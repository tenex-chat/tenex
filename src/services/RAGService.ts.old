import { connect, type Connection, type Table } from '@lancedb/lancedb';
import * as path from 'path';
import { EmbeddingProvider, LocalTransformerEmbeddingProvider } from './EmbeddingProvider.js';

export interface RAGDocument {
    id?: string;
    content: string;
    metadata?: Record<string, any>;
    vector?: Float32Array;
    timestamp?: number;
    source?: string;
}

export interface RAGCollection {
    name: string;
    schema?: Record<string, any>;
    created_at: number;
    updated_at: number;
}

export interface RAGQueryResult {
    document: RAGDocument;
    score: number;
}

export class RAGService {
    private static instance: RAGService | null = null;
    private connection: Connection | null = null;
    private embeddingProvider: EmbeddingProvider;
    private dataDir: string;
    private collections: Map<string, Table> = new Map();

    private constructor() {
        // Get data directory from environment or use default
        this.dataDir = process.env.LANCEDB_DATA_DIR || path.join(process.cwd(), 'data', 'lancedb');
        
        // Initialize embedding provider
        this.embeddingProvider = new LocalTransformerEmbeddingProvider();
    }

    public static getInstance(): RAGService {
        if (!RAGService.instance) {
            RAGService.instance = new RAGService();
        }
        return RAGService.instance;
    }

    private async ensureConnection(): Promise<Connection> {
        if (!this.connection) {
            this.connection = await connect(this.dataDir);
        }
        return this.connection;
    }

    /**
     * Create a new collection (LanceDB table)
     */
    public async createCollection(name: string, schema?: Record<string, any>): Promise<RAGCollection> {
        const connection = await this.ensureConnection();
        
        // Check if collection already exists
        const tables = await connection.tableNames();
        if (tables.includes(name)) {
            throw new Error(`Collection ${name} already exists`);
        }

        // Create initial schema with vector column
        const defaultSchema = {
            id: 'string',
            content: 'string',
            vector: `vector(${await this.embeddingProvider.getDimensions()})`,
            metadata: 'string', // JSON string
            timestamp: 'int64',
            source: 'string'
        };

        const finalSchema = { ...defaultSchema, ...schema };

        // Create empty table with schema
        const table = await connection.createTable(
            name,
            [{
                id: 'initial',
                content: '',
                vector: new Float32Array(await this.embeddingProvider.getDimensions()).fill(0),
                metadata: '{}',
                timestamp: Date.now(),
                source: 'system'
            }],
            { mode: 'overwrite' }
        );

        // Delete the initial row
        await table.delete("id = 'initial'");

        this.collections.set(name, table);

        return {
            name,
            schema: finalSchema,
            created_at: Date.now(),
            updated_at: Date.now()
        };
    }

    /**
     * Add documents to a collection
     */
    public async addDocuments(collectionName: string, documents: RAGDocument[]): Promise<void> {
        const connection = await this.ensureConnection();
        
        // Get or open table
        let table = this.collections.get(collectionName);
        if (!table) {
            const tables = await connection.tableNames();
            if (!tables.includes(collectionName)) {
                throw new Error(`Collection ${collectionName} does not exist`);
            }
            table = await connection.openTable(collectionName);
            this.collections.set(collectionName, table);
        }

        // Process documents in batches for efficiency
        const batchSize = 100;
        for (let i = 0; i < documents.length; i += batchSize) {
            const batch = documents.slice(i, i + batchSize);
            
            // Generate embeddings for documents without vectors
            const processedDocs = await Promise.all(
                batch.map(async (doc) => {
                    const vector = doc.vector || await this.embeddingProvider.embed(doc.content);
                    
                    return {
                        id: doc.id || `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        content: doc.content,
                        vector: Array.from(vector), // Convert Float32Array to regular array for LanceDB
                        metadata: JSON.stringify(doc.metadata || {}),
                        timestamp: doc.timestamp || Date.now(),
                        source: doc.source || 'user'
                    };
                })
            );

            // Add to table
            await table.add(processedDocs);
        }
    }

    /**
     * Query a collection with semantic search
     */
    public async query(
        collectionName: string,
        queryText: string,
        topK: number = 5
    ): Promise<RAGQueryResult[]> {
        const connection = await this.ensureConnection();
        
        // Get or open table
        let table = this.collections.get(collectionName);
        if (!table) {
            const tables = await connection.tableNames();
            if (!tables.includes(collectionName)) {
                throw new Error(`Collection ${collectionName} does not exist`);
            }
            table = await connection.openTable(collectionName);
            this.collections.set(collectionName, table);
        }

        // Generate embedding for query
        const queryVector = await this.embeddingProvider.embed(queryText);

        // Perform vector search
        const searchQuery = table
            .search(Array.from(queryVector))
            .limit(topK);
        
        // Execute and collect results
        const results: any[] = [];
        for await (const batch of searchQuery) {
            for (const result of batch) {
                results.push(result);
            }
        }

        // Transform results
        return results.map((result: any) => ({
            document: {
                id: result.id,
                content: result.content,
                metadata: JSON.parse(result.metadata || '{}'),
                timestamp: result.timestamp,
                source: result.source
            },
            score: result._distance !== undefined ? (1 - result._distance) : 0
        }));
    }

    /**
     * Delete a collection
     */
    public async deleteCollection(name: string): Promise<void> {
        const connection = await this.ensureConnection();
        
        const tables = await connection.tableNames();
        if (!tables.includes(name)) {
            throw new Error(`Collection ${name} does not exist`);
        }

        await connection.dropTable(name);
        this.collections.delete(name);
    }

    /**
     * List all collections
     */
    public async listCollections(): Promise<string[]> {
        const connection = await this.ensureConnection();
        return await connection.tableNames();
    }

    /**
     * Set a custom embedding provider
     */
    public setEmbeddingProvider(provider: EmbeddingProvider): void {
        this.embeddingProvider = provider;
    }

    /**
     * Cleanup and close connections
     */
    public async close(): Promise<void> {
        this.collections.clear();
        this.connection = null;
    }
}