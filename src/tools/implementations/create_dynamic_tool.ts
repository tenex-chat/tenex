import { mkdir, writeFile } from "node:fs/promises";
import { homedir } from "node:os";
import { join } from "node:path";
import { getProjectContext } from "@/services/projects";
import type { AISdkTool, ToolExecutionContext } from "@/tools/types";
import { logger } from "@/utils/logger";
import { tool } from "ai";
import { z } from "zod";

const createDynamicToolSchema = z.object({
    name: z
        .string()
        .regex(/^[a-z0-9_]+$/)
        .describe("Tool name (lowercase, alphanumeric and underscores only)"),
    description: z.string().describe("Clear description of what the tool does"),
    inputSchema: z
        .string()
        .describe(
            'Zod schema definition as TypeScript code (e.g., "z.object({ param: z.string() })")'
        ),
    implementation: z
        .string()
        .describe(
            "The async function body that implements the tool logic (without the function declaration)"
        ),
    humanReadableFormat: z
        .string()
        .nullable()
        .describe(
            "Optional template string for human-readable output (use ${input.paramName} for parameters)"
        ),
});

type CreateDynamicToolInput = z.infer<typeof createDynamicToolSchema>;

/**
 * Create a tool for dynamically creating new tools
 */
export function createCreateDynamicToolTool(context: ToolExecutionContext): AISdkTool {
    const aiTool = tool({
        description:
            "Create a new dynamic tool that can be used immediately by agents. The tool will be saved as a TypeScript file and automatically loaded.",

        inputSchema: createDynamicToolSchema,

        execute: async (input: CreateDynamicToolInput) => {
            const { name, description, inputSchema, implementation, humanReadableFormat } = input;

            // Generate the tool code
            const toolCode = `import { tool, type CoreTool } from 'ai';
import { z } from 'zod';
import type { ToolExecutionContext, AISdkTool } from '@/tools/types';

/**
 * Dynamic Tool: ${name}
 * 
 * ${description}
 * 
 * Auto-generated by agent: ${context.agent.name}
 */

// Define the input schema
const ${name}Schema = ${inputSchema};

// Type for the tool input
type ${name.charAt(0).toUpperCase() + name.slice(1)}Input = z.infer<typeof ${name}Schema>;

/**
 * Factory function to create the ${name} tool
 */
const create${name.charAt(0).toUpperCase() + name.slice(1)}Tool = (context: ToolExecutionContext): AISdkTool => {
    const aiTool = tool({
        description: '${description.replace(/'/g, "\\'")}',
        
        inputSchema: ${name}Schema,
        
        execute: async (input: ${name.charAt(0).toUpperCase() + name.slice(1)}Input) => {
            ${implementation
                .split("\n")
                .map((line) => `            ${line}`)
                .join("\n")
                .trim()}
        },
    });
    
    ${
        humanReadableFormat
            ? `// Add human-readable content generation
    Object.defineProperty(aiTool, 'getHumanReadableContent', {
        value: (input: ${name.charAt(0).toUpperCase() + name.slice(1)}Input) => {
            return \`${humanReadableFormat}\`;
        },
        enumerable: false,
        configurable: true
    });`
            : ""
    }
    
    return aiTool as AISdkTool;
};

// Export the factory function as default
export default create${name.charAt(0).toUpperCase() + name.slice(1)}Tool;`;

            // Determine the file path - must match DynamicToolService's watched path
            // Use double underscore (__) to separate agent name from tool name
            // This allows agent names with underscores to be parsed correctly
            const dynamicToolsDir = join(homedir(), ".tenex", "tools");
            const fileName = `agent_${context.agent.name.toLowerCase().replace(/[^a-z0-9]/g, "_")}__${name}.ts`;
            const filePath = join(dynamicToolsDir, fileName);

            // Ensure the directory exists
            await mkdir(dynamicToolsDir, { recursive: true });

            // Write the tool file
            await writeFile(filePath, toolCode, "utf-8");

            // Load the tool synchronously to make it immediately available
            // This bypasses the 300ms debounce in the file watcher
            const { dynamicToolService } = await import("@/services/DynamicToolService");
            await dynamicToolService.loadToolSync(filePath);

            // Inject the new tool into the active execution's tool set
            // This makes it available immediately in the current streaming session
            if (context.activeToolsObject) {
                const dynamicTools = dynamicToolService.getDynamicToolsObject(context);
                if (dynamicTools[name]) {
                    context.activeToolsObject[name] = dynamicTools[name];
                    logger.info(`[CreateDynamicTool] Injected tool '${name}' into active execution context`);
                }
            }

            logger.info("[CreateDynamicTool] Created new dynamic tool", {
                name,
                agent: context.agent.name,
                file: fileName,
                path: filePath,
            });

            // Update the agent's tool list to include the new tool
            // Get the agent's current tool list from the execution context
            const currentTools = context.agent.tools || [];

            // Add the new tool's name to the list
            const updatedTools = [...currentTools, name];

            // Save the updated tool list to the agent's persistent configuration
            try {
                const projectContext = getProjectContext();
                const agentRegistry = projectContext.agentRegistry;
                const { agentStorage } = await import("@/agents/AgentStorage");

                // Update in storage then reload into registry
                await agentStorage.updateAgentTools(context.agent.pubkey, updatedTools);
                await agentRegistry.reloadAgent(context.agent.pubkey);

                logger.info(
                    `[CreateDynamicTool] Added tool '${name}' to agent '${context.agent.name}'`
                );
            } catch (error) {
                logger.error(
                    `Failed to persist updated tool list for agent ${context.agent.name}:`,
                    {
                        agentPubkey: context.agent.pubkey,
                        toolName: name,
                        error: error instanceof Error ? error.message : String(error),
                    }
                );
            }

            return {
                success: true,
                toolName: name,
                fileName,
                path: filePath,
                message: `Successfully created dynamic tool '${name}'. The tool is now available and you can use it immediately.`,
            };
        },
    });

    Object.defineProperty(aiTool, "getHumanReadableContent", {
        value: ({ name }: CreateDynamicToolInput) => {
            return `Creating dynamic tool: ${name}`;
        },
        enumerable: false,
        configurable: true,
    });

    return aiTool as AISdkTool;
}
