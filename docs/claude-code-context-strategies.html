<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Claude Code Session Context: Strategy Options</title>
  <style>
    :root {
      --ink: #1b1a17;
      --muted: #4c4741;
      --paper: #f8f2e8;
      --paper-2: #f3efe6;
      --accent: #c45d3a;
      --accent-2: #2e6b62;
      --accent-3: #bf9b30;
      --line: rgba(27, 26, 23, 0.15);
      --shadow: 0 18px 40px rgba(27, 26, 23, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      color: var(--ink);
      background:
        radial-gradient(1000px 600px at 10% -10%, rgba(196, 93, 58, 0.16), transparent 60%),
        radial-gradient(800px 500px at 90% 0%, rgba(46, 107, 98, 0.14), transparent 62%),
        linear-gradient(180deg, #f7f1e7 0%, #f0efe8 45%, #f6f2ea 100%);
      font-family: "Iowan Old Style", "Baskerville", "Big Caslon", "Palatino Linotype", serif;
    }

    .orb {
      position: fixed;
      border-radius: 50%;
      filter: blur(0px);
      opacity: 0.12;
      z-index: 0;
      pointer-events: none;
      animation: drift 18s ease-in-out infinite;
    }

    .orb.one {
      width: 320px;
      height: 320px;
      background: #e0a050;
      top: 8%;
      left: -80px;
    }

    .orb.two {
      width: 260px;
      height: 260px;
      background: #5a9c86;
      bottom: 10%;
      right: -60px;
      animation-delay: 2s;
    }

    main {
      position: relative;
      z-index: 1;
      max-width: 1100px;
      margin: 0 auto;
      padding: 48px 24px 72px;
      animation: fadeUp 0.8s ease-out;
    }

    header.hero {
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.7);
      box-shadow: var(--shadow);
      padding: 32px 36px;
      border-radius: 18px;
      backdrop-filter: blur(6px);
    }

    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-size: 12px;
      font-family: "Gill Sans", "Avenir Next", "Futura", sans-serif;
      color: var(--accent-2);
      margin-bottom: 12px;
    }

    h1 {
      margin: 0 0 16px;
      font-size: clamp(30px, 4vw, 44px);
      line-height: 1.05;
      font-family: "Avenir Next", "Futura", "Gill Sans", sans-serif;
    }

    p {
      margin: 0 0 12px;
      line-height: 1.6;
      color: var(--muted);
      font-size: 16px;
    }

    .hero-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      margin-top: 22px;
    }

    .hero-pill {
      border: 1px solid var(--line);
      background: var(--paper);
      padding: 12px 16px;
      border-radius: 999px;
      font-family: "Gill Sans", "Avenir Next", "Futura", sans-serif;
      font-size: 13px;
      color: var(--ink);
    }

    section {
      margin-top: 36px;
    }

    h2 {
      font-family: "Avenir Next", "Futura", "Gill Sans", sans-serif;
      font-size: 22px;
      margin-bottom: 14px;
    }

    h3 {
      font-family: "Avenir Next", "Futura", "Gill Sans", sans-serif;
      font-size: 18px;
      margin: 0 0 10px;
    }

    .card-grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .card {
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.75);
      border-radius: 16px;
      padding: 20px 22px;
      box-shadow: 0 10px 24px rgba(27, 26, 23, 0.08);
      animation: fadeUp 0.9s ease-out;
    }

    .card .tag {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-family: "Gill Sans", "Avenir Next", "Futura", sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: var(--paper-2);
      border: 1px solid var(--line);
      color: var(--accent);
      margin-bottom: 10px;
    }

    .split {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    ul {
      padding-left: 18px;
      margin: 8px 0 0;
      line-height: 1.55;
      color: var(--muted);
    }

    .callout {
      border: 1px dashed var(--line);
      background: rgba(255, 255, 255, 0.8);
      padding: 16px 20px;
      border-radius: 12px;
    }

    .diagram {
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 16px 18px;
      font-family: "SFMono-Regular", "Menlo", "Consolas", "Liberation Mono", monospace;
      font-size: 13px;
      color: #2d2a26;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 12px;
      overflow: hidden;
    }

    th, td {
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      text-align: left;
      vertical-align: top;
    }

    th {
      font-family: "Gill Sans", "Avenir Next", "Futura", sans-serif;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 12px;
      color: var(--accent-2);
      background: rgba(243, 239, 230, 0.85);
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    footer {
      margin-top: 46px;
      font-size: 13px;
      color: var(--muted);
    }

    @keyframes fadeUp {
      from {
        opacity: 0;
        transform: translateY(12px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes drift {
      0% {
        transform: translateY(0px);
      }
      50% {
        transform: translateY(-18px);
      }
      100% {
        transform: translateY(0px);
      }
    }

    @media (max-width: 720px) {
      header.hero {
        padding: 24px;
      }
      .hero-pill {
        font-size: 12px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      * {
        animation: none !important;
      }
    }
  </style>
</head>
<body>
  <div class="orb one"></div>
  <div class="orb two"></div>
  <main>
    <header class="hero">
      <div class="eyebrow">TENEX design memo</div>
      <h1>Claude Code session context without duplicate history</h1>
      <p>
        Problem: Claude Code preserves its own session history, but TENEX currently sends
        the full message history on resume. This duplicates context, inflates tokens,
        and can skew behavior.
      </p>
      <div class="hero-grid">
        <div class="hero-pill">Constraint: keep Claude Code internal memory</div>
        <div class="hero-pill">Need: support message injection and tool results</div>
        <div class="hero-pill">Goal: move complexity away from AgentExecutor</div>
      </div>
    </header>

    <section>
      <h2>Current pipeline snapshot</h2>
      <div class="diagram">
AgentExecutor -> ConversationStore.buildMessagesForRal -> LLMService.stream
    |                          |                           |
    |                          |                           +-- for claudeCode: resume session
    |                          |                               but messages[] still full history
    +-- system prompts + todo + response context are appended every step
      </div>
    </section>

    <section>
      <h2>Design goals and constraints</h2>
      <div class="card-grid">
        <div class="card">
          <h3>Goals</h3>
          <ul>
            <li>Eliminate duplicate history on session resume.</li>
            <li>Preserve Claude Code internal memory and tool behavior.</li>
            <li>Keep injection support (nudge, supervision, dynamic tools).</li>
            <li>Maintain correctness for tool call and tool result replay.</li>
            <li>Keep the solution testable and observable.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Constraints</h3>
          <ul>
            <li>AgentExecutor already complex; avoid piling more branching there.</li>
            <li>ConversationStore is the source of truth for messages.</li>
            <li>Provider capabilities differ (sessionResumption only for some).</li>
            <li>System prompts include both static and per-turn dynamic content.</li>
            <li>Resume must stay safe when worktree or branch changes.</li>
          </ul>
        </div>
      </div>
    </section>

    <section>
      <h2>Alternative A: Session cursor and delta-only messages</h2>
      <div class="card">
        <div class="tag">Option A</div>
        <div class="split">
          <div>
            <h3>High level</h3>
            <p>
              Track the last message that was sent to the provider and only send
              new messages after that cursor when resuming a session.
            </p>
          </div>
          <div>
            <h3>Implementation sketch</h3>
            <ul>
              <li>Add a monotonic message index to ConversationStore entries.</li>
              <li>Persist per session cursor in SessionManager metadata.</li>
              <li>Add ConversationStore.buildMessagesForRalSince(cursor).</li>
              <li>When provider supports sessionResumption and sessionId exists,
                  send only delta messages + dynamic system updates.</li>
              <li>Advance cursor on successful completion; keep stable on abort.</li>
            </ul>
          </div>
        </div>
        <div class="split">
          <div>
            <h3>Pros</h3>
            <ul>
              <li>Minimal token overhead, avoids duplication entirely.</li>
              <li>Leverages existing SessionManager and ConversationStore.</li>
              <li>Simple mental model once cursor is in place.</li>
            </ul>
          </div>
          <div>
            <h3>Cons</h3>
            <ul>
              <li>Cursor correctness is critical (failure and retries).</li>
              <li>Requires new message indexing or event-to-message mapping.</li>
              <li>Need to decide which system messages are re-sent each turn.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section>
      <h2>Alternative B: Provider context strategy layer</h2>
      <div class="card">
        <div class="tag">Option B</div>
        <div class="split">
          <div>
            <h3>High level</h3>
            <p>
              Introduce a context strategy interface that compiles messages based
              on provider capabilities. AgentExecutor stays clean, strategies handle
              full history vs session delta.
            </p>
          </div>
          <div>
            <h3>Implementation sketch</h3>
            <ul>
              <li>Create ContextStrategy in src/llm or src/services/llm.</li>
              <li>Strategies: FullHistoryStrategy, SessionDeltaStrategy, HybridSummaryStrategy.</li>
              <li>Use provider metadata capabilities.sessionResumption to select strategy.</li>
              <li>Strategy handles message slicing and post-send cursor updates.</li>
            </ul>
          </div>
        </div>
        <div class="split">
          <div>
            <h3>Pros</h3>
            <ul>
              <li>Centralizes policy decisions outside AgentExecutor.</li>
              <li>Reusable for codex-cli or future agent providers.</li>
              <li>Clear test surface for each strategy.</li>
            </ul>
          </div>
          <div>
            <h3>Cons</h3>
            <ul>
              <li>New abstraction layer to maintain.</li>
              <li>Needs plumbing for provider metadata into LLMService or strategy factory.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section>
      <h2>Alternative C: Checkpoint summary plus delta</h2>
      <div class="card">
        <div class="tag">Option C</div>
        <div class="split">
          <div>
            <h3>High level</h3>
            <p>
              When resuming a session, send a compact summary of prior context
              (checkpoint) plus only the new delta messages. Claude Code keeps
              its internal memory, but the checkpoint guards against drift.
            </p>
          </div>
          <div>
            <h3>Implementation sketch</h3>
            <ul>
              <li>Use ConversationSummarizer to maintain rolling summary in metadata.</li>
              <li>Track last summarized event or message index.</li>
              <li>On resume, prepend summary as a user message or system injection.</li>
              <li>Send only messages after the summary checkpoint.</li>
            </ul>
          </div>
        </div>
        <div class="split">
          <div>
            <h3>Pros</h3>
            <ul>
              <li>Resilient to session loss or cross-provider fallbacks.</li>
              <li>Balances internal memory with explicit context anchor.</li>
            </ul>
          </div>
          <div>
            <h3>Cons</h3>
            <ul>
              <li>Summary quality risk, especially for tool-heavy sessions.</li>
              <li>Extra summarization cost and lifecycle management.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section>
      <h2>Alternative D: Provider history ledger with hashes</h2>
      <div class="card">
        <div class="tag">Option D</div>
        <div class="split">
          <div>
            <h3>High level</h3>
            <p>
              Maintain a ledger of message hashes that were actually sent to
              the provider. On each request, send only messages not already in the ledger.
            </p>
          </div>
          <div>
            <h3>Implementation sketch</h3>
            <ul>
              <li>Add ProviderHistoryLedgerService under src/services.</li>
              <li>Hash role + content + tool data for each message.</li>
              <li>Filter messages against the ledger when resuming a session.</li>
              <li>Update ledger only after stream completion succeeds.</li>
            </ul>
          </div>
        </div>
        <div class="split">
          <div>
            <h3>Pros</h3>
            <ul>
              <li>Does not require new message IDs or event mapping.</li>
              <li>Portable across providers with session memory.</li>
              <li>Flexible for mixed or reordered message sources.</li>
            </ul>
          </div>
          <div>
            <h3>Cons</h3>
            <ul>
              <li>Hash mismatches if content changes post-send.</li>
              <li>Ledger growth and extra storage overhead.</li>
              <li>Harder to reason about compared to simple cursor.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section>
      <h2>Alternative E: Split static vs dynamic system prompts</h2>
      <div class="card">
        <div class="tag">Option E</div>
        <div class="split">
          <div>
            <h3>High level</h3>
            <p>
              Separate system prompts into static (only on session start) and
              dynamic (every turn). On resume, send only dynamic prompts and the
              new conversation delta.
            </p>
          </div>
          <div>
            <h3>Implementation sketch</h3>
            <ul>
              <li>Extend buildSystemPromptMessages to mark prompts as static or dynamic.</li>
              <li>Use compileMessagesForClaudeCode only for static prompts on new session.</li>
              <li>Convert dynamic prompts to user messages when resuming.</li>
              <li>Combine with delta message slicing (Option A or D).</li>
            </ul>
          </div>
        </div>
        <div class="split">
          <div>
            <h3>Pros</h3>
            <ul>
              <li>Stops re-sending large static identity context.</li>
              <li>Ensures todo list and response context stay fresh.</li>
              <li>Improves clarity about what changes per turn.</li>
            </ul>
          </div>
          <div>
            <h3>Cons</h3>
            <ul>
              <li>Requires prompt builder refactor.</li>
              <li>Needs decisions on what is static vs dynamic.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section>
      <h2>Comparison matrix</h2>
      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Change scope</th>
            <th>Duplication fix</th>
            <th>Complexity</th>
            <th>Resilience</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>A - Session cursor</td>
            <td>ConversationStore + SessionManager</td>
            <td>Strong</td>
            <td>Medium</td>
            <td>Medium</td>
          </tr>
          <tr>
            <td>B - Strategy layer</td>
            <td>New strategy module</td>
            <td>Strong</td>
            <td>Medium</td>
            <td>High</td>
          </tr>
          <tr>
            <td>C - Summary checkpoint</td>
            <td>ConversationSummarizer + policy</td>
            <td>Medium</td>
            <td>High</td>
            <td>High</td>
          </tr>
          <tr>
            <td>D - Hash ledger</td>
            <td>New service + filtering</td>
            <td>Strong</td>
            <td>High</td>
            <td>Medium</td>
          </tr>
          <tr>
            <td>E - Prompt split</td>
            <td>Prompt builder refactor</td>
            <td>Partial</td>
            <td>Medium</td>
            <td>Medium</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2>Edge cases and guardrails</h2>
      <div class="card-grid">
        <div class="card">
          <h3>Failure and retry</h3>
          <ul>
            <li>Advance cursor only after confirmed completion.</li>
            <li>On abort, keep cursor to resend last delta safely.</li>
            <li>Log a mismatch signal if sessionId exists but cursor missing.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Dynamic system updates</h3>
          <ul>
            <li>Todo list and response context should always be re-sent.</li>
            <li>Convert dynamic system prompts to user messages on resume.</li>
            <li>Keep static identity prompt as session start only.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Session mismatch detection</h3>
          <ul>
            <li>Invalidate resume if workingDirectory or branch changes.</li>
            <li>Fallback to new session with full context if mismatch.</li>
            <li>Record metrics for how often resume is disabled.</li>
          </ul>
        </div>
      </div>
    </section>

    <section>
      <h2>Suggested experiments</h2>
      <div class="callout">
        <p>
          Start with Option A plus the prompt split in Option E. That gives a
          minimal path to remove duplication while keeping dynamic context fresh.
          Wrap it in Option B later if the strategy surface grows.
        </p>
        <ul>
          <li>Instrument prompt token counts for claudeCode resume vs new session.</li>
          <li>Add tests for cursor advance and resend on abort.</li>
          <li>Validate that tool call results stay in sync across resume.</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>Open questions</h2>
      <div class="card">
        <ul>
          <li>Should cursor track NDK event IDs or internal message indices?</li>
          <li>Which system prompt fragments are truly static?</li>
          <li>How should we handle cross-provider switching mid conversation?</li>
          <li>Do we need a user-visible toggle to reset session state?</li>
        </ul>
      </div>
    </section>

    <footer>
      Draft for discussion. The options can be combined; most likely path is
      Option A (cursor) + Option E (prompt split) with Option B as a structural
      refactor once policy grows.
    </footer>
  </main>
</body>
</html>
