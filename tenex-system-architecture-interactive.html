<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TENEX System Architecture - Interactive</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            overflow: hidden;
        }
        
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }
        
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .header p {
            margin: 5px 0 0 0;
            opacity: 0.9;
            font-size: 14px;
        }
        
        .container {
            display: flex;
            height: 100vh;
            padding-top: 70px;
        }
        
        .diagram-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #f5f5f5;
        }
        
        .diagram-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            cursor: grab;
        }
        
        .diagram-wrapper.grabbing {
            cursor: grabbing;
        }
        
        .mermaid {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform-origin: 0 0;
            transition: none;
            display: inline-block;
            min-width: 3000px;
        }
        
        /* Zoom controls */
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .zoom-controls button {
            width: 40px;
            height: 40px;
            border: none;
            background: #3498db;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .zoom-controls button:hover {
            background: #2980b9;
        }
        
        .zoom-controls button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        
        .zoom-controls .zoom-level {
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 14px;
            color: #555;
            min-width: 60px;
            justify-content: center;
        }
        
        /* Navigation help */
        .nav-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Drawer styles */
        .drawer {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background-color: white;
            box-shadow: -2px 0 8px rgba(0,0,0,0.15);
            transition: right 0.3s ease-in-out;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .drawer.open {
            right: 0;
        }
        
        .drawer-header {
            background-color: #3498db;
            color: white;
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .drawer-header h2 {
            margin: 0 0 5px 0;
            font-size: 20px;
        }
        
        .drawer-header .type {
            font-size: 12px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .drawer-close {
            position: absolute;
            right: 20px;
            top: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .drawer-close:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .drawer-content {
            padding: 20px;
        }
        
        .drawer-content h3 {
            color: #2c3e50;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        
        .drawer-content h3:first-child {
            margin-top: 0;
        }
        
        .drawer-content p {
            line-height: 1.6;
            color: #555;
            margin: 10px 0;
        }
        
        .drawer-content ul {
            padding-left: 20px;
            margin: 10px 0;
        }
        
        .drawer-content li {
            margin: 5px 0;
            line-height: 1.6;
            color: #555;
        }
        
        .drawer-content code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }
        
        .file-path {
            background-color: #ecf0f1;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
            word-break: break-all;
        }
        
        .connection-flow {
            background-color: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
        }
        
        .connection-flow h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 14px;
        }
        
        /* Overlay for drawer */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.3);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 999;
        }
        
        .overlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* Make clickable elements more obvious */
        .node rect, .node circle, .node polygon {
            cursor: pointer !important;
        }
        
        .node:hover rect, .node:hover circle, .node:hover polygon {
            stroke-width: 3px !important;
            filter: brightness(1.1);
        }

        .edgePath:hover path {
            stroke-width: 3px !important;
            cursor: pointer;
        }

        /* Highlight clickable connections */
        .clickable-edge path {
            cursor: pointer !important;
            stroke-width: 2px;
        }
        
        .clickable-edge:hover path {
            stroke-width: 4px !important;
            stroke: #3498db !important;
        }
        
        /* Override mermaid default sizes */
        #diagram {
            font-size: 16px !important;
        }
        
        #diagram .nodeLabel {
            font-size: 14px !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>TENEX System Architecture</h1>
        <p>Click on any component or connection to learn more ‚Ä¢ Use mouse to pan ‚Ä¢ Scroll to zoom</p>
    </div>

    <div class="container">
        <div class="diagram-container">
            <div class="diagram-wrapper" id="diagramWrapper">
                <div class="mermaid" id="diagram">
%%{init: {'theme':'default', 'themeVariables': { 'fontSize': '16px'}}}%%
graph TB
    %% External Interfaces
    subgraph "External Interfaces"
        CLI[CLI Commands<br/>tenex.ts]
        NostrNetwork[Nostr Network<br/>Relays]
        WebClient[Web/iOS Clients]
        LLMProviders[LLM Providers<br/>OpenAI/Anthropic/etc]
        MCPServers[MCP Servers]
    end

    %% Core System Entry Points
    subgraph "System Entry Points"
        CLI --> ProjectCmd[project run]
        CLI --> DaemonCmd[daemon]
        CLI --> SetupCmd[setup]
        CLI --> AgentCmd[agent]
        CLI --> MCPCmd[mcp]
        
        NostrNetwork -->|events| EventMonitor[EventMonitor<br/>Daemon Mode]
        WebClient --> NostrNetwork
    end

    %% Event Processing Layer
    subgraph "Event Processing Layer"
        EventHandler[EventHandler<br/>Event Router]
        EventHandler --> NewConvHandler[New Conversation<br/>Handler]
        EventHandler --> ReplyHandler[Reply Handler]
        EventHandler --> TaskHandler[Task Handler]
        EventHandler --> ProjectHandler[Project Handler]
        EventHandler --> ConfigUpdateHandler[Config Update<br/>Handler]
        
        NostrNetwork -->|kind: 11,1111,1934| EventHandler
        EventMonitor --> ProcessManager[ProcessManager]
        ProcessManager --> EventHandler
    end

    %% Conversation Management
    subgraph "Conversation Management"
        ConvCoord[ConversationCoordinator<br/>Central State Manager]
        ConvStore[ConversationStore<br/>In-Memory Cache]
        FSAdapter[FileSystemAdapter<br/>Persistence]
        PhaseManager[PhaseManager<br/>Workflow Control]
        MessageBuilder[MessageBuilder<br/>Context Assembly]
        
        ConvCoord --> ConvStore
        ConvCoord --> FSAdapter
        ConvCoord --> PhaseManager
        ConvCoord --> MessageBuilder
        
        NewConvHandler --> ConvCoord
        ReplyHandler --> ConvCoord
        TaskHandler --> ConvCoord
    end

    %% Agent System
    subgraph "Agent System"
        AgentRegistry[AgentRegistry<br/>Agent Management]
        AgentExecutor[AgentExecutor<br/>Execution Orchestrator]
        ReasonActLoop[ReasonActLoop<br/>Streaming Backend]
        
        subgraph "Built-in Agents"
            Orchestrator[Orchestrator<br/>Routing Agent]
            Planner[Planner Agent]
            Executor[Executor Agent]
            ProjectManager[Project Manager]
        end
        
        AgentRegistry --> Orchestrator
        AgentRegistry --> Planner
        AgentRegistry --> Executor
        AgentRegistry --> ProjectManager
        
        EventHandler -->|triggers| AgentExecutor
        AgentExecutor -->|executes| ReasonActLoop
    end

    %% Execution Pipeline
    subgraph "Execution Pipeline"
        StreamStateManager[StreamStateManager<br/>State Tracking]
        ToolStreamHandler[ToolStreamHandler<br/>Tool Events]
        TerminationHandler[TerminationHandler<br/>Completion]
        ToolRepetitionDetector[Tool Repetition<br/>Detector]
        
        ReasonActLoop -->|manages| StreamStateManager
        ReasonActLoop --> ToolStreamHandler
        ReasonActLoop --> TerminationHandler
        ReasonActLoop --> ToolRepetitionDetector
    end

    %% LLM Integration
    subgraph "LLM Integration Layer"
        LLMRouter[LLMRouter<br/>Provider Orchestration]
        ConfigService[ConfigService<br/>Config Management]
        ModelSelector[ModelSelector<br/>Model Discovery]
        LLMTester[LLMTester<br/>Validation]
        PricingService[Pricing Service<br/>Cost Optimization]
        CallLogger[CallLogger<br/>Observability]
        
        LLMRouter --> ConfigService
        LLMRouter --> ModelSelector
        LLMRouter --> LLMTester
        LLMRouter --> PricingService
        LLMRouter --> CallLogger
        
        AgentExecutor -->|requests| LLMRouter
        LLMRouter -->|calls| LLMProviders
    end

    %% Tool System
    subgraph "Tool System"
        ToolRegistry[ToolRegistry<br/>Tool Management]
        ToolExecutor[ToolExecutor<br/>Execution Engine]
        ToolPlugin[ToolPlugin<br/>LLM Adapter]
        
        subgraph "Built-in Tools"
            FileTools[File Tools<br/>read/write]
            ControlTools[Control Tools<br/>complete/continue]
            AnalysisTools[Analysis Tools<br/>analyze/learn]
            ExecutionTools[Execution Tools<br/>shell/inventory]
            DelegationTools[Delegation Tools<br/>delegate/delegate_external]
        end
        
        subgraph "External Tools"
            MCPToolAdapter[MCPToolAdapter<br/>MCP Bridge]
            MCPService[MCPService<br/>Server Management]
        end
        
        ToolRegistry --> FileTools
        ToolRegistry --> ControlTools
        ToolRegistry --> AnalysisTools
        ToolRegistry --> ExecutionTools
        ToolRegistry --> DelegationTools
        
        MCPService --> MCPToolAdapter
        MCPToolAdapter --> ToolRegistry
        MCPServers --> MCPService
        
        ToolStreamHandler -->|executes| ToolExecutor
        ToolExecutor --> ToolRegistry
        LLMRouter --> ToolPlugin
        ToolPlugin -->|wraps| ToolExecutor
    end

    %% Publishing System
    subgraph "Publishing System"
        NostrPublisher[NostrPublisher<br/>Event Publisher]
        StreamPublisher[StreamPublisher<br/>Real-time Streaming]
        StatusPublisher[StatusPublisher<br/>Heartbeat]
        TypingIndicatorMgr[TypingIndicator<br/>Manager]
        AgentEventEncoder[AgentEventEncoder<br/>Event Serialization]
        
        NostrPublisher --> StreamPublisher
        NostrPublisher --> TypingIndicatorMgr
        NostrPublisher --> AgentEventEncoder
        
        AgentExecutor --> NostrPublisher
        ProjectCmd --> StatusPublisher
        
        NostrPublisher -->|publishes| NostrNetwork
        StatusPublisher --> NostrNetwork
    end

    %% Learning System
    subgraph "Learning & Context"
        LessonStorage[Agent Lessons<br/>NDKAgentLesson]
        ProjectContext[ProjectContext<br/>PROJECT.md/INVENTORY.md]
        PromptBuilder[PromptBuilder<br/>System Prompts]
        FragmentRegistry[FragmentRegistry<br/>Prompt Fragments]
        
        AnalysisTools -->|creates| LessonStorage
        ProjectManager --> ProjectContext
        AgentExecutor --> PromptBuilder
        PromptBuilder --> FragmentRegistry
        
        LessonStorage -->|stores| NostrNetwork
    end

    %% Persistence & State
    subgraph "Persistence Layer"
        ConvPersistence[Conversation Files<br/>.tenex/state/conversations/]
        ConfigFiles[Config Files<br/>.tenex/llms.json]
        LogFiles[Log Files<br/>.tenex/logs/]
        MCPCache[MCP Cache<br/>.tenex/cache/]
        
        FSAdapter --> ConvPersistence
        ConfigService --> ConfigFiles
        CallLogger --> LogFiles
        MCPService --> MCPCache
    end

    %% Data Flow Connections
    ConvCoord -->|provides context| AgentExecutor
    PhaseManager -->|controls| AgentExecutor
    MessageBuilder -->|builds messages| ReasonActLoop
    
    %% Control Flow
    Orchestrator -.->|routes to| Planner
    Orchestrator -.->|routes to| Executor
    Orchestrator -.->|routes to| ProjectManager
    
    ControlTools -.->|returns control| Orchestrator
    DelegationTools -.->|delegates to| AgentRegistry
    
    %% Styling
    classDef external fill:#f9f,stroke:#333,stroke-width:2px
    classDef core fill:#9cf,stroke:#333,stroke-width:3px
    classDef agent fill:#fc9,stroke:#333,stroke-width:2px
    classDef tool fill:#cf9,stroke:#333,stroke-width:2px
    classDef nostr fill:#f9c,stroke:#333,stroke-width:2px
    
    class CLI,NostrNetwork,WebClient,LLMProviders,MCPServers external
    class ConvCoord,AgentExecutor,LLMRouter,ToolExecutor core
    class Orchestrator,Planner,Executor,ProjectManager agent
    class FileTools,ControlTools,AnalysisTools,ExecutionTools,DelegationTools tool
    class NostrPublisher,EventHandler,StatusPublisher nostr

    %% Click handlers for nodes
    click CLI "javascript:showDetails('CLI')"
    click NostrNetwork "javascript:showDetails('NostrNetwork')"
    click WebClient "javascript:showDetails('WebClient')"
    click LLMProviders "javascript:showDetails('LLMProviders')"
    click MCPServers "javascript:showDetails('MCPServers')"
    click ProjectCmd "javascript:showDetails('ProjectCmd')"
    click DaemonCmd "javascript:showDetails('DaemonCmd')"
    click SetupCmd "javascript:showDetails('SetupCmd')"
    click AgentCmd "javascript:showDetails('AgentCmd')"
    click MCPCmd "javascript:showDetails('MCPCmd')"
    click EventMonitor "javascript:showDetails('EventMonitor')"
    click EventHandler "javascript:showDetails('EventHandler')"
    click NewConvHandler "javascript:showDetails('NewConvHandler')"
    click ReplyHandler "javascript:showDetails('ReplyHandler')"
    click TaskHandler "javascript:showDetails('TaskHandler')"
    click ProjectHandler "javascript:showDetails('ProjectHandler')"
    click ConfigUpdateHandler "javascript:showDetails('ConfigUpdateHandler')"
    click ProcessManager "javascript:showDetails('ProcessManager')"
    click ConvCoord "javascript:showDetails('ConvCoord')"
    click ConvStore "javascript:showDetails('ConvStore')"
    click FSAdapter "javascript:showDetails('FSAdapter')"
    click PhaseManager "javascript:showDetails('PhaseManager')"
    click MessageBuilder "javascript:showDetails('MessageBuilder')"
    click AgentRegistry "javascript:showDetails('AgentRegistry')"
    click AgentExecutor "javascript:showDetails('AgentExecutor')"
    click ReasonActLoop "javascript:showDetails('ReasonActLoop')"
    click Orchestrator "javascript:showDetails('Orchestrator')"
    click Planner "javascript:showDetails('Planner')"
    click Executor "javascript:showDetails('Executor')"
    click ProjectManager "javascript:showDetails('ProjectManager')"
    click StreamStateManager "javascript:showDetails('StreamStateManager')"
    click ToolStreamHandler "javascript:showDetails('ToolStreamHandler')"
    click TerminationHandler "javascript:showDetails('TerminationHandler')"
    click ToolRepetitionDetector "javascript:showDetails('ToolRepetitionDetector')"
    click LLMRouter "javascript:showDetails('LLMRouter')"
    click ConfigService "javascript:showDetails('ConfigService')"
    click ModelSelector "javascript:showDetails('ModelSelector')"
    click LLMTester "javascript:showDetails('LLMTester')"
    click PricingService "javascript:showDetails('PricingService')"
    click CallLogger "javascript:showDetails('CallLogger')"
    click ToolRegistry "javascript:showDetails('ToolRegistry')"
    click ToolExecutor "javascript:showDetails('ToolExecutor')"
    click ToolPlugin "javascript:showDetails('ToolPlugin')"
    click FileTools "javascript:showDetails('FileTools')"
    click ControlTools "javascript:showDetails('ControlTools')"
    click AnalysisTools "javascript:showDetails('AnalysisTools')"
    click ExecutionTools "javascript:showDetails('ExecutionTools')"
    click DelegationTools "javascript:showDetails('DelegationTools')"
    click MCPToolAdapter "javascript:showDetails('MCPToolAdapter')"
    click MCPService "javascript:showDetails('MCPService')"
    click NostrPublisher "javascript:showDetails('NostrPublisher')"
    click StreamPublisher "javascript:showDetails('StreamPublisher')"
    click StatusPublisher "javascript:showDetails('StatusPublisher')"
    click TypingIndicatorMgr "javascript:showDetails('TypingIndicatorMgr')"
    click AgentEventEncoder "javascript:showDetails('AgentEventEncoder')"
    click LessonStorage "javascript:showDetails('LessonStorage')"
    click ProjectContext "javascript:showDetails('ProjectContext')"
    click PromptBuilder "javascript:showDetails('PromptBuilder')"
    click FragmentRegistry "javascript:showDetails('FragmentRegistry')"
    click ConvPersistence "javascript:showDetails('ConvPersistence')"
    click ConfigFiles "javascript:showDetails('ConfigFiles')"
    click LogFiles "javascript:showDetails('LogFiles')"
    click MCPCache "javascript:showDetails('MCPCache')"
                </div>
            </div>
        </div>
    </div>

    <!-- Zoom controls -->
    <div class="zoom-controls">
        <button onclick="zoomOut()" id="zoomOutBtn">‚àí</button>
        <span class="zoom-level" id="zoomLevel">100%</span>
        <button onclick="zoomIn()" id="zoomInBtn">+</button>
        <button onclick="resetZoom()">‚ü≤</button>
    </div>

    <!-- Navigation help -->
    <div class="nav-help">
        üñ±Ô∏è Click & drag to pan ‚Ä¢ üîç Scroll to zoom ‚Ä¢ üì± Pinch to zoom
    </div>

    <!-- Drawer -->
    <div class="overlay" id="overlay"></div>
    <div class="drawer" id="drawer">
        <div class="drawer-header">
            <h2 id="drawer-title">Component Details</h2>
            <span class="type" id="drawer-type">Component</span>
            <button class="drawer-close" onclick="closeDrawer()">√ó</button>
        </div>
        <div class="drawer-content" id="drawer-content">
            <!-- Content will be inserted here -->
        </div>
    </div>

    <script>
        // Zoom and pan functionality
        let scale = 1;
        const scaleStep = 0.1;
        const minScale = 0.3;
        const maxScale = 2;
        let isPanning = false;
        let startX = 0;
        let startY = 0;
        let scrollLeft = 0;
        let scrollTop = 0;

        const diagramWrapper = document.getElementById('diagramWrapper');
        const diagram = document.getElementById('diagram');
        const zoomLevelDisplay = document.getElementById('zoomLevel');

        function updateZoomDisplay() {
            zoomLevelDisplay.textContent = Math.round(scale * 100) + '%';
            document.getElementById('zoomInBtn').disabled = scale >= maxScale;
            document.getElementById('zoomOutBtn').disabled = scale <= minScale;
        }

        function applyZoom() {
            diagram.style.transform = `scale(${scale})`;
            updateZoomDisplay();
        }

        function zoomIn() {
            if (scale < maxScale) {
                scale = Math.min(scale + scaleStep, maxScale);
                applyZoom();
            }
        }

        function zoomOut() {
            if (scale > minScale) {
                scale = Math.max(scale - scaleStep, minScale);
                applyZoom();
            }
        }

        function resetZoom() {
            scale = 1;
            applyZoom();
            diagramWrapper.scrollLeft = 0;
            diagramWrapper.scrollTop = 0;
        }

        // Mouse wheel zoom
        diagramWrapper.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }
        });

        // Pan functionality
        diagramWrapper.addEventListener('mousedown', (e) => {
            if (e.target === diagramWrapper || e.target === diagram) {
                isPanning = true;
                diagramWrapper.classList.add('grabbing');
                startX = e.pageX - diagramWrapper.offsetLeft;
                startY = e.pageY - diagramWrapper.offsetTop;
                scrollLeft = diagramWrapper.scrollLeft;
                scrollTop = diagramWrapper.scrollTop;
            }
        });

        diagramWrapper.addEventListener('mouseleave', () => {
            isPanning = false;
            diagramWrapper.classList.remove('grabbing');
        });

        diagramWrapper.addEventListener('mouseup', () => {
            isPanning = false;
            diagramWrapper.classList.remove('grabbing');
        });

        diagramWrapper.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            e.preventDefault();
            const x = e.pageX - diagramWrapper.offsetLeft;
            const y = e.pageY - diagramWrapper.offsetTop;
            const walkX = (x - startX) * 1;
            const walkY = (y - startY) * 1;
            diagramWrapper.scrollLeft = scrollLeft - walkX;
            diagramWrapper.scrollTop = scrollTop - walkY;
        });

        // Component details database
        const componentDetails = {
            // External Interfaces
            'CLI': {
                type: 'External Interface',
                title: 'CLI Commands',
                content: `
                    <h3>Overview</h3>
                    <p>The command-line interface that provides direct access to TENEX functionality.</p>
                    <div class="file-path">src/tenex.ts</div>
                    
                    <h3>Key Features</h3>
                    <ul>
                        <li><strong>Project Management</strong>: Initialize and run projects</li>
                        <li><strong>Agent Control</strong>: Add, remove, and list agents</li>
                        <li><strong>Setup Wizard</strong>: Configure LLM providers and credentials</li>
                        <li><strong>Debug Tools</strong>: Interactive chat, timeline viewer</li>
                        <li><strong>MCP Integration</strong>: Manage Model Context Protocol servers</li>
                    </ul>
                    
                    <h3>Main Commands</h3>
                    <ul>
                        <li><code>tenex project run</code> - Start a project in interactive mode</li>
                        <li><code>tenex daemon</code> - Run in background monitoring mode</li>
                        <li><code>tenex setup llm</code> - Configure LLM providers</li>
                        <li><code>tenex agent add</code> - Add custom agents to project</li>
                        <li><code>tenex debug chat</code> - Test agents interactively</li>
                    </ul>
                `
            },
            
            'NostrNetwork': {
                type: 'External Interface',
                title: 'Nostr Network',
                content: `
                    <h3>Overview</h3>
                    <p>The decentralized communication protocol that enables all agent-to-agent and user-to-agent communication.</p>
                    
                    <h3>Key Concepts</h3>
                    <ul>
                        <li><strong>Events</strong>: All communication happens through signed events</li>
                        <li><strong>Relays</strong>: Distributed servers that store and forward events</li>
                        <li><strong>Pubkeys</strong>: Cryptographic identities for users and agents</li>
                        <li><strong>Event Kinds</strong>: Different message types (11, 1111, 1934, etc.)</li>
                    </ul>
                    
                    <h3>Event Types Used</h3>
                    <ul>
                        <li><code>kind: 11</code> - New conversation initiation</li>
                        <li><code>kind: 1111</code> - Generic replies/messages</li>
                        <li><code>kind: 1934</code> - Task assignments</li>
                        <li><code>kind: 24010</code> - Status/heartbeat events</li>
                        <li><code>kind: 21111</code> - Streaming responses</li>
                    </ul>
                    
                    <h3>Integration</h3>
                    <p>TENEX uses NDK (Nostr Development Kit) as its client library, maintaining a singleton connection to multiple relays for redundancy.</p>
                `
            },
            
            'WebClient': {
                type: 'External Interface',
                title: 'Web/iOS Clients',
                content: `
                    <h3>Overview</h3>
                    <p>External client applications that interact with TENEX through the Nostr protocol.</p>
                    
                    <h3>Client Types</h3>
                    <ul>
                        <li><strong>Web Client</strong>: Browser-based interface for project creation and management</li>
                        <li><strong>iOS Client</strong>: Native mobile app for on-the-go interaction</li>
                        <li><strong>Custom Clients</strong>: Any Nostr-compatible client can interact with TENEX</li>
                    </ul>
                    
                    <h3>Communication</h3>
                    <p>Clients publish events to Nostr relays, which are then picked up by TENEX daemons monitoring for project-specific events.</p>
                    
                    <h3>Features</h3>
                    <ul>
                        <li>Create new projects and conversations</li>
                        <li>Send messages to agents</li>
                        <li>View real-time streaming responses</li>
                        <li>Monitor agent status and availability</li>
                    </ul>
                `
            },
            
            'LLMProviders': {
                type: 'External Interface',
                title: 'LLM Providers',
                content: `
                    <h3>Overview</h3>
                    <p>External AI model providers that power agent intelligence.</p>
                    
                    <h3>Supported Providers</h3>
                    <ul>
                        <li><strong>OpenAI</strong>: GPT-4, GPT-3.5-turbo models</li>
                        <li><strong>Anthropic</strong>: Claude 3 Opus, Sonnet, Haiku</li>
                        <li><strong>Google</strong>: Gemini Pro models</li>
                        <li><strong>OpenRouter</strong>: Access to 100+ models</li>
                        <li><strong>Groq</strong>: Fast inference models</li>
                        <li><strong>Mistral</strong>: Open-weight models</li>
                        <li><strong>Ollama</strong>: Local model execution</li>
                    </ul>
                    
                    <h3>Integration</h3>
                    <p>Providers are accessed through the multi-llm-ts library, which provides a unified interface across all providers.</p>
                    
                    <h3>Features</h3>
                    <ul>
                        <li>Dynamic model selection</li>
                        <li>Automatic failover</li>
                        <li>Cost tracking and optimization</li>
                        <li>Streaming and completion modes</li>
                    </ul>
                `
            },
            
            'MCPServers': {
                type: 'External Interface',
                title: 'MCP Servers',
                content: `
                    <h3>Overview</h3>
                    <p>Model Context Protocol servers that provide dynamic tool capabilities to agents.</p>
                    
                    <h3>What is MCP?</h3>
                    <p>MCP is a protocol for exposing tools and capabilities to LLMs in a standardized way. Servers can provide file system access, API integrations, databases, and more.</p>
                    
                    <h3>Integration</h3>
                    <ul>
                        <li>Servers run as separate processes</li>
                        <li>Communication via stdio or HTTP</li>
                        <li>Tools dynamically discovered at runtime</li>
                        <li>Schema validation for type safety</li>
                    </ul>
                    
                    <h3>Examples</h3>
                    <ul>
                        <li><code>filesystem</code> - Advanced file operations</li>
                        <li><code>git</code> - Repository management</li>
                        <li><code>sqlite</code> - Database operations</li>
                        <li><code>fetch</code> - HTTP requests</li>
                    </ul>
                    
                    <div class="file-path">src/services/mcp/</div>
                `
            },
            
            // System Entry Points
            'ProjectCmd': {
                type: 'CLI Command',
                title: 'Project Run Command',
                content: `
                    <h3>Overview</h3>
                    <p>The main command for running TENEX in interactive project mode.</p>
                    <div class="file-path">src/commands/project/run.ts</div>
                    
                    <h3>Functionality</h3>
                    <ul>
                        <li>Loads project configuration</li>
                        <li>Initializes conversation coordinator</li>
                        <li>Sets up event subscriptions</li>
                        <li>Publishes periodic status updates</li>
                        <li>Handles graceful shutdown</li>
                    </ul>
                    
                    <h3>Key Components Started</h3>
                    <ul>
                        <li><strong>EventHandler</strong>: Processes incoming events</li>
                        <li><strong>SubscriptionManager</strong>: Manages Nostr subscriptions</li>
                        <li><strong>StatusPublisher</strong>: Sends heartbeat events</li>
                        <li><strong>ConversationCoordinator</strong>: Manages conversation state</li>
                    </ul>
                    
                    <h3>Usage</h3>
                    <code>tenex project run</code>
                    <p>Must be run from a directory containing .tenex/project.json</p>
                `
            },
            
            'DaemonCmd': {
                type: 'CLI Command',
                title: 'Daemon Command',
                content: `
                    <h3>Overview</h3>
                    <p>Runs TENEX as a background daemon that monitors for events across all projects.</p>
                    <div class="file-path">src/commands/daemon.ts</div>
                    
                    <h3>Daemon Mode Features</h3>
                    <ul>
                        <li>Monitors global Nostr events</li>
                        <li>Auto-spawns project processes</li>
                        <li>Manages multiple projects concurrently</li>
                        <li>Handles process lifecycle</li>
                    </ul>
                    
                    <h3>Components</h3>
                    <ul>
                        <li><strong>EventMonitor</strong>: Watches for relevant events</li>
                        <li><strong>ProcessManager</strong>: Spawns and manages child processes</li>
                        <li><strong>ProjectManager</strong>: Tracks active projects</li>
                    </ul>
                    
                    <h3>Usage</h3>
                    <code>tenex daemon</code>
                    <p>Runs continuously until stopped with Ctrl+C</p>
                `
            },
            
            // Event Processing
            'EventHandler': {
                type: 'Core Component',
                title: 'Event Handler',
                content: `
                    <h3>Overview</h3>
                    <p>The central router for all incoming Nostr events. Determines event type and routes to appropriate handlers.</p>
                    <div class="file-path">src/event-handler/index.ts</div>
                    
                    <h3>Responsibilities</h3>
                    <ul>
                        <li>Event discrimination and filtering</li>
                        <li>Handler routing based on event kind</li>
                        <li>Loop prevention (ignores own events)</li>
                        <li>Component initialization</li>
                    </ul>
                    
                    <h3>Event Routing</h3>
                    <ul>
                        <li><code>kind: 11</code> ‚Üí New Conversation Handler</li>
                        <li><code>kind: 1111</code> ‚Üí Reply Handler</li>
                        <li><code>kind: 1934</code> ‚Üí Task Handler</li>
                        <li><code>kind: 17001</code> ‚Üí Project Handler</li>
                        <li><code>kind: 24020</code> ‚Üí Config Update Handler</li>
                    </ul>
                    
                    <h3>Key Features</h3>
                    <ul>
                        <li>Prevents infinite loops by checking sender</li>
                        <li>Manages project update locking</li>
                        <li>Handles dynamic agent configuration</li>
                    </ul>
                `
            },
            
            'EventMonitor': {
                type: 'Daemon Component',
                title: 'Event Monitor',
                content: `
                    <h3>Overview</h3>
                    <p>Monitors global Nostr events in daemon mode and triggers project process spawning.</p>
                    <div class="file-path">src/daemon/EventMonitor.ts</div>
                    
                    <h3>Functionality</h3>
                    <ul>
                        <li>Subscribes to events from whitelisted pubkeys</li>
                        <li>Extracts project identifiers from event tags</li>
                        <li>Triggers process spawning for new events</li>
                        <li>Prevents duplicate process creation</li>
                    </ul>
                    
                    <h3>Whitelist System</h3>
                    <p>Only processes events from authorized users, configured in <code>~/.tenex/whitelist.json</code></p>
                    
                    <h3>Project Detection</h3>
                    <p>Looks for 'a' tags in events to identify which project should handle the event.</p>
                `
            },
            
            // Conversation Management
            'ConvCoord': {
                type: 'Core Component',
                title: 'Conversation Coordinator',
                content: `
                    <h3>Overview</h3>
                    <p>The central state manager for all conversations. Handles creation, updates, persistence, and context building.</p>
                    <div class="file-path">src/conversations/ConversationCoordinator.ts</div>
                    
                    <h3>Core Responsibilities</h3>
                    <ul>
                        <li><strong>State Management</strong>: In-memory conversation state</li>
                        <li><strong>Message Building</strong>: Agent-specific context windows</li>
                        <li><strong>Phase Control</strong>: Workflow state transitions</li>
                        <li><strong>Persistence</strong>: File-based state storage</li>
                        <li><strong>Turn Tracking</strong>: Orchestrator routing history</li>
                    </ul>
                    
                    <h3>Key Features</h3>
                    <ul>
                        <li>Atomic state updates</li>
                        <li>Crash recovery mechanisms</li>
                        <li>Agent state isolation</li>
                        <li>Incremental message processing</li>
                    </ul>
                    
                    <h3>Data Structures</h3>
                    <ul>
                        <li><code>conversations</code>: Map of active conversations</li>
                        <li><code>agentStates</code>: Per-agent processing state</li>
                        <li><code>phaseTransitions</code>: Workflow history</li>
                        <li><code>orchestratorTurns</code>: Routing decisions</li>
                    </ul>
                `
            },
            
            'PhaseManager': {
                type: 'Workflow Component',
                title: 'Phase Manager',
                content: `
                    <h3>Overview</h3>
                    <p>Controls the phase-based workflow that ensures quality and completeness in every task.</p>
                    <div class="file-path">src/conversations/services/PhaseManager.ts</div>
                    
                    <h3>Workflow Phases</h3>
                    <ol>
                        <li><strong>CHAT</strong>: Initial conversation and requirements gathering</li>
                        <li><strong>BRAINSTORM</strong>: Creative exploration and ideation</li>
                        <li><strong>PLAN</strong>: Structured approach and technical design</li>
                        <li><strong>EXECUTE</strong>: Implementation with tool usage</li>
                        <li><strong>VERIFICATION</strong>: Testing and quality assurance</li>
                        <li><strong>CHORES</strong>: Documentation and cleanup</li>
                        <li><strong>REFLECTION</strong>: Learning capture and improvement</li>
                    </ol>
                    
                    <h3>Transition Rules</h3>
                    <ul>
                        <li>Valid transitions enforced</li>
                        <li>Phase-specific requirements</li>
                        <li>Automatic advancement triggers</li>
                        <li>No backward transitions</li>
                    </ul>
                    
                    <h3>Special Behaviors</h3>
                    <ul>
                        <li>REFLECTION ‚Üí CHAT clears read files</li>
                        <li>Some phases require termination</li>
                        <li>Conversational phases (CHAT/BRAINSTORM) are open-ended</li>
                    </ul>
                `
            },
            
            // Agent System
            'AgentRegistry': {
                type: 'Agent Component',
                title: 'Agent Registry',
                content: `
                    <h3>Overview</h3>
                    <p>Manages all available agents in the system, both built-in and custom.</p>
                    <div class="file-path">src/agents/AgentRegistry.ts</div>
                    
                    <h3>Agent Types</h3>
                    <ul>
                        <li><strong>Built-in Agents</strong>: Orchestrator, Planner, Executor, Project Manager</li>
                        <li><strong>Custom Agents</strong>: User-defined agents with specific capabilities</li>
                        <li><strong>External Agents</strong>: Agents from other systems via delegation</li>
                    </ul>
                    
                    <h3>Registry Features</h3>
                    <ul>
                        <li>Agent discovery and lookup</li>
                        <li>Capability-based filtering</li>
                        <li>Dynamic registration</li>
                        <li>Tool assignment management</li>
                    </ul>
                    
                    <h3>Agent Properties</h3>
                    <ul>
                        <li><code>name</code>: Display name</li>
                        <li><code>slug</code>: Unique identifier</li>
                        <li><code>pubkey</code>: Nostr public key</li>
                        <li><code>role</code>: Agent specialization</li>
                        <li><code>capabilities</code>: What the agent can do</li>
                    </ul>
                `
            },
            
            'AgentExecutor': {
                type: 'Core Component',
                title: 'Agent Executor',
                content: `
                    <h3>Overview</h3>
                    <p>Orchestrates agent execution by building context, managing sessions, and coordinating with the streaming backend.</p>
                    <div class="file-path">src/agents/execution/AgentExecutor.ts</div>
                    
                    <h3>Execution Pipeline</h3>
                    <ol>
                        <li>Build message context from conversation</li>
                        <li>Retrieve or create session ID</li>
                        <li>Initialize stream publisher</li>
                        <li>Execute through ReasonActLoop</li>
                        <li>Handle completion and routing</li>
                    </ol>
                    
                    <h3>Context Building</h3>
                    <ul>
                        <li>Historical messages with agent perspective</li>
                        <li>"Messages while you were away" markers</li>
                        <li>Phase-specific instructions</li>
                        <li>Available tools and agents</li>
                    </ul>
                    
                    <h3>Session Management</h3>
                    <p>Maintains Claude session continuity across executions for stateful conversations.</p>
                `
            },
            
            'ReasonActLoop': {
                type: 'Execution Backend',
                title: 'Reason-Act Loop',
                content: `
                    <h3>Overview</h3>
                    <p>The unified streaming execution backend that handles all agent interactions with LLMs.</p>
                    <div class="file-path">src/agents/execution/ReasonActLoop.ts</div>
                    
                    <h3>Core Features</h3>
                    <ul>
                        <li>Streaming response processing</li>
                        <li>Tool execution handling</li>
                        <li>Termination enforcement</li>
                        <li>Retry mechanisms</li>
                    </ul>
                    
                    <h3>Stream Event Processing</h3>
                    <ul>
                        <li><strong>content</strong>: Text chunks from LLM</li>
                        <li><strong>tool_start</strong>: Tool execution beginning</li>
                        <li><strong>tool_complete</strong>: Tool execution finished</li>
                        <li><strong>done</strong>: Stream completion</li>
                        <li><strong>error</strong>: Error handling</li>
                    </ul>
                    
                    <h3>Termination Logic</h3>
                    <p>Ensures agents properly complete tasks:</p>
                    <ul>
                        <li>Max 3 attempts with reminders</li>
                        <li>Auto-completion for non-critical phases</li>
                        <li>Orchestrator never auto-completes</li>
                    </ul>
                `
            },
            
            'Orchestrator': {
                type: 'Built-in Agent',
                title: 'Orchestrator Agent',
                content: `
                    <h3>Overview</h3>
                    <p>The invisible conductor that routes tasks to appropriate specialized agents.</p>
                    <div class="file-path">src/agents/built-in/orchestrator.ts</div>
                    
                    <h3>Unique Features</h3>
                    <ul>
                        <li>No direct user interaction (invisible)</li>
                        <li>Receives structured routing context</li>
                        <li>Makes routing decisions only</li>
                        <li>Cannot use tools</li>
                    </ul>
                    
                    <h3>Routing Context</h3>
                    <p>Receives JSON with:</p>
                    <ul>
                        <li><code>user_request</code>: What the user wants</li>
                        <li><code>workflow_narrative</code>: History of work done</li>
                    </ul>
                    
                    <h3>Decision Making</h3>
                    <p>Routes based on:</p>
                    <ul>
                        <li>Current conversation phase</li>
                        <li>Agent capabilities</li>
                        <li>Task requirements</li>
                        <li>Previous routing history</li>
                    </ul>
                `
            },
            
            // LLM System
            'LLMRouter': {
                type: 'Core Component',
                title: 'LLM Router',
                content: `
                    <h3>Overview</h3>
                    <p>Multi-provider orchestration layer that manages all LLM interactions with intelligent routing.</p>
                    <div class="file-path">src/llm/router.ts</div>
                    
                    <h3>Core Features</h3>
                    <ul>
                        <li>Provider abstraction (OpenAI, Anthropic, etc.)</li>
                        <li>Context-aware configuration selection</li>
                        <li>Streaming and completion modes</li>
                        <li>Tool integration via plugins</li>
                        <li>Comprehensive logging</li>
                    </ul>
                    
                    <h3>Configuration Resolution</h3>
                    <p>Cascading configuration with multiple fallbacks:</p>
                    <ol>
                        <li>Direct configuration name</li>
                        <li>Default by context (agents, analyze, orchestrator)</li>
                        <li>First available configuration</li>
                    </ol>
                    
                    <h3>Streaming Pipeline</h3>
                    <ul>
                        <li>Event transformation from provider format</li>
                        <li>Tool execution integration</li>
                        <li>Usage tracking and cost calculation</li>
                    </ul>
                `
            },
            
            // Tool System
            'ToolExecutor': {
                type: 'Tool Component',
                title: 'Tool Executor',
                content: `
                    <h3>Overview</h3>
                    <p>Type-safe execution engine for all tool invocations with validation and error handling.</p>
                    <div class="file-path">src/tools/executor.ts</div>
                    
                    <h3>Execution Pipeline</h3>
                    <ol>
                        <li>Input validation against Zod schema</li>
                        <li>Tool execution with context</li>
                        <li>Result wrapping with metadata</li>
                        <li>Error handling and typing</li>
                        <li>Duration tracking</li>
                    </ol>
                    
                    <h3>Special Cases</h3>
                    <ul>
                        <li><code>generate_inventory</code>: Bypasses validation</li>
                        <li>Terminal tools: Trigger control flow changes</li>
                        <li>MCP tools: Additional error wrapping</li>
                    </ul>
                    
                    <h3>Result Structure</h3>
                    <code>Result&lt;ToolError, Output&gt;</code>
                    <p>Monadic error handling ensures errors are explicitly handled.</p>
                `
            },
            
            'ControlTools': {
                type: 'Built-in Tools',
                title: 'Control Flow Tools',
                content: `
                    <h3>Overview</h3>
                    <p>Tools that manage task completion and control flow between agents.</p>
                    
                    <h3>Tools</h3>
                    <ul>
                        <li><strong>complete</strong>: Marks task as done, returns to orchestrator</li>
                        <li><strong>continue</strong>: Continues with same agent (session continuity)</li>
                    </ul>
                    
                    <h3>Complete Tool</h3>
                    <p>The most important tool - ensures proper task completion:</p>
                    <ul>
                        <li>Captures completion summary</li>
                        <li>Determines next agent routing</li>
                        <li>Triggers phase transitions</li>
                        <li>Required in most phases</li>
                    </ul>
                    
                    <h3>Control Flow</h3>
                    <p>When complete is called:</p>
                    <ol>
                        <li>Current agent finishes</li>
                        <li>Control returns to orchestrator</li>
                        <li>Orchestrator routes to next agent</li>
                    </ol>
                `
            },
            
            // Publishing System
            'NostrPublisher': {
                type: 'Publishing Component',
                title: 'Nostr Publisher',
                content: `
                    <h3>Overview</h3>
                    <p>Primary interface for publishing all events to the Nostr network.</p>
                    <div class="file-path">src/nostr/NostrPublisher.ts</div>
                    
                    <h3>Core Features</h3>
                    <ul>
                        <li>Response publishing with metadata</li>
                        <li>Error notification handling</li>
                        <li>Typing indicator management</li>
                        <li>Streaming response support</li>
                        <li>Tool status reporting</li>
                    </ul>
                    
                    <h3>Publishing Pattern</h3>
                    <p>Save-then-publish for consistency:</p>
                    <ol>
                        <li>Save event locally</li>
                        <li>Publish to relays</li>
                        <li>Handle failures gracefully</li>
                    </ol>
                    
                    <h3>Tag Management</h3>
                    <ul>
                        <li>Project association tags</li>
                        <li>Phase and execution metadata</li>
                        <li>Clean routing (no spam p-tags)</li>
                        <li>Voice mode propagation</li>
                    </ul>
                `
            },
            
            'StreamPublisher': {
                type: 'Publishing Component',
                title: 'Stream Publisher',
                content: `
                    <h3>Overview</h3>
                    <p>Handles real-time streaming of agent responses with intelligent batching.</p>
                    
                    <h3>Streaming Strategy</h3>
                    <ul>
                        <li>Content buffering for efficiency</li>
                        <li>Sentence boundary detection</li>
                        <li>Natural flushing points</li>
                        <li>Sequence number management</li>
                    </ul>
                    
                    <h3>Optimization</h3>
                    <ul>
                        <li>Balances latency vs network efficiency</li>
                        <li>Prevents message flooding</li>
                        <li>Handles backpressure</li>
                        <li>Retry logic for failures</li>
                    </ul>
                    
                    <h3>Finalization</h3>
                    <p>When streaming completes:</p>
                    <ol>
                        <li>Flush remaining buffer</li>
                        <li>Publish complete response</li>
                        <li>Add execution metadata</li>
                        <li>Clean up resources</li>
                    </ol>
                `
            },
            
            // Add more component details...
            'MessageBuilder': {
                type: 'Context Component',
                title: 'Message Builder',
                content: `
                    <h3>Overview</h3>
                    <p>Constructs agent-specific message contexts from conversation history.</p>
                    <div class="file-path">src/conversations/MessageBuilder.ts</div>
                    
                    <h3>Context Assembly</h3>
                    <ul>
                        <li>Historical messages with proper roles</li>
                        <li>Incremental processing markers</li>
                        <li>Phase transition context</li>
                        <li>Handoff information</li>
                    </ul>
                    
                    <h3>Agent Perspective</h3>
                    <p>Messages are transformed based on viewing agent:</p>
                    <ul>
                        <li>Own messages ‚Üí assistant role</li>
                        <li>User messages ‚Üí user role</li>
                        <li>Other agents ‚Üí system role</li>
                    </ul>
                    
                    <h3>Special Features</h3>
                    <ul>
                        <li>"Messages while you were away" blocks</li>
                        <li>Orchestrator JSON context</li>
                        <li>Metadata preservation</li>
                    </ul>
                `
            },
            
            'ToolPlugin': {
                type: 'Integration Component',
                title: 'Tool Plugin Adapter',
                content: `
                    <h3>Overview</h3>
                    <p>Bridges TENEX tools with the multi-llm-ts plugin system.</p>
                    <div class="file-path">src/llm/ToolPlugin.ts</div>
                    
                    <h3>Adaptation Process</h3>
                    <ol>
                        <li>Convert TENEX tool to LLM plugin</li>
                        <li>Schema translation (Zod ‚Üí Plugin)</li>
                        <li>Execute through ToolExecutor</li>
                        <li>Serialize results for LLM</li>
                    </ol>
                    
                    <h3>Result Handling</h3>
                    <ul>
                        <li>Dual format results (human + typed)</li>
                        <li>Error message formatting</li>
                        <li>Metadata preservation</li>
                        <li>Control flow detection</li>
                    </ul>
                    
                    <h3>Special Processing</h3>
                    <p>Terminal tools get special handling to extract response content for LLM consumption.</p>
                `
            },
            
            'ProjectContext': {
                type: 'Context Component',
                title: 'Project Context',
                content: `
                    <h3>Overview</h3>
                    <p>Manages project-level context files that guide agent behavior.</p>
                    <div class="file-path">src/services/ProjectContext.ts</div>
                    
                    <h3>Context Files</h3>
                    <ul>
                        <li><strong>PROJECT.md</strong>: Core project description and goals</li>
                        <li><strong>INVENTORY.md</strong>: Current state of codebase</li>
                        <li><strong>Custom contexts</strong>: Domain-specific guidance</li>
                    </ul>
                    
                    <h3>Features</h3>
                    <ul>
                        <li>Automatic loading and caching</li>
                        <li>Hot reload on file changes</li>
                        <li>Fallback to empty context</li>
                        <li>Integration with prompts</li>
                    </ul>
                    
                    <h3>Usage</h3>
                    <p>Context is injected into agent system prompts to provide consistent project understanding across all agents.</p>
                `
            }
        };

        // Connection details for significant arrows
        const connectionDetails = {
            'NostrNetwork-EventHandler': {
                title: 'Event Flow',
                content: `
                    <h3>Nostr ‚Üí Event Handler Connection</h3>
                    <p>The primary entry point for all external communication into TENEX.</p>
                    
                    <div class="connection-flow">
                        <h4>Event Flow Process</h4>
                        <ol>
                            <li>Nostr relays receive events from clients/agents</li>
                            <li>NDK client subscription filters relevant events</li>
                            <li>Events delivered to EventHandler for routing</li>
                            <li>Handler discriminates by kind and routes accordingly</li>
                        </ol>
                    </div>
                    
                    <h3>Event Kinds Processed</h3>
                    <ul>
                        <li><code>kind: 11</code> - New conversations</li>
                        <li><code>kind: 1111</code> - Replies/messages</li>
                        <li><code>kind: 1934</code> - Task assignments</li>
                    </ul>
                `
            },
            
            'ControlTools-Orchestrator': {
                title: 'Control Return Flow',
                content: `
                    <h3>Complete Tool ‚Üí Orchestrator</h3>
                    <p>Critical control flow that enables multi-agent collaboration.</p>
                    
                    <div class="connection-flow">
                        <h4>Completion Process</h4>
                        <ol>
                            <li>Agent calls <code>complete()</code> tool</li>
                            <li>Tool signals task termination</li>
                            <li>Control returns to orchestrator</li>
                            <li>Orchestrator decides next agent</li>
                            <li>New agent receives handoff context</li>
                        </ol>
                    </div>
                    
                    <h3>Handoff Context</h3>
                    <p>Includes completion summary and metadata for smooth transitions between agents.</p>
                `
            },
            
            'AgentExecutor-LLMRouter': {
                title: 'LLM Request Flow',
                content: `
                    <h3>Agent ‚Üí LLM Connection</h3>
                    <p>How agents access AI capabilities through the routing layer.</p>
                    
                    <div class="connection-flow">
                        <h4>Request Process</h4>
                        <ol>
                            <li>AgentExecutor prepares context</li>
                            <li>Requests include agent name for routing</li>
                            <li>LLMRouter selects appropriate config</li>
                            <li>Routes to best provider/model</li>
                            <li>Streams response back to agent</li>
                        </ol>
                    </div>
                    
                    <h3>Context-Aware Routing</h3>
                    <ul>
                        <li>Orchestrator gets specialized config</li>
                        <li>Agents use task-appropriate models</li>
                        <li>Automatic failover on errors</li>
                    </ul>
                `
            },
            
            'ReasonActLoop-StreamStateManager': {
                title: 'Stream State Management',
                content: `
                    <h3>Execution ‚Üí State Tracking</h3>
                    <p>How streaming execution maintains consistent state.</p>
                    
                    <div class="connection-flow">
                        <h4>State Updates</h4>
                        <ul>
                            <li>Content accumulation from chunks</li>
                            <li>Tool execution history</li>
                            <li>Termination signal tracking</li>
                            <li>Custom state extensions</li>
                        </ul>
                    </div>
                    
                    <h3>State Lifecycle</h3>
                    <ol>
                        <li>Initialize empty state</li>
                        <li>Accumulate during streaming</li>
                        <li>Reset on retries (selective)</li>
                        <li>Finalize on completion</li>
                    </ol>
                `
            },
            
            'Orchestrator-Planner': {
                title: 'Agent Routing',
                content: `
                    <h3>Orchestrator ‚Üí Agent Routing</h3>
                    <p>How the orchestrator delegates work to specialized agents.</p>
                    
                    <div class="connection-flow">
                        <h4>Routing Decision Process</h4>
                        <ol>
                            <li>Analyze user request and context</li>
                            <li>Consider current phase requirements</li>
                            <li>Evaluate agent capabilities</li>
                            <li>Make routing decision</li>
                            <li>Create handoff with context</li>
                        </ol>
                    </div>
                    
                    <h3>Common Routing Patterns</h3>
                    <ul>
                        <li><strong>Planning needed</strong> ‚Üí Planner agent</li>
                        <li><strong>Code implementation</strong> ‚Üí Executor agent</li>
                        <li><strong>Project setup</strong> ‚Üí Project Manager</li>
                    </ul>
                `
            },
            
            'ConvCoord-AgentExecutor': {
                title: 'Context Provision',
                content: `
                    <h3>Conversation ‚Üí Execution Context</h3>
                    <p>How conversation state becomes agent execution context.</p>
                    
                    <div class="connection-flow">
                        <h4>Context Building</h4>
                        <ol>
                            <li>Load conversation from coordinator</li>
                            <li>Build agent-specific message view</li>
                            <li>Add phase instructions</li>
                            <li>Include available tools/agents</li>
                            <li>Pass to executor for execution</li>
                        </ol>
                    </div>
                    
                    <h3>Context Elements</h3>
                    <ul>
                        <li>Historical messages</li>
                        <li>Current phase and transitions</li>
                        <li>Agent states and last seen</li>
                        <li>Project context (PROJECT.md)</li>
                    </ul>
                `
            }
        };

        // Initialize mermaid with callback support
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: false,
                htmlLabels: true,
                curve: 'basis',
                rankSpacing: 100,
                nodeSpacing: 100,
                padding: 20
            },
            themeVariables: {
                fontSize: '16px'
            },
            securityLevel: 'loose' // Allow javascript callbacks
        });

        // Show details in drawer
        window.showDetails = function(componentId) {
            const details = componentDetails[componentId];
            if (!details) {
                console.warn('No details found for:', componentId);
                return;
            }
            
            document.getElementById('drawer-title').textContent = details.title;
            document.getElementById('drawer-type').textContent = details.type;
            document.getElementById('drawer-content').innerHTML = details.content;
            
            openDrawer();
        }

        // Show connection details
        function showConnection(connectionId) {
            const details = connectionDetails[connectionId];
            if (!details) {
                console.warn('No connection details found for:', connectionId);
                return;
            }
            
            document.getElementById('drawer-title').textContent = details.title;
            document.getElementById('drawer-type').textContent = 'Connection';
            document.getElementById('drawer-content').innerHTML = details.content;
            
            openDrawer();
        }

        // Drawer management
        function openDrawer() {
            document.getElementById('drawer').classList.add('open');
            document.getElementById('overlay').classList.add('show');
        }

        function closeDrawer() {
            document.getElementById('drawer').classList.remove('open');
            document.getElementById('overlay').classList.remove('show');
        }

        // Close drawer when clicking overlay
        document.getElementById('overlay').addEventListener('click', closeDrawer);

        // Make certain edges clickable after mermaid renders
        window.addEventListener('load', () => {
            // Center the diagram after rendering
            setTimeout(() => {
                const wrapper = document.getElementById('diagramWrapper');
                const diagram = document.getElementById('diagram');
                
                // Calculate centering
                const wrapperWidth = wrapper.clientWidth;
                const wrapperHeight = wrapper.clientHeight;
                const diagramWidth = diagram.scrollWidth;
                const diagramHeight = diagram.scrollHeight;
                
                // Center horizontally and show top portion
                wrapper.scrollLeft = (diagramWidth - wrapperWidth) / 2;
                wrapper.scrollTop = 100; // Show top portion
                
                // Find and make specific edges clickable
                const clickableConnections = [
                    { from: 'NostrNetwork', to: 'EventHandler', id: 'NostrNetwork-EventHandler' },
                    { from: 'ControlTools', to: 'Orchestrator', id: 'ControlTools-Orchestrator' },
                    { from: 'AgentExecutor', to: 'LLMRouter', id: 'AgentExecutor-LLMRouter' },
                    { from: 'ReasonActLoop', to: 'StreamStateManager', id: 'ReasonActLoop-StreamStateManager' },
                    { from: 'Orchestrator', to: 'Planner', id: 'Orchestrator-Planner' },
                    { from: 'ConvCoord', to: 'AgentExecutor', id: 'ConvCoord-AgentExecutor' }
                ];
                
                // Add click handlers to edges
                clickableConnections.forEach(conn => {
                    const edges = document.querySelectorAll('.edgePath');
                    edges.forEach(edge => {
                        const pathElement = edge.querySelector('path');
                        if (pathElement && pathElement.getAttribute('d')) {
                            // Check if this edge connects the right nodes (this is approximate)
                            const edgeClasses = edge.getAttribute('class') || '';
                            if (edgeClasses.includes('LS-' + conn.from) || edgeClasses.includes('LE-' + conn.to)) {
                                edge.classList.add('clickable-edge');
                                edge.style.cursor = 'pointer';
                                edge.addEventListener('click', () => showConnection(conn.id));
                            }
                        }
                    });
                });
            }, 1000); // Wait for mermaid to finish rendering
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDrawer();
            }
            if (e.key === '=' || e.key === '+') {
                zoomIn();
            }
            if (e.key === '-' || e.key === '_') {
                zoomOut();
            }
            if (e.key === '0' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                resetZoom();
            }
        });
    </script>
</body>
</html>