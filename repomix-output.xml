This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
context/
  agents.md
  claude-code-integration.md
  commands.md
  conversation_manager.md
  conversations.md
  execution-queue-mutex-system.md
  INVENTORY.md
  llm.md
  metadata-preservation-debug-logging.md
  nostr.md
  PROJECT.md
  standalone-agents-plan.md
patches/
  multi-llm-ts+4.3.6.patch
scripts/
  build-bundled.js
src/
  agents/
    __tests__/
      AgentPublisher.test.ts
      AgentRegistry.republish.test.ts
      AgentRegistry.test.ts
      tool-assignment.test.ts
      utils.normalization.test.ts
    built-in/
      executor.ts
      planner.ts
      project-manager.ts
    execution/
      __tests__/
        AgentExecutor-simple.test.ts
        AgentExecutor.test.ts
        completionHandler.test.ts
        ReasonActLoop.errorRecovery.test.ts
        ReasonActLoop.toolError.test.ts
        RoutingBackend.test.ts
        StreamStateManager.test.ts
      AgentExecutor.ts
      completionHandler.ts
      constants.ts
      control-flow-types.ts
      index.ts
      ReasonActLoop.ts
      StreamStateManager.ts
      TerminationHandler.ts
      ToolStreamHandler.ts
      types.ts
    AgentPublisher.ts
    AgentRegistry.ts
    builtInAgents.ts
    constants.ts
    index.ts
    types.ts
    utils.ts
  claude/
    DelayedMessageBuffer.ts
    executor.ts
    index.ts
    orchestrator.ts
  commands/
    agent/
      add.ts
      index.ts
      list.ts
      remove.ts
    debug/
      __tests__/
        utils.test.ts
      chat.ts
      claudeCode.ts
      conversation.ts
      conversationSelector.ts
      index.ts
      timeline.ts
      utils.ts
    inventory/
      index.ts
    mcp/
      __tests__/
        add.test.ts
        list.test.ts
      add.ts
      index.ts
      list.ts
      remove.ts
      server.ts
    project/
      index.ts
      init.ts
      run.ts
    queue/
      clear.ts
      history.ts
      index.ts
      release.ts
      remove.ts
      status.ts
    run/
      __tests__/
        StatusPublisher.test.ts
        SubscriptionManager.test.ts
      constants.ts
      processedEventTracking.ts
      ProjectDisplay.ts
      StatusPublisher.ts
      SubscriptionManager.ts
    setup/
      index.ts
      llm.ts
    daemon.ts
  conversations/
    __tests__/
      AgentConversationContext.test.ts
      ConversationManager.agentContext.test.ts
      ConversationManager.integration.test.ts
      ConversationManager.multiAgent.test.ts
      ConversationManager.nostrEntities.test.ts
      ConversationManager.phaseTransition.test.ts
      ConversationManager.test.ts
      executionTime.test.ts
    executionQueue/
      __tests__/
        ExecutionQueueManager.test.ts
      ExecutionEventPublisher.ts
      ExecutionQueueManager.ts
      index.ts
      LockManager.ts
      QueueManager.ts
      TimeoutManager.ts
      types.ts
    persistence/
      __tests__/
        FileSystemAdapter.integration.test.ts
        FileSystemAdapter.state-persistence.test.ts
        FileSystemAdapter.test.ts
      FileSystemAdapter.ts
      index.ts
      schemas.ts
      types.ts
    services/
      __tests__/
        ConversationCoordinator.e2e.test.ts
        ConversationEventProcessor.test.ts
        ConversationStore.test.ts
        PhaseManager.test.ts
      AgentResolver.ts
      ConversationCoordinator.ts
      ConversationEventProcessor.ts
      ConversationPersistenceService.ts
      ConversationStore.ts
      index.ts
      PhaseManager.ts
    AgentConversationContext.ts
    ConversationManager.ts
    executionTime.ts
    index.ts
    MessageBuilder.ts
    phases.ts
    types.ts
  daemon/
    __tests__/
      EventMonitor.test.ts
      ProcessManager.test.ts
    EventMonitor.ts
    ProcessManager.ts
    ProjectManager.ts
  event-handler/
    __tests__/
      newConversation.test.ts
      reply.delegation.test.ts
      reply.test.ts
      task-reply-routing.test.ts
      task.test.ts
    index.ts
    newConversation.ts
    project.ts
    reply.ts
    task.ts
  events/
    index.ts
    NDKAgentDefinition.ts
    NDKAgentLesson.ts
    NDKMCPTool.ts
  lib/
    __tests__/
      shell.test.ts
    fs/
      filesystem.ts
      index.ts
      tenex.ts
    shell.ts
  llm/
    __tests__/
      pricing.test.ts
      ToolResult.test.ts
    selection/
      ModelSelector.ts
    testing/
      LLMTester.ts
    ui/
      LLMConfigUI.ts
    callLogger.ts
    constants.ts
    index.ts
    LLMConfigEditor.ts
    models.ts
    pricing.ts
    router.ts
    ToolPlugin.ts
    ToolResult.ts
    types.ts
  logging/
    ExecutionLogger.ts
  nostr/
    __tests__/
      NostrEventService.test.ts
      NostrPublisher.test.ts
      TaskPublisher.test.ts
      TypingIndicatorManager.integration.test.ts
      TypingIndicatorManager.manual.test.ts
      TypingIndicatorManager.test.ts
      voice-mode-propagation.test.ts
    event-builder.ts
    factory.ts
    index.ts
    ndkClient.ts
    NostrEventService.ts
    NostrPublisher.ts
    tags.ts
    TaskPublisher.ts
    types.ts
    TypingIndicatorManager.ts
    utils.ts
  prompts/
    __tests__/
      FragmentRegistry.test.ts
      PromptBuilder.test.ts
    core/
      FragmentRegistry.ts
      index.ts
      PromptBuilder.ts
      types.ts
    fragments/
      __tests__/
        agent-execution.test.ts
        agentFragments.test.ts
        available-agents.test.ts
        integration.test.ts
        phase-definitions.test.ts
        tool-registry.test.ts
        voice-mode.test.ts
      01-specialist-identity.ts
      10-phase-definitions.ts
      10-referenced-article.ts
      15-specialist-available-agents.ts
      20-phase-constraints.ts
      20-phase-context.ts
      20-voice-mode.ts
      24-retrieved-lessons.ts
      25-specialist-tools.ts
      30-project-inventory.ts
      30-project-md.ts
      35-specialist-completion-guidance.ts
      85-specialist-reasoning.ts
      90-inventory-generation.ts
    utils/
      __tests__/
        systemPromptBuilder.test.ts
      llmMetadata.ts
      phaseInstructionsBuilder.ts
      systemPromptBuilder.ts
    index.ts
  services/
    __tests__/
      ConfigService.test.ts
    config/
      __tests__/
        mcp-config.test.ts
      types.ts
    mcp/
      __tests__/
        mcpInstaller.test.ts
        MCPService.integration.test.ts
        MCPService.test.ts
      mcpInstaller.ts
      MCPService.ts
      MCPToolAdapter.ts
    ConfigService.ts
    index.ts
    NDKAgentDiscovery.ts
    ProjectContext.ts
  test-utils/
    mock-llm/
      scenarios/
        concurrency-workflow.ts
        error-handling.ts
        index.ts
        inventory-generation.ts
        network-resilience.ts
        orchestrator-workflow.ts
        performance-testing.ts
        routing-decisions.ts
        state-persistence.ts
      example-e2e.test.ts
      index.ts
      MockLLMService.ts
      performance.test.ts
      types.ts
    mocks/
      events.ts
    conversational-logger.ts
    e2e-conversational-setup.ts
    index.ts
    mock-factories.ts
    mock-setup.ts
    README.md
    test-persistence-adapter.ts
  tools/
    __tests__/
      core.test.ts
      executor.test.ts
      registry.test.ts
      tool-helpers.test.ts
      utils.test.ts
      zod-schema.test.ts
    implementations/
      __tests__/
        agents-discover.test.ts
        analyze.test.ts
        claude_code.test.ts
        complete.test.ts
        delegate-simple.test.ts
        learn.test.ts
        mcp-discover.test.ts
        nostr-projects-empty-args.test.ts
        readPath.test.ts
        shell-simple.test.ts
        writeContextFile.test.ts
      agents-discover.ts
      agents-hire.ts
      analyze.ts
      claude_code.ts
      complete.ts
      delegate.ts
      generateInventory.ts
      learn.ts
      lessonGet.ts
      mcp-discover.ts
      nostr-projects.ts
      readPath.ts
      shell.ts
      switch_phase.ts
      writeContextFile.ts
    core.ts
    executor.ts
    registry.ts
    toolLogger.ts
    types.ts
    utils.ts
    zod-schema.ts
  tracing/
    __tests__/
      index.test.ts
      TracingContext.test.ts
      TracingLogger.test.ts
    index.ts
    TracingContext.ts
    TracingLogger.ts
  utils/
    __tests__/
      agentFetcher.test.ts
      cli-config-scope.test.ts
      cli-error.test.ts
      configLocation.test.ts
      conversationFetcher.test.ts
      error-formatter.test.ts
      error-handler.test.ts
      formatting.test.ts
      lessonFormatter.test.ts
      logger.test.ts
      relays.test.ts
      string.test.ts
      validation.test.ts
    git/
      createExecutionBranch.ts
      gitignore.ts
      index.ts
      initializeGitRepo.ts
    agentFetcher.ts
    cli-config-scope.ts
    cli-error.ts
    conversationFetcher.ts
    error-formatter.ts
    error-handler.ts
    file-persistence.ts
    formatting.ts
    inventory.ts
    lessonFormatter.ts
    logger.ts
    process.ts
    project-detection.ts
    projectInitialization.ts
    relays.ts
    repomix.ts
    setup.ts
    string.ts
    validation.ts
  cli.ts
  constants.ts
  index.ts
  tenex.ts
tests/
  e2e/
    agent-error-recovery.test.ts
    concurrency-multiple-conversations.test.ts
    executor-verification-flow.test.ts
    nostr-network-resilience.test.ts
    performance-timeout.test.ts
    state-persistence.test.ts
    state-recovery.test.ts
    test-harness.ts
.gitignore
.npmignore
.repomixignore
biome.json
bunfig.toml
CLEANUP_COMPLETE.md
CONSOLIDATION_COMPLETE.md
conversation-manager-refactor-plan.md
E2E_FRAMEWORK.md
eslint.config.js
find_orphaned_files.sh
NEW-FLOW.md
package.json
project-less-agents-analysis.md
README.md
standalone-agent-nostr-plan.md
SYSTEM_PROMPT_ARCHITECTURE_REPORT.md
test-delegate-tools.js
tsconfig.build.json
tsconfig.eslint.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/agents/__tests__/AgentRegistry.republish.test.ts">
import { AgentRegistry } from "@/agents/AgentRegistry";
import { AgentPublisher } from "@/agents/AgentPublisher";
import { getNDK } from "@/nostr";
import { getProjectContext, isProjectContextInitialized, setProjectContext } from "@/services";
import type { NDKPrivateKeySigner } from "@nostr-dev-kit/ndk";
import type { NDKProject } from "@nostr-dev-kit/ndk";
⋮----
// Mock dependencies
⋮----
// Create mock project
⋮----
// Create mock agents
⋮----
// Add agents to registry
⋮----
// Call republishAllAgentProfiles
⋮----
// Verify AgentPublisher was created
⋮----
// Verify publishAgentProfile was called for each agent
⋮----
// Mock project context
⋮----
// Create mock agent
⋮----
// Add agent to registry
⋮----
// Call republishAllAgentProfiles without project
⋮----
// Verify publishAgentProfile was called with context values
⋮----
// Create mock agent
⋮----
// Add agent to registry
⋮----
// Call republishAllAgentProfiles without project
⋮----
// Verify publishAgentProfile was NOT called
⋮----
// Create mock project
⋮----
// Create mock agents
⋮----
// Add agents to registry
⋮----
// Make first call fail
⋮----
// Call republishAllAgentProfiles
⋮----
// Verify both agents were attempted
</file>

<file path="src/agents/execution/__tests__/RoutingBackend.test.ts">
import { describe, expect, it, mock, beforeEach } from "bun:test";
import type { LLMService } from "@/llm/types";
import type { ConversationManager } from "@/conversations/ConversationManager";
import { RoutingBackend } from "../RoutingBackend";
import type { ExecutionContext } from "../types";
import { Message } from "multi-llm-ts";
⋮----
// Mock LLM service
⋮----
// Mock conversation manager
⋮----
// Mock agent executor
⋮----
// Mock project context
⋮----
// Verify LLM was called
⋮----
// Verify agent executor was called
⋮----
phase: "plan", // Different phase
⋮----
phase: "chat", // Current phase
⋮----
// Mock project context
⋮----
// Verify phase transition was called
⋮----
// Mock project context
⋮----
// Verify agent executor was called with executor
⋮----
// Mock project context
⋮----
// Verify both agents were executed
</file>

<file path="src/agents/execution/index.ts">

</file>

<file path="src/agents/index.ts">

</file>

<file path="src/claude/index.ts">

</file>

<file path="src/commands/agent/index.ts">
import { Command } from "commander";
import { agentAddCommand } from "./add";
import { agentListCommand } from "./list";
import { agentRemoveCommand } from "./remove";
</file>

<file path="src/commands/agent/remove.ts">
import { AgentRegistry } from "@/agents/AgentRegistry";
import { configService } from "@/services/ConfigService";
import { logger } from "@/utils/logger";
import { confirm } from "@inquirer/prompts";
import { Command } from "commander";
⋮----
interface RemoveOptions {
    project?: boolean;
    global?: boolean;
    force?: boolean;
}
⋮----
// Determine where to remove from
⋮----
// Default: try project first if in one, otherwise global
⋮----
// Load the appropriate registry
⋮----
// Find the agent
⋮----
// If we defaulted to project, suggest checking global
⋮----
// Check if it's a built-in agent
⋮----
// Confirm deletion unless --force is used
⋮----
// Remove the agent
</file>

<file path="src/commands/debug/conversationSelector.ts">
import inquirer from "inquirer";
import chalk from "chalk";
import type { ConversationManager } from "@/conversations/ConversationManager";
import { formatDuration } from "@/utils/formatting";
⋮----
interface ConversationChoice {
    name: string;
    value: string;
    short: string;
}
⋮----
export async function selectConversation(conversationManager: ConversationManager): Promise<string | null>
⋮----
// Sort conversations by last event timestamp (most recent first)
⋮----
// Create choices for inquirer
⋮----
// Create a display name with metadata
⋮----
// Add separator and cancel option
⋮----
// Handle Ctrl+C
</file>

<file path="src/commands/mcp/__tests__/list.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { Command } from "commander";
import { listCommand } from "../list";
import type { TenexConfig } from "@/services/config/types";
import chalk from "chalk";
⋮----
// Mock modules
⋮----
// Mock console methods
⋮----
// Helper to set up configService mocks
async function setupConfigServiceMocks()
⋮----
// Reset mocks
⋮----
// Default mock configs
⋮----
// Create commander program
⋮----
(configService.loadConfig as any).mockResolvedValue(mockProjectConfig); // Main config
⋮----
.mockResolvedValueOnce(mockGlobalConfig.mcp) // Global MCP
.mockResolvedValueOnce(mockProjectConfig.mcp); // Project MCP
⋮----
// Check that logger.info was called
⋮----
// Get the actual calls and convert to plain text
⋮----
// Check that key information is present in the output
⋮----
// Check global servers
⋮----
// Check project servers
⋮----
// Check status footer
⋮----
.mockResolvedValueOnce({}) // No global config
.mockResolvedValueOnce({}); // No project config
⋮----
// Should not show these optional fields
⋮----
// Missing args field
</file>

<file path="src/commands/mcp/list.ts">
import { configService } from "@/services/ConfigService";
import type { MCPServerConfig } from "@/services/config/types";
import { logger } from "@/utils/logger";
import chalk from "chalk";
import { Command } from "commander";
⋮----
interface ListOptions {
    project?: boolean;
    global?: boolean;
    all?: boolean;
}
⋮----
// Default to showing all servers
⋮----
// Validate options
⋮----
// Load configurations
⋮----
// Check if any servers exist
⋮----
// Display global servers
⋮----
// Display project servers
⋮----
// Categorize servers
⋮----
// Show project-specific servers first
⋮----
// Show overridden servers
⋮----
// Display status summary
⋮----
// Load merged config to show final status
⋮----
function displayServer(
    name: string,
    server: MCPServerConfig,
    isOverridden = false,
    isOverriding = false
): void
</file>

<file path="src/commands/project/index.ts">
import { projectInitCommand } from "@/commands/project/init";
import { projectRunCommand } from "@/commands/project/run";
import { Command } from "commander";
</file>

<file path="src/commands/run/constants.ts">
import { EVENT_KINDS } from "@/llm/types";
⋮----
export const STATUS_INTERVAL_MS = 15000; // 15 seconds
⋮----
export function getEventKindName(kind: number): string
</file>

<file path="src/commands/setup/index.ts">
import { llmCommand } from "@/commands/setup/llm";
import { Command } from "commander";
</file>

<file path="src/conversations/persistence/index.ts">

</file>

<file path="src/conversations/persistence/types.ts">
import type { Conversation } from "../types";
⋮----
export interface ConversationMetadata {
    id: string;
    title: string;
    createdAt: number;
    updatedAt: number;
    phase: string;
    eventCount: number;
    agentCount: number;
    archived?: boolean;
}
⋮----
export interface ConversationSearchCriteria {
    title?: string;
    phase?: string;
    dateFrom?: number;
    dateTo?: number;
    agentPubkey?: string;
    archived?: boolean;
}
⋮----
export interface ConversationPersistenceAdapter {
    initialize(): Promise<void>;
    save(conversation: Conversation): Promise<void>;
    load(conversationId: string): Promise<Conversation | null>;
    delete(conversationId: string): Promise<void>;
    list(): Promise<ConversationMetadata[]>;
    search(criteria: ConversationSearchCriteria): Promise<ConversationMetadata[]>;
    archive(conversationId: string): Promise<void>;
    restore(conversationId: string): Promise<void>;
}
⋮----
initialize(): Promise<void>;
save(conversation: Conversation): Promise<void>;
load(conversationId: string): Promise<Conversation | null>;
delete(conversationId: string): Promise<void>;
list(): Promise<ConversationMetadata[]>;
search(criteria: ConversationSearchCriteria): Promise<ConversationMetadata[]>;
archive(conversationId: string): Promise<void>;
restore(conversationId: string): Promise<void>;
</file>

<file path="src/conversations/executionTime.ts">
/**
 * Utility functions for managing conversation execution time
 * Works directly with Conversation objects, following DRY principle
 */
⋮----
import type { Conversation } from "./types";
⋮----
/**
 * Start tracking execution time for a conversation
 */
export function startExecutionTime(conversation: Conversation): void
⋮----
// Already active - don't restart
⋮----
/**
 * Stop tracking execution time and add duration to total
 * @returns Duration of this session in milliseconds
 */
export function stopExecutionTime(conversation: Conversation): number
⋮----
/**
 * Get total execution time in seconds (including current session if active)
 */
export function getTotalExecutionTimeSeconds(conversation: Conversation): number
⋮----
// If currently executing, include current session time
⋮----
/**
 * Check if conversation is currently tracking execution time
 */
export function isExecutionActive(conversation: Conversation): boolean
⋮----
/**
 * Initialize execution time for a new conversation
 */
export function initializeExecutionTime(conversation: Conversation): void
⋮----
/**
 * Ensure conversation has execution time initialized (for loaded conversations)
 */
export function ensureExecutionTimeInitialized(conversation: Conversation): void
⋮----
// Crash recovery: if execution was active but daemon restarted,
// reset the active state as the session was lost
⋮----
const maxSessionTime = 30 * 60 * 1000; // 30 minutes max reasonable session
⋮----
// Consider the session lost and reset state
</file>

<file path="src/conversations/index.ts">

</file>

<file path="src/daemon/__tests__/EventMonitor.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock, spyOn } from "bun:test";
import type { NDKEvent, NDKFilter, NDKSubscription } from "@nostr-dev-kit/ndk";
import { EventMonitor } from "../EventMonitor";
import type { IProcessManager } from "../ProcessManager";
import type { IProjectManager } from "../ProjectManager";
⋮----
import { logger } from "@/utils/logger";
⋮----
// Mock nostr-tools at module level
⋮----
// Mock types
interface MockNDK {
    subscribe: (filter: NDKFilter, options?: any) => NDKSubscription;
}
⋮----
interface MockSubscription extends NDKSubscription {
    on: (event: string, handler: (event: NDKEvent) => void) => void;
    stop: () => void;
    eventHandlers: Map<string, ((event: NDKEvent) => void)[]>;
}
⋮----
// Extend EventMonitor to expose private method for testing
class TestableEventMonitor extends EventMonitor
⋮----
public async testHandleEvent(event: NDKEvent): Promise<void>
⋮----
// Create mock implementations
⋮----
// Create mock subscription with event handlers
⋮----
// Create mock NDK
⋮----
// Mock getNDK to return our mock
⋮----
// Spy on logger methods
⋮----
// Create EventMonitor instance
⋮----
// Don't start, just stop
⋮----
const createMockEvent = (tags: string[][], pubkey: string = "testpubkey"): NDKEvent =>
⋮----
// Add debug spy for getNDK
⋮----
// Verify ensureProjectExists was called with correct naddr format
⋮----
expect.stringMatching(/^naddr1/), // Should start with naddr1
⋮----
// First call returns false, second returns true (simulating race condition)
⋮----
// Trigger both events concurrently
⋮----
// Should only spawn once due to the isProjectRunning check
⋮----
// Get the event handler
⋮----
// Create an event that will cause an error
⋮----
// Mock handleEvent to throw
⋮----
// The handler should catch the error
⋮----
// Wait for async error handling
⋮----
// Error should be logged
</file>

<file path="src/daemon/__tests__/ProcessManager.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { ProcessManager } from "../ProcessManager";
import { createTempDir, cleanupTempDir } from "@/test-utils";
⋮----
// Track mock processes by PID
⋮----
// Store reference to the original process.kill
⋮----
// Override process.kill globally
⋮----
// Just checking if process exists
⋮----
// Process doesn't exist - throw ESRCH error
⋮----
// Actually killing the process
⋮----
// For SIGTERM, trigger the mock process kill method
⋮----
// For other signals (like SIGKILL), just remove from tracking
⋮----
// Mock child_process module
⋮----
// Trigger exit handlers
⋮----
// Track the process
⋮----
// Mock logger
⋮----
// Clear all tracking
⋮----
// Clean up any remaining processes
⋮----
// Clean up temp directory
⋮----
// Clear all tracking
⋮----
// Check that a process was spawned
⋮----
// Check that the manager tracks it as running
⋮----
// Try to spawn again
⋮----
// Should still be just one process
⋮----
// The process should be tracked by customId in ProcessManager
⋮----
// But not by the path basename
⋮----
// Get the spawned process
⋮----
// Manually trigger process exit
⋮----
// Call the exit handler
⋮----
// Process should be removed from tracking
⋮----
// Temporarily override spawn to create an error process
⋮----
// Trigger error immediately
⋮----
// Clean up
⋮----
// Track it briefly
⋮----
// Return to default behavior for other tests
⋮----
// Wait for error handler
⋮----
// Process should not be running
⋮----
// Restore original module mock
⋮----
// Verify it's running first
⋮----
// Get the PID and remove it from active PIDs
⋮----
// The ProcessManager uses process.kill(pid, 0) to check if process exists
// Our mock will return false since we removed it from activePids
⋮----
// Should detect process is dead
⋮----
// Wait for process to exit
⋮----
// Should not throw
⋮----
// Get the mock process and make it not respond to SIGTERM
⋮----
// Override kill to not trigger exit
⋮----
// Don't trigger exit handlers
⋮----
// Override once to capture the handler but not remove the PID
⋮----
// Start the stop operation
⋮----
// Wait a bit then trigger timeout by calling process.kill with SIGKILL
⋮----
// ProcessManager should try SIGKILL after timeout
// We'll simulate the process finally dying
⋮----
// Call any exit handlers that were registered
⋮----
// Start multiple projects
⋮----
// Wait for all processes to exit
⋮----
// Should not throw when no processes
⋮----
// Stop only project1
⋮----
// Start and stop multiple times
</file>

<file path="src/daemon/EventMonitor.ts">
import { getNDK } from "@/nostr/ndkClient";
import { logger } from "@/utils/logger";
import type { NDKEvent, NDKFilter, NDKSubscription } from "@nostr-dev-kit/ndk";
import { nip19 } from "nostr-tools";
import type { IProcessManager } from "./ProcessManager";
import type { IProjectManager } from "./ProjectManager";
⋮----
export interface IEventMonitor {
    start(whitelistedPubkeys: string[]): Promise<void>;
    stop(): Promise<void>;
}
⋮----
start(whitelistedPubkeys: string[]): Promise<void>;
stop(): Promise<void>;
⋮----
export class EventMonitor implements IEventMonitor
⋮----
constructor(
⋮----
async start(whitelistedPubkeys: string[]): Promise<void>
⋮----
async stop(): Promise<void>
⋮----
private async handleEvent(event: NDKEvent): Promise<void>
⋮----
// Check if event has project "a" tag
⋮----
// Check if project is already running
⋮----
// Ensure project exists and get path
⋮----
// Spawn project run process
⋮----
private getProjectTag(event: NDKEvent): string | undefined
⋮----
private extractProjectIdentifier(aTag: string): string | undefined
⋮----
// Format: kind:pubkey:identifier
⋮----
private reconstructNaddr(aTag: string, eventPubkey: string): string
⋮----
// Parse the a tag to get project details
⋮----
// Validate that kind is present
⋮----
// Use the pubkey from the a tag if available, otherwise use event pubkey
⋮----
// Encode as naddr
</file>

<file path="src/event-handler/__tests__/reply.delegation.test.ts">
import { describe, it, expect } from "bun:test";
⋮----
// The new architecture ensures:
// 1. PM is the visible orchestrator
// 2. NDKTask events handle formal delegation
// 3. Task completions trigger agent reactivation
// 4. No complex state machines - just event-driven callbacks
⋮----
// All principles should be true in the new design
⋮----
// The delegation flow is simple:
// 1. Agent calls delegate() creating NDKTask events
// 2. Agent state tracks pending task IDs
// 3. Task completions update state
// 4. When all complete, agent is reactivated with synthesized responses
⋮----
expect(flowSteps.length).toBe(4); // Simple 4-step process
</file>

<file path="src/events/NDKMCPTool.ts">
import { NDKEvent, type NDKRawEvent } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
⋮----
export class NDKMCPTool extends NDKEvent
⋮----
constructor(ndk?: NDK, event?: NDKEvent | NDKRawEvent)
⋮----
static from(event: NDKEvent): NDKMCPTool
⋮----
get name(): string | undefined
⋮----
set name(value: string | undefined)
⋮----
get description(): string | undefined
⋮----
set description(value: string | undefined)
⋮----
get command(): string | undefined
⋮----
set command(value: string | undefined)
⋮----
get image(): string | undefined
⋮----
set image(value: string | undefined)
⋮----
get slug(): string
</file>

<file path="src/lib/fs/index.ts">

</file>

<file path="src/lib/fs/tenex.ts">
import path from "node:path";
import { directoryExists, ensureDirectory } from "./filesystem.js";
⋮----
/**
 * Get paths for common .tenex files
 */
export function getTenexPaths(projectPath: string):
⋮----
// Configuration operations removed - use ConfigService from @/services instead
⋮----
/**
 * Check if a project has been initialized (has .tenex directory)
 */
export async function isProjectInitialized(projectPath: string): Promise<boolean>
⋮----
/**
 * Initialize .tenex directory structure
 */
export async function initializeTenexDirectory(projectPath: string): Promise<void>
⋮----
// Create main .tenex directory
⋮----
// Create subdirectories
</file>

<file path="src/llm/__tests__/pricing.test.ts">
/**
 * Tests for OpenRouter pricing service
 */
⋮----
import { OpenRouterPricingService } from "../pricing";
⋮----
// Mock fetch for testing
⋮----
// Expected: (10000/1M * 0.0000003) + (5000/1M * 0.0000025) = 0.000000003 + 0.0000000125 = 0.0000000155
⋮----
// Expected: (10000 + 5000) / 1M * 1.0 = 0.015
</file>

<file path="src/llm/constants.ts">
/**
 * LLM Configuration Constants
 */
⋮----
// Default configuration keys used in llms.json
⋮----
// Default fallback key for agents when no llmConfig is specified
</file>

<file path="src/llm/index.ts">
// Export types
⋮----
// Export router and utilities
⋮----
// Export model utilities
⋮----
// Re-export commonly used multi-llm-ts types
</file>

<file path="src/llm/models.ts">
import { logger } from "@/utils/logger";
import { type ModelsList, loadModels, loadOpenRouterModels } from "multi-llm-ts";
import type { LLMProvider } from "./types";
⋮----
/**
 * Get available models for a provider
 */
export async function getModelsForProvider(
    provider: LLMProvider,
    apiKey?: string
): Promise<ModelsList | null>
⋮----
/**
 * Get all available models grouped by provider
 */
export async function getAllModels(
    credentials?: Record<string, string>
): Promise<Record<string, ModelsList>>
⋮----
// Handle OpenRouter separately if credentials are provided
</file>

<file path="src/llm/ToolResult.ts">
/**
 * Serializable representation of tool execution results
 * Preserves type information across LLM boundaries
 */
⋮----
import type { ToolExecutionResult } from "@/tools/types";
import type { ToolError } from "@/tools/core";
⋮----
/**
 * Simplified serialized tool result
 */
export interface SerializedToolResult {
    /** Whether the tool execution was successful */
    success: boolean;

    /** Tool execution duration in milliseconds */
    duration: number;

    /** The actual result data */
    data: {
        output?: unknown;
        error?: {
            kind: string;
            message: string;
        };
    };
}
⋮----
/** Whether the tool execution was successful */
⋮----
/** Tool execution duration in milliseconds */
⋮----
/** The actual result data */
⋮----
/**
 * Serialize a tool result for LLM transport
 */
export function serializeToolResult(result: ToolExecutionResult): SerializedToolResult
⋮----
/**
 * Check if an object is a serialized tool result
 */
export function isSerializedToolResult(obj: unknown): obj is SerializedToolResult
⋮----
/**
 * Deserialize a tool result back to typed format
 */
function deserializeToolError(
    error: { kind: string; message: string } | undefined
): ToolError | undefined
⋮----
// Create a proper ToolError based on the kind
⋮----
field: "unknown", // We don't serialize the field, so use a default
⋮----
tool: "unknown", // We don't serialize the tool name separately
⋮----
// If unknown kind, treat as system error
⋮----
export function deserializeToolResult(serialized: SerializedToolResult): ToolExecutionResult
</file>

<file path="src/nostr/__tests__/TypingIndicatorManager.manual.test.ts">
/**
 * Manual test to demonstrate typing indicator behavior
 * Run with: npm test -- src/nostr/__tests__/TypingIndicatorManager.manual.test.ts
 */
⋮----
import { describe, it } from "bun:test";
import { TypingIndicatorManager } from "../TypingIndicatorManager";
import type { NostrPublisher } from "../NostrPublisher";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Simulate rapid typing indicators
⋮----
// Wait to see when stop is published
⋮----
}, 10000); // 10 second timeout for this test
</file>

<file path="src/nostr/__tests__/TypingIndicatorManager.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock, spyOn } from "bun:test";
import { TypingIndicatorManager } from "../TypingIndicatorManager";
import type { NostrPublisher } from "../NostrPublisher";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import { logger } from "@/utils/logger";
⋮----
// Request stop immediately
⋮----
// Stop should not be published immediately
⋮----
// Wait for minimum duration (5 seconds)
⋮----
// Now stop should have been called
⋮----
// Rapid sequence: start -> stop -> start -> stop
⋮----
// Only two start calls should have been made
⋮----
// No stop call should have been made yet
⋮----
// After 5 seconds, stop should be called once
⋮----
// Multiple stop requests
⋮----
// Wait for stop to trigger
⋮----
// Should only publish stop once
⋮----
// Wait 2 seconds
⋮----
// Start typing again (updates message but doesn't reset timer)
⋮----
// Request stop
⋮----
// Should stop after 3 more seconds (5 total from first start)
⋮----
// Note: Bun doesn't have built-in fake timers like Vitest
// This test is kept for reference but skipped
// The actual timing tests above use real timeouts
⋮----
// Create a new manager instance for this test
⋮----
// Wait for stop to execute
⋮----
// Should log error
⋮----
// Manager should reset state despite error
⋮----
// Make publishTypingIndicatorRaw throw for stop
⋮----
// Should log error
⋮----
// Manager should reset state despite error
⋮----
// Execute multiple starts concurrently
⋮----
// Should be typing with state consistency
⋮----
// All start calls should have gone through
⋮----
// Request stop
⋮----
// Wait 2 seconds (less than minimum)
⋮----
// Start again (should cancel the pending stop)
⋮----
// Wait for original stop time to pass
⋮----
// Should still be typing (stop was cancelled)
⋮----
// Stop should not have been called
⋮----
// Cleanup while stop is pending
⋮----
// Wait for stop duration
⋮----
// Stop should not have been called (timer was cleared)
⋮----
// Should not call publisher
⋮----
// Should not call publisher
⋮----
// Start again without message (should keep previous)
⋮----
// Should use the first message for the second call
⋮----
// Should have called 3 times (initial + 2 retries)
⋮----
// Should have taken at least 3 seconds (1s + 2s delays)
⋮----
expect(true).toBe(false); // Should not reach here
⋮----
// State should be reset after failure
⋮----
// Wait exactly 5 seconds
⋮----
// Stop should execute quickly now
⋮----
// Small delay for execution
⋮----
// ForceStop should have executed immediately
</file>

<file path="src/nostr/tags.ts">
/**
 * Strongly typed Nostr tag definitions for consistency across the codebase
 */
⋮----
// Status tags
⋮----
// LLM-related tags - consistent prefix for all LLM metadata
⋮----
// Session and execution tags
⋮----
// Claude-specific tags
</file>

<file path="src/nostr/types.ts">
export interface LLMMetadata {
    model: string;
    cost: number;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    contextWindow?: number;
    maxCompletionTokens?: number;
    systemPrompt?: string;
    userPrompt?: string;
    rawResponse?: string;
}
⋮----
export interface PublishOptions {
    llmMetadata?: LLMMetadata;
    metadata?: Record<string, string | number | boolean | string[]>;
}
</file>

<file path="src/prompts/__tests__/FragmentRegistry.test.ts">
import { FragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
</file>

<file path="src/prompts/__tests__/PromptBuilder.test.ts">
import { PromptBuilder } from "../core/PromptBuilder";
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
// Clear the global registry before each test
⋮----
// Restore registry state
⋮----
interface TestArgs {
                name: string;
                value: number;
            }
⋮----
fragmentRegistry.register({ id: "f2", template: () => "Middle" }); // default 50
⋮----
interface UserArgs {
                user: { name: string; role: string };
                permissions: string[];
            }
⋮----
// Manually add a fragment config without registering the fragment
</file>

<file path="src/prompts/core/FragmentRegistry.ts">
import type { PromptFragment } from "./types";
⋮----
export class FragmentRegistry
⋮----
register<T>(fragment: PromptFragment<T>): void
⋮----
get(id: string): PromptFragment<unknown> | undefined
⋮----
has(id: string): boolean
⋮----
clear(): void
⋮----
getAllIds(): string[]
</file>

<file path="src/prompts/core/index.ts">

</file>

<file path="src/prompts/core/types.ts">
export interface PromptFragment<T = unknown> {
    id: string;
    priority?: number;
    template: (args: T) => string;
    validateArgs?: (args: unknown) => args is T;
    expectedArgs?: string; // Description of expected arguments for error messages
}
⋮----
expectedArgs?: string; // Description of expected arguments for error messages
⋮----
export interface FragmentConfig {
    fragmentId: string;
    args: unknown;
    condition?: (args: unknown) => boolean;
}
</file>

<file path="src/prompts/fragments/__tests__/agentFragments.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { phaseContextFragment } from "../agentFragments";
import type { Conversation, PhaseTransition } from "@/conversations/types";
import type { Phase } from "@/conversations/phases";
⋮----
// Transition to a different phase
⋮----
mockConversation.phase = "plan"; // Looking for plan, but only have execute
</file>

<file path="src/prompts/fragments/__tests__/voice-mode.test.ts">
import { describe, expect, it } from "bun:test";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import { isVoiceMode } from "../voice-mode";
</file>

<file path="src/services/__tests__/ConfigService.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { ConfigService } from "../ConfigService";
import { createTempDir, cleanupTempDir } from "@/test-utils";
⋮----
import { promises as fs } from "node:fs";
⋮----
// Clear singleton state
⋮----
// Clean up
⋮----
// Clear singleton and cache
⋮----
// Create an isolated project dir that doesn't load global config
⋮----
description: 123, // Invalid type
invalidField: "test" // Unknown field
⋮----
// Should throw on invalid type
⋮----
// First load
⋮----
// Modify file directly
⋮----
// Second load should return cached value
⋮----
expect(loaded2.description).toBe("Test"); // Still cached
⋮----
// Clear cache and load again
⋮----
expect(loaded3.description).toBe("Modified"); // Fresh from file
⋮----
// Load both
⋮----
// Modify config file
⋮----
// Clear only config cache
⋮----
// Config should be fresh, agents still cached
⋮----
// Write invalid JSON
⋮----
expect(loaded).toEqual({}); // Default value
⋮----
// Try to load from non-existent directory
⋮----
// Try to save to a file path (not a directory)
⋮----
// This should throw because it can't create .tenex directory
⋮----
// Save using convenience methods
⋮----
// Load using convenience methods
⋮----
// Note: loadConfig merges global and project configs
// Since we can't easily mock the global path, we'll test the merging logic
// by saving to different project directories
⋮----
// Load each individually to verify they saved correctly
</file>

<file path="src/services/config/__tests__/mcp-config.test.ts">
import { describe, it, expect } from "bun:test";
import { z } from "zod";
import { TenexMCPSchema, MCPServerConfigSchema } from "../types";
import type { TenexMCP, MCPServerConfig } from "../types";
⋮----
{ args: ["server.js"] }, // Missing command
{ command: "node" }, // Missing args
{}, // Missing both
⋮----
command: 123, // Should be string
⋮----
args: "server.js", // Should be array
⋮----
env: "API_KEY=secret", // Should be object
⋮----
allowedPaths: "/path1", // Should be array
⋮----
// Missing args
⋮----
// Simulate merge
⋮----
// Project should override global
⋮----
// All env values should remain as strings
</file>

<file path="src/services/mcp/__tests__/MCPService.integration.test.ts">
import { describe, it, expect, beforeEach, afterEach, spyOn } from "bun:test";
import { MCPService } from "../MCPService";
import { spawn } from "child_process";
⋮----
import { configService } from "@/services/ConfigService";
import type { TenexMCP } from "@/services/config/types";
⋮----
// Helper to create a simple MCP server for testing
async function createTestMCPServer(serverPath: string)
⋮----
// Reset singleton
⋮----
// Create test directories
⋮----
// Create test MCP server
⋮----
// Shutdown service
⋮----
// Clean up test files
⋮----
// Mock config loading
⋮----
// Initialize service
⋮----
// Verify server is running
⋮----
// Get available tools
⋮----
// Check tool details
⋮----
// Execute echo tool
⋮----
// Execute add tool
⋮----
// Get the process and kill it externally
⋮----
// Kill the process
⋮----
// Wait a bit for the process to die
⋮----
// Server should no longer be running
⋮----
// Tool execution should fail
⋮----
// Create a second test server
⋮----
// Both servers should be running
⋮----
// Get tools from both servers
⋮----
expect(tools).toHaveLength(4); // 2 tools from each server
⋮----
// Execute tools on both servers
⋮----
// Shutdown should stop both servers
⋮----
// Server should not be running
⋮----
// No tools should be available
⋮----
// Create a server that sends invalid JSON
⋮----
// Server should fail health check
⋮----
// Should not start for disallowed project
⋮----
// Reset and try with allowed path
⋮----
// Create a server that checks env vars
⋮----
// Check custom env var
⋮----
// Check that process env is also available
</file>

<file path="src/services/mcp/__tests__/MCPService.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock, spyOn } from "bun:test";
import { MCPService } from "../MCPService";
import { ChildProcess } from "child_process";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import type { MCPServerConfig, TenexMCP } from "@/services/config/types";
import type { Tool, PluginParameter } from "@/tools/types";
import { configService } from "@/services";
⋮----
// Mock modules
⋮----
// We don't need to mock spawn directly as StdioClientTransport handles it
⋮----
// Reset all mocks
⋮----
// Reset singleton instance
⋮----
// Create mock process
⋮----
// Simulate process exit after a short delay
⋮----
// Create mock transport with process
⋮----
process: mockProcess, // The transport has the process
⋮----
// Create mock client
⋮----
// Reset mocks first
⋮----
// Setup mocks
⋮----
// Store the options for verification
⋮----
// Clean up the service after each test
⋮----
// Reset singleton instance
⋮----
// Reset the isInitialized flag
⋮----
// Mock health check failure
⋮----
// Server should not be started if health check fails
⋮----
// Test with disallowed project path
⋮----
// Both servers should start
⋮----
// Mock health check to never resolve
⋮----
healthCheckPromise = new Promise(() => {}); // Never resolves
⋮----
// Wait for initialization to complete (which includes the health check timeout)
⋮----
// The process should not be added to clients due to health check failure
⋮----
// Check that parameters has correct shape
⋮----
// Check properties
⋮----
// Check parameters shape
⋮----
// Kill the process to simulate server crash
⋮----
// Should still attempt to kill process
⋮----
// Mock process that doesn't exit
⋮----
// Wait a bit but don't call exit callback
⋮----
// Force the timeout
⋮----
// This should be allowed but might be a security concern
⋮----
// Should allow since /test/project starts with /test
</file>

<file path="src/services/mcp/MCPToolAdapter.ts">
import type { Tool } from "@/tools/types";
import { createZodSchema, mcpSchemaToZod } from "@/tools/zod-schema";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { z } from "zod";
⋮----
// Import MCPPropertyDefinition type
interface MCPPropertyDefinition {
    type?: "string" | "number" | "integer" | "boolean" | "array" | "object";
    description?: string;
    enum?: string[];
    minLength?: number;
    maxLength?: number;
    minimum?: number;
    maximum?: number;
    items?: MCPPropertyDefinition;
    properties?: Record<string, MCPPropertyDefinition>;
    required?: string[];
    minItems?: number;
    maxItems?: number;
}
⋮----
export interface MCPTool {
    name: string;
    description?: string;
    inputSchema?: {
        properties?: Record<string, MCPPropertyDefinition>;
        required?: string[];
    };
}
⋮----
/**
 * Converts an MCP tool definition to our type-safe tool system using Zod
 */
export function adaptMCPTool(
    mcpTool: MCPTool,
    serverName: string,
    executeFn: (args: Record<string, unknown>) => Promise<unknown>
): Tool<Record<string, unknown>, unknown>
⋮----
// Convert MCP input schema to Zod schema
⋮----
// Add description to the schema
⋮----
// Create the parameter schema using our Zod adapter
⋮----
// Create a Tool that wraps the MCP tool
⋮----
/**
 * Type-safe MCP tool with proper inference
 */
export interface TypedMCPTool<TInput extends z.ZodType<unknown>>
    extends Tool<z.infer<TInput>, unknown> {
    readonly inputSchema: TInput;
}
⋮----
/**
 * Create a strongly-typed MCP tool
 */
export function createTypedMCPTool<TInput extends z.ZodType<unknown>>(config: {
    name: string;
    serverName: string;
    description?: string;
    inputSchema: TInput;
execute: (args: z.infer<TInput>)
</file>

<file path="src/services/index.ts">
/**
 * Centralized services for TENEX
 */
</file>

<file path="src/test-utils/mock-llm/scenarios/index.ts">
import { orchestratorWorkflowScenario } from "./orchestrator-workflow";
import { errorHandlingScenario } from "./error-handling";
import { statePersistenceScenario } from "./state-persistence";
import { routingDecisions } from "./routing-decisions";
import { performanceTestingScenario } from "./performance-testing";
import { concurrencyWorkflowScenarios } from "./concurrency-workflow";
import { inventoryGenerationScenario } from "./inventory-generation";
import { networkResilienceScenario } from "./network-resilience";
import type { MockLLMScenario } from "../types";
⋮----
/**
 * All available mock scenarios for testing
 */
⋮----
/**
 * Concurrency testing scenarios
 */
⋮----
// Add concurrency scenarios to all scenarios
⋮----
/**
 * Get a specific scenario by name
 */
export function getScenario(name: string): MockLLMScenario | undefined
⋮----
/**
 * Create a custom scenario for specific test cases
 */
export function createScenario(
    name: string,
    description: string,
    responses: MockLLMScenario['responses']
): MockLLMScenario
</file>

<file path="src/test-utils/mock-llm/scenarios/network-resilience.ts">
import type { MockLLMScenario } from "../types";
⋮----
/**
 * Scenario for testing Nostr network resilience
 * Provides simple, deterministic responses for network failure testing
 */
⋮----
// Orchestrator responses for initial requests
⋮----
// Planner responses
⋮----
// Executor responses
⋮----
// Verification phase
⋮----
// Generic fallback for any agent
</file>

<file path="src/test-utils/mock-llm/scenarios/performance-testing.ts">
import type { MockLLMScenario } from "../types";
⋮----
/**
 * Performance testing scenarios that simulate slow responses, timeouts, and system stress
 */
⋮----
// Scenario: Slow LLM response during orchestration
⋮----
streamDelay: 5000, // 5 second delay
⋮----
// Scenario: Very slow planning phase
⋮----
streamDelay: 8000, // 8 second delay
⋮----
// Scenario: Timeout simulation (exceeds typical timeout)
⋮----
streamDelay: 35000, // 35 second delay (should trigger timeout)
⋮----
// Scenario: Slow tool execution
⋮----
streamDelay: 3000, // 3 second delay for tool response
⋮----
// Scenario: Rapid sequential requests (stress test)
⋮----
streamDelay: 50, // Very short delay
⋮----
// Scenario: Memory-intensive response
⋮----
// Generate a large response to test memory handling
content: "Large response data: " + "x".repeat(50000), // 50KB of data
⋮----
// Scenario: Recovery after timeout
⋮----
streamDelay: 100, // Quick response after timeout
⋮----
// Performance test initial response
</file>

<file path="src/test-utils/mock-llm/scenarios/routing-decisions.ts">
import type { MockLLMScenario } from "../types";
⋮----
/**
 * Mock responses for orchestrator routing decisions
 */
⋮----
// Error recovery routing
⋮----
// Infinite loop routing
⋮----
// Timeout test routing
⋮----
// Multi-agent error routing
⋮----
// Default routing response for any orchestrator message with JSON instruction
</file>

<file path="src/test-utils/mock-llm/scenarios/state-persistence.ts">
import type { MockLLMScenario } from "../types";
⋮----
/**
 * Scenario for testing conversation state persistence and recovery
 * Simulates partial workflow execution and recovery after restart
 */
⋮----
// Initial orchestrator response - transition to PLAN phase
⋮----
// Plan phase response - transition to BUILD
⋮----
// Test agent BUILD phase response
⋮----
// Analyze project structure scenario
⋮----
// Recovery scenario - continue analysis
⋮----
// Concurrent task scenarios
</file>

<file path="src/test-utils/mock-llm/performance.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { MockLLMService } from "./MockLLMService";
import type { MockLLMScenario } from "./types";
⋮----
/**
 * Unit tests for MockLLMService performance features
 * Tests that streamDelay works correctly for simulating slow responses
 */
⋮----
// Create a simple scenario with delays
⋮----
streamDelay: 3000, // 3 second delay
⋮----
streamDelay: 1000, // 1 second delay
⋮----
streamDelay: 0, // No delay
⋮----
// Should take at least 1000ms
⋮----
// Should take at least 3000ms
⋮----
// Should be nearly instant (less than 100ms)
⋮----
// Stream the response
⋮----
// Streaming should also respect the delay
⋮----
// Make a delayed request
⋮----
// Start three requests concurrently
⋮----
// All should complete, with the slowest determining total time
</file>

<file path="src/test-utils/test-persistence-adapter.ts">
import type { Conversation } from "@/conversations/types";
import type { 
    ConversationPersistenceAdapter, 
    ConversationMetadata,
    ConversationSearchCriteria 
} from "@/conversations/persistence/types";
⋮----
/**
 * In-memory persistence adapter for testing
 * Avoids file system operations and serialization issues in tests
 */
export class TestPersistenceAdapter implements ConversationPersistenceAdapter
⋮----
async initialize(): Promise<void>
⋮----
// No initialization needed for in-memory storage
⋮----
async save(conversation: Conversation): Promise<void>
⋮----
// Store conversation directly without serialization
⋮----
// Deep clone to prevent mutations
⋮----
async load(id: string): Promise<Conversation | null>
⋮----
// Return a deep clone to prevent mutations
⋮----
async delete(id: string): Promise<void>
⋮----
async list(): Promise<ConversationMetadata[]>
⋮----
async search(criteria: ConversationSearchCriteria): Promise<ConversationMetadata[]>
⋮----
// Check archived status
⋮----
// Check other criteria
⋮----
async archive(conversationId: string): Promise<void>
⋮----
async restore(conversationId: string): Promise<void>
⋮----
private createMetadata(conv: Conversation): ConversationMetadata
⋮----
// Test-specific methods
clear(): void
⋮----
getAll(): Map<string, Conversation>
</file>

<file path="src/tools/__tests__/core.test.ts">
import { describe, it, expect } from "bun:test";
import type { Result, Tool } from "../core";
</file>

<file path="src/tools/__tests__/utils.test.ts">
import { describe, expect, it } from "bun:test";
import { resolveAndValidatePath } from "../utils";
import { resolve } from "node:path";
</file>

<file path="src/tools/implementations/__tests__/complete.test.ts">
import { describe, it, expect } from "bun:test";
import { completeTool } from "../complete";
import { z } from "zod";
⋮----
response: 123, // number instead of string
summary: true, // boolean instead of string
⋮----
// Access the schema shape to verify descriptions
⋮----
// Verify required fields
</file>

<file path="src/tools/implementations/__tests__/readPath.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { readPathTool } from "../readPath";
import { createTempDir, cleanupTempDir } from "@/test-utils";
import { writeFileSync, mkdirSync } from "node:fs";
⋮----
import type { Tool, ToolContext } from "@/tools/types";
⋮----
// Mock conversation manager
⋮----
// Reset mocks before each test
⋮----
// Reset mock implementation
⋮----
// Create test context
⋮----
// Create test files and directories
⋮----
// Mock conversation with existing tracked file
⋮----
// Make file unreadable (this might not work on all systems)
⋮----
// Skip test if chmod doesn't work
⋮----
// Restore permissions
⋮----
// Cleanup error ignored in test teardown
⋮----
// Should return directory listing instead of error
⋮----
// Create circular symlink (platform dependent)
⋮----
// Skip if symlinks not supported
⋮----
const largeContent = "x".repeat(1024 * 1024); // 1MB
⋮----
// Context without conversation manager
</file>

<file path="src/tools/implementations/__tests__/shell-simple.test.ts">
import { describe, it, expect } from "bun:test";
import { shellTool } from "../shell";
import { createMockExecutionContext } from "@/test-utils";
⋮----
// Missing required command
</file>

<file path="src/tools/implementations/switch_phase.ts">
import { z } from "zod";
import { createToolDefinition, success, failure } from "../types";
import { PHASES, type Phase } from "@/conversations/phases";
import { logger } from "@/utils/logger";
⋮----
/**
 * Switch the conversation to a new phase.
 * This tool is EXCLUSIVE to the Project Manager agent for orchestrating workflow.
 * 
 * The reason provided becomes critical context for the next agent, explaining
 * what needs to be accomplished in this phase.
 */
⋮----
// Verify this is the PM (belt and suspenders - should already be restricted by toolset)
⋮----
// Update conversation phase through ConversationManager
⋮----
reason, // This becomes the phase transition message
⋮----
reason, // Also store as the reason
`Switching to ${phase} phase: ${reason}` // Summary for history
</file>

<file path="src/tools/executor.ts">
/**
 * Simplified tool executor
 */
⋮----
import type { Tool, ToolError, Validated } from "./core";
import type { ExecutionContext } from "./types";
import { logger } from "@/utils/logger";
import { formatAnyError } from "@/utils/error-formatter";
⋮----
/**
 * Metadata that tools can provide for better UI/logging
 */
export interface ToolExecutionMetadata {
    /** Human-readable message describing what the tool is doing */
    displayMessage?: string;
    /** The actual arguments that were executed (for tools that skip tool_start) */
    executedArgs?: Record<string, unknown>;
    /** Any other metadata the tool wants to provide */
    [key: string]: unknown;
}
⋮----
/** Human-readable message describing what the tool is doing */
⋮----
/** The actual arguments that were executed (for tools that skip tool_start) */
⋮----
/** Any other metadata the tool wants to provide */
⋮----
/**
 * Simple, unified tool execution result
 */
export interface ToolExecutionResult<T = unknown> {
    success: boolean;
    output?: T;
    error?: ToolError;
    duration: number;
    /** Optional metadata for UI/logging purposes */
    metadata?: ToolExecutionMetadata;
}
⋮----
/** Optional metadata for UI/logging purposes */
⋮----
/**
 * Simple tool executor
 */
export class ToolExecutor
⋮----
constructor(private readonly context: ExecutionContext)
⋮----
/**
     * Execute a tool with the given input
     */
async execute<I, O>(tool: Tool<I, O>, input: unknown): Promise<ToolExecutionResult<O>>
⋮----
// Skip validation for generate_inventory tool
⋮----
// Pass through any input for generate_inventory
⋮----
// Validate input for other tools
⋮----
// Execute the tool
⋮----
metadata: result.metadata, // Pass through metadata if present
⋮----
/**
 * Create a tool executor for a given context
 */
export function createToolExecutor(context: ExecutionContext): ToolExecutor
</file>

<file path="src/tools/utils.ts">
import { isAbsolute, relative, resolve } from "node:path";
⋮----
/**
 * Resolves and validates a file path to ensure it stays within the project boundaries.
 *
 * @param filePath - The file path to validate (can be absolute or relative)
 * @param projectPath - The root project path
 * @returns The resolved absolute path if valid
 * @throws Error if the path would escape the project directory
 */
export function resolveAndValidatePath(filePath: string, projectPath: string): string
</file>

<file path="src/tracing/__tests__/TracingContext.test.ts">
import { describe, expect, it, vi } from "vitest";
import {
    createTracingContext,
    createAgentExecutionContext,
    createToolExecutionContext,
    createPhaseExecutionContext,
    generateExecutionId,
    formatTracingContext,
    type TracingContext
} from "../TracingContext";
⋮----
// Empty strings are falsy, so they won't be included in optional fields
⋮----
// Start with base context
⋮----
// Add agent context
⋮----
// Add phase context
⋮----
// Add tool context
⋮----
// Original should be unchanged
⋮----
// They should share the same base properties
</file>

<file path="src/tracing/__tests__/TracingLogger.test.ts">
import { describe, expect, it, beforeEach } from "bun:test";
import { TracingLogger } from "../TracingLogger";
import type { TracingContext } from "../TracingContext";
</file>

<file path="src/tracing/index.ts">

</file>

<file path="src/tracing/TracingContext.ts">
import { randomBytes } from "node:crypto";
⋮----
/**
 * Minimal context for debugging execution flow through the TENEX system.
 */
export interface TracingContext {
    conversationId: string; // ID of the conversation (from Nostr event)
    executionId: string; // Unique ID for this specific execution/request
    currentAgent?: string; // Current agent name for debugging
    currentPhase?: string; // Current phase for debugging
    currentTool?: string; // Current tool being executed
}
⋮----
conversationId: string; // ID of the conversation (from Nostr event)
executionId: string; // Unique ID for this specific execution/request
currentAgent?: string; // Current agent name for debugging
currentPhase?: string; // Current phase for debugging
currentTool?: string; // Current tool being executed
⋮----
/**
 * Generate a unique execution ID
 */
export function generateExecutionId(prefix = "exec"): string
⋮----
/**
 * Create a new tracing context for a conversation
 */
export function createTracingContext(conversationId: string): TracingContext
⋮----
/**
 * Create an agent execution context
 */
export function createAgentExecutionContext(
    parent: TracingContext,
    agentName: string
): TracingContext
⋮----
/**
 * Create a tool execution context
 */
export function createToolExecutionContext(
    parent: TracingContext,
    toolName: string
): TracingContext
⋮----
/**
 * Create a phase execution context
 */
export function createPhaseExecutionContext(parent: TracingContext, phase: string): TracingContext
⋮----
/**
 * Format tracing context for logging
 */
export function formatTracingContext(context: TracingContext): Record<string, unknown>
</file>

<file path="src/tracing/TracingLogger.ts">
import { type LogModule, logger as baseLogger, parseModuleVerbosity } from "@/utils/logger";
import type { TracingContext } from "./TracingContext";
import { formatTracingContext } from "./TracingContext";
⋮----
/**
 * Enhanced logger that automatically includes tracing context in all log entries
 */
export class TracingLogger
⋮----
constructor(
        private context: TracingContext,
        private module?: LogModule
)
⋮----
// Check if tracing is enabled based on module verbosity
⋮----
// Only enable tracing for verbose or debug levels
⋮----
/**
     * Create a scoped logger for a specific module
     */
forModule(module: LogModule): TracingLogger
⋮----
/**
     * Update the tracing context
     */
withContext(context: TracingContext): TracingLogger
⋮----
/**
     * Format message with tracing context
     */
private formatMessage(
        _message: string,
        additionalContext?: Record<string, unknown>
): [Record<string, unknown>]
⋮----
info(message: string, additionalContext?: Record<string, unknown>): void
⋮----
success(message: string, additionalContext?: Record<string, unknown>): void
⋮----
// Log context separately for success messages
⋮----
warning(message: string, additionalContext?: Record<string, unknown>): void
⋮----
error(message: string, error?: unknown, additionalContext?: Record<string, unknown>): void
⋮----
// Log error with full context
⋮----
debug(message: string, additionalContext?: Record<string, unknown>): void
⋮----
/**
     * Log the start of an operation
     */
startOperation(operation: string, additionalContext?: Record<string, unknown>): void
⋮----
/**
     * Log the completion of an operation
     */
completeOperation(operation: string, additionalContext?: Record<string, unknown>): void
⋮----
/**
     * Log a failed operation
     */
failOperation(
        operation: string,
        error: unknown,
        additionalContext?: Record<string, unknown>
): void
⋮----
/**
     * Log an event publication
     */
logEventPublished(
        eventId: string,
        eventType: string,
        additionalContext?: Record<string, unknown>
): void
⋮----
/**
     * Log LLM interaction
     */
logLLMRequest(model: string, additionalContext?: Record<string, unknown>): void
⋮----
/**
     * Log LLM response
     */
logLLMResponse(model: string, additionalContext?: Record<string, unknown>): void
⋮----
/**
 * Create a tracing logger instance
 */
export function createTracingLogger(context: TracingContext, module?: LogModule): TracingLogger
</file>

<file path="src/utils/__tests__/agentFetcher.test.ts">
import { describe, test, expect, mock, beforeEach } from "bun:test";
import { fetchAgentDefinition } from "../agentFetcher";
import type NDK from "@nostr-dev-kit/ndk";
import { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Create a mock NDKEvent
⋮----
// Create mock NDK instance
</file>

<file path="src/utils/__tests__/cli-config-scope.test.ts">
import { describe, it, expect, mock, beforeEach } from "bun:test";
import { resolveConfigScope, formatConfigScope } from "../cli-config-scope";
⋮----
// Mock the ConfigService
</file>

<file path="src/utils/__tests__/configLocation.test.ts">
import { afterEach, beforeEach, describe, expect, it, mock, spyOn } from "bun:test";
import { configService } from "@/services/ConfigService";
import { logger } from "@/utils/logger";
import { determineConfigLocation, getConfigLocationDescription, type ConfigLocationOptions } from "../configLocation";
</file>

<file path="src/utils/__tests__/error-formatter.test.ts">
import { describe, it, expect } from "bun:test";
import { formatAnyError, formatToolError } from "../error-formatter";
import type { ToolError } from "@/tools/types";
</file>

<file path="src/utils/__tests__/formatting.test.ts">
import { describe, test, expect } from "bun:test";
import { formatDuration, formatMarkdown, colorizeJSON } from "../formatting";
</file>

<file path="src/utils/git/createExecutionBranch.ts">
import { execSync } from "node:child_process";
import { logger } from "@/utils/logger";
⋮----
export interface GitBranchResult {
    branchName: string;
    created: boolean;
}
⋮----
/**
 * Create a git branch for execution
 */
export function createExecutionBranch(
    baseName: string,
    projectPath: string = process.cwd()
): GitBranchResult
⋮----
// Check if we're in a git repository
⋮----
// Generate branch name
⋮----
// Create and checkout new branch
</file>

<file path="src/utils/git/index.ts">

</file>

<file path="src/utils/conversationFetcher.ts">
import { getAgentSlugFromEvent } from "@/nostr/utils";
import { type ProjectContext, getProjectContext } from "@/services";
import type NDK from "@nostr-dev-kit/ndk";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import chalk from "chalk";
⋮----
interface ConversationEvent {
    event: NDKEvent;
    author: string;
    isHuman: boolean;
    timestamp: Date;
    content: string;
    depth: number;
}
⋮----
interface ConversationTree {
    root: ConversationEvent;
    replies: Map<string, ConversationEvent[]>;
}
⋮----
export async function fetchConversation(
    bech32Event: string,
    ndk: NDK,
    _projectPath: string
): Promise<string>
⋮----
// Fetch the event directly using the nevent string
⋮----
// Get project context to identify human user
⋮----
// Get the root event Id (it's either E-tagged or then we already have it).
⋮----
// Fetch profiles for all participants
⋮----
// Build conversation tree
⋮----
// Format as markdown
⋮----
async function fetchAllEventsInConversation(ndk: NDK, rootEventId: string): Promise<NDKEvent[]>
⋮----
// Sort by created_at
⋮----
async function fetchParticipantProfiles(
    events: NDKEvent[],
    ndk: NDK,
    projectCtx: ProjectContext
): Promise<Map<string, string>>
⋮----
// Collect unique pubkeys
⋮----
// Fetch profiles
⋮----
// Check if it's an agent first
⋮----
// Fetch from nostr
⋮----
function buildConversationTree(
    events: NDKEvent[],
    participants: Map<string, string>,
    humanPubkey: string
): ConversationTree
⋮----
// First pass: create ConversationEvent objects
⋮----
// Find parent
⋮----
// This is the root
⋮----
// Second pass: build reply structure
⋮----
// Direct reply to root
⋮----
// Calculate depths
function setDepth(event: ConversationEvent, depth: number): void
⋮----
// Get the first event from the map if no root event found
⋮----
function formatConversationMarkdown(tree: ConversationTree, _humanPubkey: string): string
⋮----
function formatEvent(event: ConversationEvent, indent = ""): void
⋮----
// Format content with proper indentation
⋮----
lines.push(""); // Empty line between messages
⋮----
// Format replies
</file>

<file path="src/utils/repomix.ts">
import { randomUUID } from "node:crypto";
import { unlinkSync, readFileSync, existsSync } from "node:fs";
import { tmpdir } from "node:os";
import { join, resolve, relative } from "node:path";
import { runDefaultAction, type CliOptions } from "repomix";
import { logger } from "@/utils/logger";
⋮----
export interface RepomixResult {
    content: string;
    size: number;
    lines: number;
    cleanup: () => void;
}
⋮----
/**
 * Generate repository content using repomix
 * @param projectPath - The root path of the project
 * @param targetDirectory - Optional directory to analyze relative to projectPath
 */
export async function generateRepomixOutput(
    projectPath: string,
    targetDirectory?: string
): Promise<RepomixResult>
⋮----
// Resolve the target path
⋮----
// Validate that the target directory exists
⋮----
// Ensure the target is within the project path
⋮----
// Configure repomix options for XML output
⋮----
// Use the programmatic API to generate repomix output
⋮----
// Read the generated file
⋮----
// Clean up on error
⋮----
// Ignore cleanup errors
</file>

<file path="src/utils/setup.ts">
import { LLMConfigEditor } from "@/llm/LLMConfigEditor";
import { configService } from "@/services";
import type { TenexConfig } from "@/services/config/types";
import { logger } from "@/utils/logger";
import chalk from "chalk";
import inquirer from "inquirer";
⋮----
export async function runInteractiveSetup(): Promise<TenexConfig>
⋮----
// Load current configuration to check what's missing
⋮----
// Step 1: Get whitelisted pubkeys if needed
⋮----
// Step 2: Save basic configuration
⋮----
// Step 3: Set up LLM configurations if needed
⋮----
const llmEditor = new LLMConfigEditor("", true); // Global config
⋮----
async function promptForPubkeys(): Promise<string[]>
</file>

<file path="src/index.ts">
// Main exports for TENEX CLI package
</file>

<file path="tests/e2e/executor-verification-flow.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { 
    setupE2ETest, 
    cleanupE2ETest, 
    createConversation,
    executeConversationFlow,
    assertAgentSequence,
    assertPhaseTransitions,
    assertToolCalls,
    assertFeedbackPropagated,
    type E2ETestContext,
    type ExecutionTrace
} from "./test-harness";
import type { MockLLMResponse } from "@/test-utils/mock-llm/types";
⋮----
// Setup with empty scenarios - we'll add responses dynamically
⋮----
// Define the flow scenario
⋮----
// 1. Orchestrator routes to executor (initial request)
⋮----
priority: 120  // Highest priority for initial user request
⋮----
// 2. Executor implements (first attempt)
⋮----
// Don't match on phase - it might be "chat" or "execute"
⋮----
// 3. Orchestrator routes to project-manager for verification
⋮----
previousAgent: "executor"  // After executor calls continue
⋮----
priority: 110  // Higher priority than the userMessage trigger
⋮----
// 4. Project Manager finds issues
⋮----
iterationCount: 1  // First verification
⋮----
// 5. Orchestrator routes back to executor with feedback
⋮----
previousAgent: "project-manager"  // After PM calls continue
⋮----
// 6. Executor fixes issues (second attempt)
⋮----
iterationCount: 2  // Second time executor is called
⋮----
// 7. Orchestrator routes to PM again
⋮----
// 8. Project Manager approves
⋮----
iterationCount: 2  // Second verification
⋮----
// Default fallback for any unmatched orchestrator calls
⋮----
// Add all responses to mock LLM
⋮----
// Create conversation
⋮----
// Execute the conversation flow
⋮----
// Verify the agent sequence
⋮----
"orchestrator",     // Initial routing
"executor",        // First implementation
"orchestrator",    // Route to verification
"project-manager", // Find issues
"orchestrator",    // Route back to executor
"executor",        // Fix issues
"orchestrator",    // Route to verification again
"project-manager"  // Final approval
⋮----
// Verify phase transitions
⋮----
"execute",      // Start in execute
"verification", // Move to verification
"execute",      // Back to execute for fixes
"verification"  // Final verification
⋮----
// Verify tool calls
⋮----
// Verify feedback was propagated
⋮----
// Verify conversation completed
⋮----
// Verify security issues were mentioned and fixed
⋮----
// Verify project manager feedback
⋮----
// Count how many times each agent was executed
⋮----
// Orchestrator should be called 4 times (initial + after each continue)
⋮----
// Executor should be called twice (initial + fix)
⋮----
// Project manager should be called twice (initial check + final approval)
⋮----
// Verify we captured phase transitions
⋮----
// Verify phase transitions are recorded in trace
⋮----
// Each transition should have a reason
</file>

<file path="tests/e2e/state-recovery.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { ConversationManager } from "@/conversations/ConversationManager";
import { AgentExecutor } from "@/agents/execution/AgentExecutor";
import { TestPersistenceAdapter } from "@/test-utils/test-persistence-adapter";
import { createMockLLMService } from "@/test-utils/mock-llm";
import { createMockNDKEvent, createMockAgent } from "@/test-utils/mock-factories";
import { EVENT_KINDS } from "@/llm/types";
import { logger } from "@/utils/logger";
import fs from "fs/promises";
import path from "path";
import os from "os";
⋮----
/**
 * E2E Tests for State Recovery and Persistence
 * 
 * These tests validate that TENEX can properly persist conversation state
 * and recover from interruptions, ensuring system reliability.
 */
⋮----
// Create temporary test directory
⋮----
// Setup test persistence adapter
⋮----
// Create mock LLM service with state persistence scenarios
⋮----
// Mock Nostr publisher to prevent network calls
⋮----
cleanup()
async publishResponse()
async publishError()
async publishTypingIndicator()
async stopTypingIndicator()
⋮----
// Mock AgentPublisher to prevent publishing during tests
⋮----
constructor()
initialize()
publishAgent()
⋮----
// Mock project context to avoid complex initialization
⋮----
// Mock LLM router
⋮----
getService()
validateModel()
⋮----
// Clean up test directory
⋮----
// Clear test persistence
⋮----
// Create conversation manager with test persistence
⋮----
// Create initial event
⋮----
// Create conversation
⋮----
// Verify initial state is persisted
⋮----
// Skip agent execution test for now - focus on persistence
// This test verifies that conversation state is properly saved
⋮----
// Manually update conversation state to simulate agent execution
⋮----
// Save the updated state
⋮----
// Verify state after first execution
⋮----
// Create first conversation manager instance
⋮----
// Create and execute initial conversation
⋮----
// Add some agent context
⋮----
// Update phase
⋮----
// Update the conversation object in memory to set execution time
⋮----
// Update title
⋮----
// Save the updated conversation
⋮----
// Simulate system restart - create new conversation manager
⋮----
// Load conversation from persistence
⋮----
// Verify all state is recovered correctly
⋮----
// Create conversation
⋮----
// Simulate partial agent execution
⋮----
// Mark conversation as in PLAN phase but incomplete
⋮----
// Add partial history
⋮----
// Save incomplete state
⋮----
// Simulate recovery - create new manager and load conversation
⋮----
expect(recovered?.history).toHaveLength(2); // Initial + partial response
⋮----
// Verify we can work with the recovered state
⋮----
// We should be able to add more context to the recovered conversation
⋮----
// Create conversation
⋮----
// First ensure we can do a simple update
⋮----
// Verify the simple update worked
⋮----
// Now test concurrent updates
⋮----
// Execute updates concurrently
⋮----
// Verify final state
⋮----
// We should have both agent contexts
⋮----
// Original history entry (initial user message) + at least one concurrent update
⋮----
// Create multiple conversations
⋮----
// Archive one conversation
⋮----
// List active conversations
⋮----
// Search for archived conversations
⋮----
// Restore archived conversation
⋮----
// Verify restoration
</file>

<file path="biome.json">
{
    "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
    "files": {
        "ignore": [
            ".tenex/**",
            "node_modules/**",
            "dist/**",
            "build/**",
            "*.min.js",
            "*.bundle.js",
            "**/*.test.js",
            "**/*.test.ts",
            "**/*.test.jsx",
            "**/*.test.tsx",
            "**/*.spec.js",
            "**/*.spec.ts",
            "**/*.spec.jsx",
            "**/*.spec.tsx",
            "**/tests/**",
            "**/test/**",
            "**/__tests__/**",
            "**/__test__/**"
        ]
    },
    "formatter": {
        "enabled": true,
        "formatWithErrors": false,
        "indentStyle": "space",
        "indentWidth": 2,
        "lineWidth": 100
    },
    "linter": {
        "enabled": true,
        "rules": {
            "recommended": true
        }
    },
    "organizeImports": {
        "enabled": true
    },
    "javascript": {
        "formatter": {
            "quoteStyle": "double",
            "trailingCommas": "es5",
            "semicolons": "always"
        }
    }
}
</file>

<file path="bunfig.toml">
# Bun configuration file

[test]
# Enable coverage reporting
coverage = true
coverageDirectory = "./coverage"
coverageReporter = ["text", "lcov"]

# Test file patterns
# Include all test files
root = "./src"

# Timeout for tests (in milliseconds)
timeout = 30000

# Run tests in watch mode by default in development
# watchMode = true

[install]
# Lockfile configuration
lockfile = { save = true }

# Auto-install peer dependencies
peer = true

[run]
# Enable source maps
smol = true
</file>

<file path="eslint.config.js">
export default typescript.config(
</file>

<file path="find_orphaned_files.sh">
#!/bin/bash

echo "Finding orphaned TypeScript/JavaScript files in src/"
echo "===================================================="
echo

# Function to check if a file is imported
check_file_imports() {
    local file=$1
    local filename=$(basename "$file")
    local dirname=$(dirname "$file")
    local basename_no_ext=${filename%.*}
    
    # For index.ts files, check if the directory is imported
    if [[ "$filename" == "index.ts" ]] || [[ "$filename" == "index.js" ]]; then
        # Get the parent directory name
        local parent_dir=$(basename "$dirname")
        # Check if the directory itself is imported
        local dir_imports=$(rg -c "from ['\"](\.\./|@/|src/).*$parent_dir['\"]" src/ 2>/dev/null | wc -l)
        if [ $dir_imports -gt 0 ]; then
            return 1  # Directory is imported, so index.ts is used
        fi
    fi
    
    # Skip checking for imports in the file itself
    local exclude_pattern="^$file:"
    
    # Various import patterns to check
    local patterns=(
        # Relative imports from parent directories
        "\.\./[^'\"]*$basename_no_ext['\"]"
        "\.\./[^'\"]*$basename_no_ext\.js['\"]"
        # Relative imports from same directory
        "\./$basename_no_ext['\"]"
        "\./$basename_no_ext\.js['\"]"
        # Absolute imports using @/
        "@/${file#src/}"
        "@/[^'\"]*$basename_no_ext['\"]"
        # Module path imports
        "${file#src/}"
        "${file#src/}\.js"
    )
    
    local total_imports=0
    
    for pattern in "${patterns[@]}"; do
        local count=$(rg -c "$pattern" src/ 2>/dev/null | grep -v "$exclude_pattern" | wc -l)
        total_imports=$((total_imports + count))
    done
    
    # Also check for barrel exports (index.ts files that might export this file)
    if [ -f "$dirname/index.ts" ] && [[ "$file" != "$dirname/index.ts" ]]; then
        local index_exports=$(rg -c "from ['\"]\./$basename_no_ext" "$dirname/index.ts" 2>/dev/null || echo 0)
        total_imports=$((total_imports + index_exports))
    fi
    
    return $total_imports
}

# Get all source files (excluding tests)
files=$(find src -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) | grep -v "__tests__" | grep -v "\.test\." | grep -v "\.spec\." | sort)

orphaned_files=()

for file in $files; do
    # Skip entry points and common config files
    if [[ "$file" == "src/tenex.ts" ]] || 
       [[ "$file" == "src/index.ts" ]] ||
       [[ "$file" == "src/types.ts" ]] ||
       [[ "$file" == *"/types.ts" ]] ||
       [[ "$file" == *"/constants.ts" ]] ||
       [[ "$file" == *"vite.config.ts" ]] ||
       [[ "$file" == *"jest.config.ts" ]]; then
        continue
    fi
    
    # Skip declaration files
    if [[ "$file" == *".d.ts" ]]; then
        continue
    fi
    
    check_file_imports "$file"
    import_count=$?
    
    if [ $import_count -eq 0 ]; then
        orphaned_files+=("$file")
    fi
done

# Display results
if [ ${#orphaned_files[@]} -eq 0 ]; then
    echo "No orphaned files found!"
else
    echo "Found ${#orphaned_files[@]} potentially orphaned files:"
    echo
    
    # Group files by type
    index_files=()
    regular_files=()
    
    for file in "${orphaned_files[@]}"; do
        if [[ "$(basename "$file")" == "index.ts" ]] || [[ "$(basename "$file")" == "index.js" ]]; then
            index_files+=("$file")
        else
            regular_files+=("$file")
        fi
    done
    
    # Display regular files first
    if [ ${#regular_files[@]} -gt 0 ]; then
        echo "Regular files:"
        echo "--------------"
        for file in "${regular_files[@]}"; do
            echo "📄 $file"
            
            # Show file info
            echo "   Size: $(wc -c < "$file" | xargs) bytes"
            echo "   Lines: $(wc -l < "$file" | xargs)"
            
            # Show exports
            exports=$(rg "^export" "$file" 2>/dev/null | head -3)
            if [ -n "$exports" ]; then
                echo "   Exports:"
                echo "$exports" | sed 's/^/     - /'
            fi
            
            # Show any TODO or DEPRECATED comments
            todos=$(rg "(TODO|DEPRECATED|FIXME)" "$file" 2>/dev/null | head -2)
            if [ -n "$todos" ]; then
                echo "   Notes:"
                echo "$todos" | sed 's/^/     - /'
            fi
            
            echo
        done
    fi
    
    # Display index files separately
    if [ ${#index_files[@]} -gt 0 ]; then
        echo "Index files (potentially unused module entry points):"
        echo "----------------------------------------------------"
        for file in "${index_files[@]}"; do
            echo "📁 $file"
            echo "   Directory: $(dirname "$file")"
            echo "   Exports: $(rg -c "^export" "$file" 2>/dev/null || echo 0) items"
            echo
        done
    fi
fi

# Additional check for files that might be CLI tools or scripts
echo
echo "Additional analysis:"
echo "-------------------"
if [ ${#orphaned_files[@]} -gt 0 ]; then
    standalone_scripts=()
    
    for file in "${orphaned_files[@]}"; do
        # Check if file has a shebang or main execution block
        if head -1 "$file" | grep -q "^#!" || rg -q "if \(__name__ ==|if \(import\.meta\.main\)" "$file"; then
            standalone_scripts+=("$file")
        fi
    done
    
    if [ ${#standalone_scripts[@]} -gt 0 ]; then
        echo "Potential standalone scripts:"
        for file in "${standalone_scripts[@]}"; do
            echo "🔧 $file"
        done
    else
        echo "No standalone scripts detected."
    fi
else
    echo "No files to analyze."
fi
</file>

<file path="tsconfig.build.json">
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "noEmit": false,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true,
        "outDir": "./dist",
        "rootDir": "./src",
        "allowImportingTsExtensions": false,
        "module": "ESNext",
        "target": "ES2022",
        "moduleResolution": "bundler",
        "resolveJsonModule": true,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "paths": {
            "@/*": ["./src/*"]
        }
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts", "src/**/__tests__/**"]
}
</file>

<file path="tsconfig.eslint.json">
{
    "extends": "./tsconfig.json",
    "include": [
        "src/**/*",
        "bin/**/*",
        "src/**/*.test.ts",
        "src/**/*.spec.ts",
        "src/**/*.integration.test.ts"
    ],
    "exclude": ["node_modules", "dist"]
}
</file>

<file path="context/agents.md">
# Agents Module

## Overview

The `src/agents` module is the core of the TENEX application, responsible for defining and managing the agents that perform tasks. It includes the logic for agent execution, lifecycle management, and the registration of built-in and custom agents.

## Key Components

- **`AgentRegistry.ts`**: A singleton class that manages the registration and lifecycle of all agents. It allows for publishing, unpublishing, and republishing agents.

- **`AgentExecutor.ts`**: The main class responsible for executing an agent's reasoning loop. It takes an agent, a conversation, and a set of tools, and then orchestrates the interaction between the LLM and the tools to accomplish a task.

- **`built-in/`**: This directory contains the definitions of the built-in agents provided by TENEX:
    - **`executor.ts`**: An agent that executes a single task.
    - **`orchestrator.ts`**: An agent that breaks down a complex task into smaller subtasks and coordinates their execution.
    - **`planner.ts`**: An agent that creates a plan for a complex task but does not execute it.
    - **`project-manager.ts`**: An agent that manages the entire lifecycle of a project, from planning to execution.

- **`execution/`**: This directory contains the core logic for the agent execution loop, including:
    - **`ReasonActLoop.ts`**: Implements the ReAct (Reason and Act) pattern for agent execution.
    - **`ToolStreamHandler.ts`**: Handles the streaming of tool outputs.
    - **`RoutingBackend.ts`**: Determines which backend (e.g., Claude, OpenAI) should be used for a given request.

- **`types.ts`**: Defines the data structures and types used throughout the agents module, such as `Agent`, `AgentExecution`, and `Tool`.
</file>

<file path="context/claude-code-integration.md">
# Claude Code Integration

## Overview

TENEX integrates Claude Code (Anthropic's code generation and execution model) through two distinct patterns, each serving different use cases and optimizing for different goals.

## Two Patterns of Claude Code Usage

### 1. ClaudeBackend Pattern (Direct Execution)

**Purpose:** Enables direct, efficient execution of Claude Code when the orchestrator determines that an entire agent turn should be handled by Claude.

**How it works:**
- Agents configured with `backend: "claude"` (e.g., Executor, Planner)
- Orchestrator routes directly to the agent
- Agent's entire execution is handled by ClaudeBackend
- No intermediate LLM call needed - the prompt passes through directly to Claude Code

**Benefits:**
- **No extra LLM calls** - Direct pass-through from orchestrator to Claude
- **No translation risk** - The original prompt is preserved exactly
- **Lower cost** - Eliminates redundant LLM invocations
- **Faster execution** - Direct path without intermediary reasoning

**Use cases:**
- When the orchestrator wants Claude to handle a complete task
- For agents whose primary purpose is Claude Code execution (Executor, Planner)
- When the entire agent turn IS the Claude Code execution

### 2. claude_code Tool Pattern (Deliberate Invocation)

**Purpose:** Allows agents using the `reason-act-loop` backend to invoke Claude Code as one step in a multi-step reasoning process.

**How it works:**
- Available as a tool in the tool registry
- **Automatically added to ALL agents using `reason-act-loop` backend** (as of latest update)
- Agents can also explicitly include `"claude_code"` in their tools array
- Agent makes an LLM call to decide when/how to use the tool
- Tool wraps ClaudeTaskOrchestrator for consistent behavior

**Benefits:**
- **Composability** - Claude Code becomes one capability among many
- **Flexibility** - Agents can combine Claude with other tools
- **Deliberate invocation** - The "extra" LLM call is intentional, part of the agent's reasoning
- **Session continuity** - Maintains claudeSessionId across invocations

**Use cases:**
- Specialist agents that need Claude for specific subtasks
- Multi-step workflows where Claude is one component
- When an agent needs to:
  1. Analyze existing code
  2. Use Claude to generate a solution
  3. Validate and integrate the result
  4. Report findings

## Implementation Details

### Shared Core: ClaudeTaskOrchestrator

Both patterns share the same underlying implementation:
- `ClaudeTaskOrchestrator` handles the actual Claude Code execution
- Manages NDKTask lifecycle for auditing and progress tracking
- Uses DelayedMessageBuffer for smooth UI updates
- Tracks execution time for metrics
- Publishes task events to Nostr

### Session Management

Both patterns support session continuity:
- `claudeSessionId` is stored in ConversationManager's agent state
- Sessions can be resumed for iterative development
- Each agent maintains its own session state

### Tool Configuration

The `claude_code` tool accepts:
- `prompt` (required): The prompt for Claude Code
- `systemPrompt` (optional): Additional context or constraints
- `title` (optional): Task title for tracking
- `branch` (optional): Git branch for the task

## When to Use Each Pattern

### Use ClaudeBackend when:
- The agent's primary purpose is Claude Code execution
- You want to minimize LLM calls and costs
- The orchestrator's instructions should pass directly to Claude
- The entire agent turn is dedicated to Claude Code

### Use claude_code Tool when:
- The agent needs Claude as part of a larger workflow
- Multiple tools need to be coordinated
- The agent needs to make decisions about when/how to use Claude
- You're building specialist agents with diverse capabilities

## Example Configurations

### Agent with ClaudeBackend
```typescript
export const EXECUTOR_AGENT = {
    name: "Executor",
    backend: "claude",  // Direct Claude execution
    // ... other configuration
};
```

### Agent with claude_code Tool (Automatic)
```typescript
export const SPECIALIST_AGENT = {
    name: "Code Reviewer",
    backend: "reason-act-loop",  // Default reasoning backend
    tools: [
        "analyze",
        "read_path",
        // claude_code is automatically added for all reason-act-loop agents
        "complete"
    ],
    // ... other configuration
};
```

### Note on Automatic Availability
As of the latest update, the `claude_code` tool is **automatically available** to all agents using the `reason-act-loop` backend. This means:
- Project Manager can use Claude Code for complex analysis
- Specialist agents can leverage Claude Code without explicit configuration
- Any dynamically hired agent with `reason-act-loop` backend gets Claude Code access
- Agents with `backend: "claude"` continue to use the direct ClaudeBackend pattern

## Architecture Benefits

This dual-pattern approach provides:
- **Efficiency** for direct Claude execution scenarios
- **Flexibility** for complex, multi-tool workflows
- **Clear separation of concerns** between execution strategies
- **Optimal cost** by avoiding unnecessary LLM calls where not needed
- **Progressive capability** - agents can be configured for either pattern based on their role
</file>

<file path="context/commands.md">
# Commands Module

## Overview

The `src/commands` module defines the command-line interface of the TENEX application. It uses the `commander` library to create a hierarchy of commands and subcommands, and it maps each command to a specific action. This module is the main entry point for users interacting with TENEX from the command line.

## Key Components

- **`tenex.ts`**: The root file of the CLI, which initializes the `commander` program and adds all the main commands.

- **`agent/`**: Contains the logic for the `agent` command and its subcommands, such as `add`, `list`, and `remove`. These commands are used to manage the agents in the system.

- **`daemon/`**: Contains the logic for the `daemon` command, which is used to start and stop the TENEX daemon process.

- **`debug/`**: Contains a set of debugging commands, such as `chat`, `conversation`, and `timeline`, which are useful for inspecting the internal state of the application.

- **`project/`**: Contains the logic for the `project` command, which is used to manage TENEX projects.

- **`setup/`**: Contains the logic for the `setup` command, which is used to configure the TENEX CLI.

- **`inventory/`**: Contains the logic for the `inventory` command, which is used to generate an inventory of the project.

- **`mcp/`**: Contains the logic for the `mcp` command, which is used to interact with the Model Context Protocol.
</file>

<file path="context/conversation_manager.md">
### Report: The TENEX Conversation Manager

This report provides a comprehensive overview of the `ConversationManager`, a critical component in the TENEX system. It covers its role in state management, context building for AI agents, data persistence, and its interaction with other parts of the application.

---

#### 1. High-Level Overview

The `ConversationManager` is the central hub for creating, managing, and persisting the state of all conversations within a project. It serves as the single source of truth for the entire lifecycle of a user's request, from the initial message to the final output.

Its primary responsibilities are:

*   **State Management:** Tracking the complete history of messages, the current phase of work, and the individual context for each participating agent.
*   **Context Building:** Preparing the specific history and instructions (the "prompt") that an AI agent needs to perform its task.
*   **Persistence:** Saving conversations to the filesystem so that state is not lost between application restarts.
*   **System Interaction:** Serving as the interface between Nostr events, agent logic, and the persistence layer.

---

#### 2. State Management: The `Conversation` Object

The core of the manager's state is the `Conversation` object. Each conversation is an instance of this object, held in an in-memory `Map`. Here’s a breakdown of its key properties:

*   **`id`**: A unique identifier for the conversation, derived from the ID of the initial Nostr event.
*   **`title`**: A human-readable title for the conversation.
*   **`history`**: This is the **single source of truth** for a conversation. It is an ordered array of `NDKEvent` objects representing every message from the user and all participating agents.
*   **`phase`**: The current stage of the conversation (e.g., `chat`, `plan`, `execute`). The manager controls phase transitions via the `updatePhase` method.
*   **`agentStates`**: This is a `Map` that is crucial for multi-agent context management. It maps an agent's slug (e.g., "project-manager") to its `AgentState`, which contains details like the last message the agent has processed.
*   **`phaseTransitions`**: A detailed log of every phase change, providing a rich audit trail.
*   **`executionTime`**: An object that tracks the cumulative time agents spend actively working on the conversation.

---

#### 3. Context Building for Agents

The most complex and vital function of the `ConversationManager` is building the message history for an agent. This process ensures that each agent receives a tailored, complete, and coherent history, enabling it to act with full awareness of the conversation's flow.

The process involves:

1.  **Identifying the Agent's State**: It retrieves the agent's `AgentState` to determine which messages it has already seen.
2.  **Building Historical Context**: It formats past messages differently based on the sender (the agent's own messages, user messages, or other agents' messages).
3.  **Providing "Messages While You Were Away"**: If there are new messages since the agent was last active, the manager creates a special summary block.
4.  **Injecting Phase Instructions**: A message is added to inform the agent of the current `PHASE` of the conversation and its goals.
5.  **Adding the Triggering Event**: The final message in the context is the specific event that triggered this action.
6.  **Updating State**: After building the context, the manager updates the agent's state to ensure it doesn't see the same messages again.

---

#### 4. Persistence via `FileSystemAdapter`

The `ConversationManager` ensures that no data is lost by using a persistence adapter. The default implementation is the `FileSystemAdapter`.

*   **Location**: It stores all data within the project's `.tenex/conversations/` directory.
*   **Serialization**: When a conversation is saved, the `Conversation` object is serialized into a JSON file. This process involves converting maps to objects and `NDKEvent`s to strings.
*   **Loading**: When the application starts, the adapter reads the JSON files, validates them, and reconstructs the full `Conversation` objects in memory.
*   **Metadata**: To speed up the listing of conversations, a central `metadata.json` file is maintained with a lightweight summary of each conversation.
*   **Archiving**: The adapter also supports archiving and restoring conversations.

---

#### 5. Interactions with Other Systems

The `ConversationManager` is deeply integrated with other parts of the TENEX system:

*   **Nostr**: It is fundamentally event-driven, creating and updating conversations based on `NDKEvent`s. It can also fetch and inline the content of `nostr:` URIs found in messages, enriching the context for agents.
*   **Agents**: It relies on the `ProjectContext` to get a list of all available agents and their properties.
*   **Orchestrator Agent**: It has a special method to build a structured summary of the conversation's history for the orchestrator, which helps it make routing decisions.
*   **Execution Queue**: It is designed to work with an `ExecutionQueueManager` to handle concurrent operations and ensure safe access to shared resources like the filesystem.
</file>

<file path="context/execution-queue-mutex-system.md">
# Specification: Execution Queue Mutex System

## 1. Summary

This document specifies a mutex system to manage access to the `EXECUTE` phase within a TENEX project. The goal is to prevent multiple conversations from entering the `EXECUTE` phase concurrently for the same project, which can lead to resource conflicts and unpredictable behavior. The system uses a FIFO (First-In, First-Out) queue to serialize execution requests.

## 2. Problem Statement

When multiple users or automated processes interact with the same TENEX project, there is a risk of them initiating `EXECUTE` phases simultaneously. This can cause race conditions, inconsistent state, and corrupted project files. A locking mechanism is required to ensure that only one conversation can be in the `EXECUTE` phase at any given time for a single project.

## 3. Functional Requirements

### 3.1. Mutex and Locking

*   **Exclusive Access:** Only one conversation per project can hold the execution lock and be in the `EXECUTE` phase at a time.
*   **Lock Acquisition:** A conversation automatically attempts to acquire the lock when it transitions into the `EXECUTE` phase.
*   **Natural Lock Release:** The lock is automatically released when the active conversation transitions out of the `EXECUTE` phase (e.g., to `VERIFICATION`, `CHORES`, or `END`).

### 3.2. Queuing Mechanism

*   **FIFO Queue:** If a conversation attempts to enter the `EXECUTE` phase while the lock is held by another conversation, it shall be placed in a queue.
*   **Automatic Dequeue:** When the lock is released, the conversation at the front of the queue automatically acquires the lock and proceeds with its execution.
*   **Queue Transparency:** Users should be able to view the current queue, their position in it, and an estimated wait time.

### 3.3. Timeout and Recovery

*   **Execution Timeout:** A lock has a configurable timeout period (default: 30 minutes) to prevent indefinite blocking.
*   **Timeout Warning:** A warning is issued 5 minutes before the lock expires.
*   **Automatic Release on Timeout:** If the execution is not completed within the timeout period, the lock is automatically released to unblock the queue.

### 3.4. Manual Override

*   **Force Release:** A mechanism must exist for a project administrator to manually force the release of a lock. This is a safety hatch for situations where a process might be stuck.

## 4. Nostr Integration

The system leverages Nostr events for status broadcasting and coordination.

*   **Kind 24010 (Project Status):** This event is enhanced to broadcast the state of the execution queue using a pure tag-based system, avoiding JSON in the `.content` field as a best practice. The queue's state is represented by the order and structure of `execution-queue` tags.
    *   **Tag Order:** The order of the `execution-queue` tags represents the FIFO queue order. The first tag is the active conversation, the second is the next in line, and so on.
    *   **Active Conversation:** The conversation currently holding the lock is denoted by the tag: `["execution-queue", "<conversation-id>", "active"]`.
    *   **Waiting Conversations:** Conversations waiting in the queue are denoted by the tag: `["execution-queue", "<conversation-id>"]`.
*   **Kind 24019 (Force Release):** A new event kind to signal a force release.
    *   An `a` tag pointing to the `project_id` will be used to target the correct project.
    *   Publishing this event triggers the immediate release of the execution lock for the specified project.

## 5. Technical Implementation Overview

The system is implemented through a set of cooperating classes:

*   **`ExecutionQueueManager`**: The central orchestrator that integrates the other components.
*   **`LockManager`**: Manages the acquisition, release, and state of the execution lock, with persistence.
*   **`QueueManager`**: Manages the conversation queue with FIFO logic.
*   **`TimeoutManager`**: Handles the execution timeout logic, including warnings.
*   **`ExecutionEventPublisher`**: Broadcasts the queue status via Nostr events.
*   **`NostrEventService`**: A general service for signing and publishing Nostr events.

## 6. CLI Commands

The following CLI commands are provided for interacting with the Execution Queue:

*   `tenex queue status`: View the current lock holder and the list of conversations in the queue.
*   `tenex queue release`: Manually force the release of the current execution lock.
*   `tenex queue remove <conversationId>`: Remove a specific conversation from the queue.
*   `tenex queue history`: View a history of past executions.
*   `tenex queue clear`: Clear all state from the queue (lock and waiting conversations).

## 7. Known Issues and Resolutions

### `ProjectContext not initialized`

*   **Symptom:** During initial verification, running any `tenex queue` command resulted in a fatal `ProjectContext not initialized` error.
*   **Root Cause:** The CLI command handlers were being executed without the necessary project context (including services like `ConversationManager` and `ExecutionQueueManager`) being loaded and initialized first.
*   **Resolution:**
    1.  A function `ensureProjectInitialized()` was created to handle the loading and initialization of the project context.
    2.  This function is now called at the beginning of every `tenex queue` command action to guarantee the context is available before the command logic runs.
    3.  The `ProjectManager` was updated to automatically create and attach the `ConversationManager` and `ExecutionQueueManager` when the project context is loaded.
</file>

<file path="context/INVENTORY.md">
# TENEX Project Inventory

## 1. Project Overview

**Description:** TENEX is a command-line interface (CLI) application that provides a suite of tools for developers. It appears to be extensible, with a system of agents that can be managed and interacted with. The CLI also includes features for debugging, project setup, and interacting with the Nostr protocol.

**Technologies:**
- **Language:** TypeScript
- **Runtime:** Bun
- **Key Libraries:**
    - `commander`: For creating the command-line interface.
    - `@nostr-dev-kit/ndk`: For Nostr protocol integration.
    - `multi-llm-ts`: Suggests integration with multiple Large Language Models (LLMs).
    - `zod`: For data validation.

**Architecture:** The project follows a modular, command-based architecture. Each command is defined in its own module, and the main `tenex.ts` file acts as the entry point that registers all the commands. There is a clear separation of concerns, with distinct modules for agents, commands, services, and utilities.

## 2. Directory Structure

- **`src/`**: The main source code directory.
    - **`agents/`**: Contains the logic for different agents that can be used within the TENEX CLI. This is likely where the core business logic of the application resides.
    - **`claude/`**: Specific integrations with Claude models.
    - **`commands/`**: Defines the commands available in the CLI (e.g., `agent`, `daemon`, `project`).
    - **`conversations/`**: Manages the state and flow of conversations with agents.
    - **`daemon/`**: Likely contains code related to running TENEX as a background process.
    - **`event-handler/`**: Handles various events within the application.
    - **`events/`**: Defines different event types.
    - **`lib/`**: Contains utility libraries, such as file system and shell helpers.
        - **`fs/`**: Provides file system utilities, including a custom file system implementation.
        - **`shell.ts`**: Offers shell command execution functionality.
    - **`llm/`**: Manages interactions with Large Language Models (LLMs).
    - **`logging/`**: Provides logging functionality.
        - **`ExecutionLogger.ts`**: A specific logger for tracking agent execution.
    - **`nostr/`**: Handles integration with the Nostr protocol.
    - **`prompts/`**: Stores and builds prompts for interacting with LLMs.
        - **`core/`**: Core components for building prompts, including a `PromptBuilder` and a `FragmentRegistry`.
        - **`fragments/`**: A collection of prompt fragments that can be reused across different prompts.
        - **`utils/`**: Utilities for working with prompts, such as a `messageBuilder` and a `systemPromptBuilder`.
    - **`services/`**: Contains services that provide specific functionalities.
        - **`ConfigService.ts`**: Manages the application's configuration.
        - **`mcp/`**: Contains services related to the Model Context Protocol (MCP).
        - **`ProjectContext.ts`**: Manages the context of the current project.
    - **`test-utils/`**: Provides utilities for testing.
    - **`tools/`**: Defines tools that can be used by agents.
        - **`core.ts`**: Core functionality for defining and executing tools.
        - **`implementations/`**: The actual implementations of the tools, such as `analyze`, `complete`, `shell`, and `writeContextFile`.
        - **`registry.ts`**: A registry for all available tools.
    - **`tracing/`**: Implements tracing for monitoring and debugging.
    - **`utils/`**: Contains miscellaneous utility functions.
        - **`agentFetcher.ts`**: Fetches agent definitions.
        - **`conversationFetcher.ts`**: Fetches conversation data.
        - **`error-handler.ts`**: Provides centralized error handling.
        - **`git/`**: Git-related utilities.
        - **`inventory.ts`**: Utilities for generating project inventories.
- **`tests/`**: Contains end-to-end tests.

## 3. Significant Files

- **`src/tenex.ts`**: The main entry point of the CLI application. It initializes the `commander` program and registers all the available commands.
- **`package.json`**: Defines project metadata, dependencies, and scripts.
- **`src/agents/AgentRegistry.ts`**: Manages the registration and publishing of agents.
- **`src/commands/agent/index.ts`**: The entry point for the `agent` command and its subcommands.
- **`src/llm/router.ts`**: Likely responsible for routing requests to different LLMs.
- **`src/nostr/ndkClient.ts`**: Initializes and configures the Nostr client.

## 4. Architectural Insights

- **Command-Based Architecture:** The application is structured around a set of commands, each with a specific responsibility. This makes the CLI easy to extend and maintain.
- **Agent-Based System:** The concept of "agents" is central to the application. These agents appear to be autonomous or semi-autonomous entities that can perform tasks.
- **LLM Integration:** The use of `multi-llm-ts` suggests that the application can interact with various LLMs, and the `src/llm` directory confirms this.
- **Nostr Protocol:** The integration with the Nostr protocol suggests that the application may be used for decentralized communication or data exchange.
- **Event-Driven:** The presence of `src/events` and `src/event-handler` directories suggests an event-driven architecture, where different parts of the application communicate through events.

## 5. High-Complexity Modules

The following modules are identified as potentially complex due to their central role and the nature of the functionality they provide:

- **`src/agents`**: The core logic of the agents, their execution, and lifecycle management. See [context/agents.md](context/agents.md) for a detailed explanation.
- **`src/llm`**: The abstraction layer for interacting with multiple LLMs, including routing, configuration, and tool usage. See [context/llm.md](context/llm.md) for a detailed explanation.
- **`src/nostr`**: The implementation of the Nostr protocol, including client management, event publishing, and task handling. See [context/nostr.md](context/nostr.md) for a detailed explanation.
- **`src/commands`**: The command definitions and their interactions with the rest of the system. See [context/commands.md](context/commands.md) for a detailed explanation.
- **`src/conversations`**: The management of conversation state, persistence, and synchronization. See [context/conversations.md](context/conversations.md) for a detailed explanation.
</file>

<file path="context/llm.md">
# LLM Module

## Overview

The `src/llm` module provides an abstraction layer for interacting with various Large Language Models (LLMs). It handles model selection, configuration, and the routing of requests to the appropriate LLM backend. This module is essential for the agent execution loop, as it provides the interface for the agents to communicate with the LLMs.

## Key Components

- **`router.ts`**: The central component of the LLM module. It contains the logic for selecting the best LLM for a given task based on the provided criteria, such as the required capabilities (e.g., tool use, code generation) and the user's preferences.

- **`models.ts`**: Defines the supported LLM models and their capabilities. This file is used by the `router.ts` to make decisions about which model to use.

- **`selection/`**: This directory contains the logic for the LLM selection process, including the `ModelSelector` class, which implements the model selection algorithm.

- **`ui/`**: This directory contains the user interface components for managing LLM configurations.

- **`types.ts`**: Defines the data structures and types used throughout the LLM module, such as `LLMConfig`, `Model`, and `ModelCapabilities`.
</file>

<file path="context/metadata-preservation-debug-logging.md">
# LLM Metadata Preservation Debug Logging

## Overview
Comprehensive debug logging has been added throughout the metadata preservation flow to track how LLM metadata is handled when tools (especially `complete()`) are used.

## Debug Log Points

### 1. **handleAgentCompletion** (`completionHandler.ts`)
- **Location**: When creating unpublished event
- **Logs**: 
  - `[handleAgentCompletion] Created unpublished event`
  - Shows: agent name, response length, event ID, tags

### 2. **complete() tool** (`complete.ts`)
- **Location**: When serializing event for deferred publishing
- **Logs**:
  - `[complete() tool] Serializing event for deferred publishing`
  - Shows: agent name, event ID, serialized event keys, content length, tag count

### 3. **ToolStreamHandler** (`ToolStreamHandler.ts`)
- **Location**: When storing serialized event
- **Logs**:
  - `[ToolStreamHandler] Stored serialized event for deferred publishing`
  - `[ToolStreamHandler] Complete tool has no serialized event` (if missing)
  - Shows: presence of serialized event, event keys, content length

### 4. **StreamStateManager** (`StreamStateManager.ts`)
- **Location**: When storing/retrieving deferred events
- **Logs**:
  - `[StreamStateManager] Stored deferred event`
  - `[StreamStateManager] Retrieved deferred event`
  - Shows: event presence, content length, tag count, event keys

### 5. **ReasonActLoop** (`ReasonActLoop.ts`)
- **Location**: Multiple points in the flow
- **Logs**:
  - `[ReasonActLoop] Terminal tool detected, continuing to wait for metadata`
    - Shows when not returning early on terminal tools
  - `[ReasonActLoop] Received 'done' event`
    - Shows: model, usage data, tokens, cost
  - `[ReasonActLoop] Processing deferred event`
    - Shows: serialized event keys, content length
  - `[ReasonActLoop] Adding metadata to deferred event`
    - Shows: model, cost, tokens, prompts presence
  - `[ReasonActLoop] ✅ Published deferred complete() event with metadata`
    - Shows: successful publication with all metadata
  - `[ReasonActLoop] Have deferred event but no publisher` (warning)
  - `[ReasonActLoop] No deferred event to publish` (debug)

### 6. **NostrPublisher** (`NostrPublisher.ts`)
- **Location**: When adding LLM metadata to events
- **Logs**:
  - `[NostrPublisher] Adding LLM metadata to event`
    - Shows: all metadata fields being added
  - `[NostrPublisher] ✅ Metadata tags added`
    - Shows: total tags, metadata tag count
  - `[NostrPublisher] No metadata to add` (if none)

### 7. **ClaudeBackend** (`ClaudeBackend.ts`)
- **Location**: Throughout the Claude execution flow
- **Logs**:
  - `[ClaudeBackend] Getting unpublished event from handleAgentCompletion`
  - `[ClaudeBackend] Adding Claude metadata to event`
    - Shows: model, cost, prompt lengths
  - `[ClaudeBackend] ✅ Published completion with metadata`
    - Shows: event ID, cost, message count, duration, session ID

## Log Flow Example

When a complete() tool is used, you'll see this sequence in the logs:

1. `[handleAgentCompletion] Created unpublished event`
2. `[complete() tool] Serializing event for deferred publishing`
3. `[ToolStreamHandler] Stored serialized event for deferred publishing`
4. `[StreamStateManager] Stored deferred event`
5. `[ReasonActLoop] Terminal tool detected, continuing to wait for metadata`
6. `[ReasonActLoop] Received 'done' event` (with usage data)
7. `[StreamStateManager] Retrieved deferred event`
8. `[ReasonActLoop] Processing deferred event`
9. `[ReasonActLoop] Adding metadata to deferred event`
10. `[NostrPublisher] Adding LLM metadata to event`
11. `[NostrPublisher] ✅ Metadata tags added`
12. `[ReasonActLoop] ✅ Published deferred complete() event with metadata`

## Key Indicators

### Success Indicators
- ✅ emoji in logs indicates successful operations
- Presence of cost, tokens, and model information in final publication

### Warning Signs
- `Have deferred event but no publisher` - indicates a configuration issue
- `Complete tool has no serialized event` - indicates the tool didn't serialize properly

### Debug Information
- All logs include relevant context like agent names, event IDs, and data sizes
- Token counts and costs are logged when available
- System/user prompts presence is indicated without logging full content (for privacy)

## Usage

To see these logs in action:
1. Run TENEX with debug logging enabled
2. Watch for `[component]` prefixed messages
3. Follow the flow from event creation to publication
4. Check for ✅ markers indicating successful metadata preservation

## Troubleshooting

If metadata is missing:
1. Check for `[ReasonActLoop] Terminal tool detected` - confirms detection
2. Look for `[ReasonActLoop] Received 'done' event` - confirms metadata arrived
3. Verify `[NostrPublisher] Adding LLM metadata` - confirms metadata was added
4. Confirm `✅ Published deferred complete() event` - confirms successful publication
</file>

<file path="context/nostr.md">
# Nostr Module

## Overview

The `src/nostr` module is responsible for all interactions with the Nostr protocol. This includes managing the Nostr client, publishing events, and handling tasks received from the Nostr network. This module is key to the decentralized and collaborative capabilities of TENEX.

## Key Components

- **`ndkClient.ts`**: Initializes and manages the Nostr Development Kit (NDK) client. It handles the connection to Nostr relays and provides a high-level API for interacting with the Nostr network.

- **`NostrPublisher.ts`**: A class that simplifies the process of publishing events to the Nostr network. It handles the creation and signing of events, and ensures that they are sent to the appropriate relays.

- **`TaskPublisher.ts`**: A specialized publisher for tasks. It publishes tasks to the Nostr network and allows other clients to subscribe to them.

- **`TypingIndicatorManager.ts`**: Manages the sending and receiving of typing indicators over the Nostr network, providing real-time feedback to users during conversations.

- **`factory.ts`**: A factory for creating different types of Nostr events.

- **`types.ts`**: Defines the data structures and types used throughout the Nostr module, such as `NostrEvent`, `NostrTag`, and `NostrProfile`.
</file>

<file path="context/standalone-agents-plan.md">
# Plan for Project-Independent Agent Conversations

This document outlines a comprehensive plan for enabling agent conversations outside of project contexts in TENEX. This will allow for standalone agent functionality, such as trying out agents before installing them and interacting with global agents.

## Phased Implementation

The implementation is broken down into four phases to deliver value incrementally and reduce risk.

### Phase 1: Core Infrastructure Changes

This phase focuses on laying the groundwork for standalone agent conversations by creating parallel infrastructure that doesn't interfere with existing project-based workflows.

*   **Key components:**
    *   `StandaloneConversationManager`: A new manager for conversations that are not associated with a project.
    *   `StandaloneAgentResolver`: A resolver for finding and instantiating agents that are not part of a project. (Note: A `StandaloneAgentResolver` already exists in the codebase, so this task will involve reviewing and potentially adapting it.)
*   **Persistence:**
    *   Initially, conversations will be stored in-memory only to simplify the initial implementation.
    *   Later, a persistence layer can be added (e.g., using a local database or Nostr events).

### Phase 2: New CLI Commands

This phase will introduce new CLI commands to allow users to interact with standalone agents.

*   **Commands:**
    *   `tenex agent chat <agent_id>`: Start a conversation with a global agent.
    *   `tenex agent try <agent_definition_id>`: Start a temporary conversation with a new instance of an agent from a definition.
*   **Implementation details:**
    *   These commands will use the new `StandaloneConversationManager` and `StandaloneAgentResolver`.

### Phase 3: Standalone Agent Execution Model

This phase will implement the execution model for standalone agents, enabling them to respond to user messages.

*   **Execution flow:**
    *   User messages will be sent directly to the agent's pubkey using NDK subscriptions.
    *   This bypasses the project-based orchestrator routing.
*   **Agent capabilities:**
    *   Agents will be able to operate in both project and standalone modes.
    *   This will be achieved through progressive enhancement, where agents have a baseline of functionality in standalone mode and enhanced capabilities when in a project context.

### Phase 4: Enhanced Features and Marketplace Integration

This phase will add advanced features and integrate with the agent marketplace.

*   **Features:**
    *   **Global Agent Registry:** A central registry for all available global agents.
    *   **Nostr Discovery:** The ability to discover and interact with agents from the Nostr network.
*   **Marketplace integration:**
    *   This will allow users to easily find, try, and install agents from a marketplace.

## Guiding Principles

*   **Reusability:** Leverage existing components whenever possible to reduce development time and complexity.
*   **Simplicity:** Start with simple solutions (e.g., in-memory persistence) and add complexity as needed.
</file>

<file path="src/agents/built-in/executor.ts">
import type { BuiltInAgentDefinition } from "../builtInAgents";
</file>

<file path="src/agents/execution/__tests__/AgentExecutor-simple.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { AgentExecutor } from "../AgentExecutor";
import type { AgentInstance } from "@/agents/types";
⋮----
// Create mock agent
⋮----
// Mock the backend modules
⋮----
// Access private method via prototype
⋮----
// Mock the backend modules
⋮----
// Access private method via prototype
⋮----
// Mock the backend modules
⋮----
// Access private method via prototype
</file>

<file path="src/agents/execution/__tests__/completionHandler.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { handleAgentCompletion } from "../completionHandler";
import type { NostrPublisher } from "@/nostr/NostrPublisher";
import type { AgentInstance } from "@/agents/types";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Reset mocks
⋮----
// Setup mock orchestrator agent
⋮----
// Mock ProjectContext
⋮----
// Mock logger
⋮----
// Setup mock publisher
⋮----
// Setup mock agent
⋮----
// Verify the result
⋮----
// Verify publishResponse was called correctly
⋮----
// Verify the result uses the custom summary
⋮----
// Verify publishResponse was called with custom summary
⋮----
// Verify it retrieved the orchestrator
⋮----
// Verify it published to orchestrator's pubkey
⋮----
// The triggering event is passed but not used in the current implementation
// This test ensures it doesn't break when provided
⋮----
// Make publisher throw an error
⋮----
// The function should throw the error up
⋮----
// Should still work with empty response
⋮----
const response = "A".repeat(10000); // Very long response
⋮----
// Should handle long responses without truncation
⋮----
// Verify the exact structure of completeMetadata
</file>

<file path="src/agents/execution/__tests__/ReasonActLoop.errorRecovery.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { ReasonActLoop } from "../ReasonActLoop";
import type { LLMService, StreamEvent } from "@/llm/types";
import { serializeToolResult } from "@/llm/ToolResult";
import type { ToolError } from "@/tools/core";
import { formatToolError } from "@/utils/error-formatter";
⋮----
// Reset mocks
⋮----
// Create mocks
⋮----
// Use reflection to access private method
⋮----
// Simulate a tool_complete event with a complex error
⋮----
// Verify publishError was called with the formatted error
⋮----
// Test system error
⋮----
// Reset mock
⋮----
// Test complex error object
⋮----
// Should not throw even if publisher fails
⋮----
// Verify error was logged
⋮----
field: "unknown", // Field is not serialized, so it becomes "unknown"
⋮----
// Test with null result
⋮----
// parseToolResult is called synchronously from handleToolCompleteEvent
// and should throw immediately
⋮----
// Test with missing __typedResult
⋮----
// Test non-orchestrator agent
⋮----
// Reset
⋮----
// Test orchestrator agent (should not add to stream)
⋮----
// Using the shared formatToolError utility directly
⋮----
// Test string error
⋮----
// Test error with message
⋮----
// Test validation error
⋮----
// Test execution error
⋮----
// Test unparseable object
⋮----
// Test other types
</file>

<file path="src/agents/execution/__tests__/ReasonActLoop.toolError.test.ts">
import { describe, it, expect, mock } from "bun:test";
import type { NostrPublisher } from "@/nostr/NostrPublisher";
import { createTracingLogger } from "@/tracing";
import { ReasonActLoop } from "../ReasonActLoop";
import { serializeToolResult } from "@/llm/ToolResult";
⋮----
// Use reflection to access private method
⋮----
// Simulate a tool_complete event with an error
⋮----
// Verify publishError was called with the correct error message
⋮----
// Use reflection to access private method
⋮----
// Simulate a tool_complete event with success
⋮----
// Verify publishError was NOT called
</file>

<file path="src/agents/execution/__tests__/StreamStateManager.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { StreamStateManager } from "../StreamStateManager";
</file>

<file path="src/agents/execution/constants.ts">
/**
 * Configuration constants for agent execution
 */
⋮----
/** Delay in milliseconds after publishing typing indicator */
⋮----
/** Default duration for tool execution when not tracked */
⋮----
/** Default timeout for shell commands in milliseconds (30 seconds) */
⋮----
/** Threshold for considering a phase transition as recent in milliseconds (30 seconds) */
</file>

<file path="src/agents/execution/types.ts">
import type { AgentInstance } from "@/agents/types";
import type { Phase } from "@/conversations/phases";
import type { PhaseTransition } from "@/conversations/types";
import type { ToolExecutionResult } from "@/tools/types";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { NostrPublisher } from "@/nostr/NostrPublisher";
import type { ConversationManager } from "@/conversations/ConversationManager";
import type { AgentExecutor } from "@/agents/execution/AgentExecutor";
import type { TracingContext } from "@/tracing";
⋮----
export interface ExecutionContext {
    agent: AgentInstance;
    conversationId: string;
    phase: Phase;
    projectPath: string;
    triggeringEvent: NDKEvent;
    publisher: NostrPublisher;
    conversationManager: ConversationManager;
    previousPhase?: Phase;
    handoff?: PhaseTransition;
    claudeSessionId?: string;
    agentExecutor?: AgentExecutor;
    tracingContext?: TracingContext;
}
⋮----
export interface AgentExecutionResult {
    success: boolean;
    response?: string;
    toolExecutions?: ToolExecutionResult[];
    error?: string;
}
</file>

<file path="src/agents/builtInAgents.ts">
import { DEFAULT_AGENT_LLM_CONFIG } from "@/llm/constants";
import { EXECUTOR_AGENT } from "./built-in/executor";
import { PLANNER_AGENT } from "./built-in/planner";
import { PROJECT_MANAGER_AGENT_DEFINITION } from "./built-in/project-manager";
⋮----
export interface BuiltInAgentDefinition {
    name: string;
    slug: string;
    role: string;
    instructions: string;
    llmConfig?: string;
    useCriteria?: string;
    tools?: string[];
}
⋮----
export function getBuiltInAgents(): BuiltInAgentDefinition[]
</file>

<file path="src/claude/DelayedMessageBuffer.ts">
import { logger } from "@/utils/logger";
⋮----
export interface BufferedMessage {
    content: string;
    sessionId?: string;
    timestamp: number;
}
⋮----
export interface DelayedMessageBufferOptions {
    delayMs?: number;
    onFlush: (message: BufferedMessage) => Promise<void>;
}
⋮----
/**
 * Buffers messages with a delay to allow consuming them before publishing
 * Single Responsibility: Manage delayed message publishing with timeout
 */
export class DelayedMessageBuffer
⋮----
constructor(options: DelayedMessageBufferOptions)
⋮----
/**
     * Add a message to the buffer with automatic flush after delay
     */
async buffer(content: string, sessionId?: string): Promise<void>
⋮----
// Clear any existing timeout
⋮----
// Store the new message
⋮----
// Set timeout to flush if not consumed
⋮----
/**
     * Consume the buffered message without publishing
     * Used when task completes within the delay window
     */
consume(): BufferedMessage | null
⋮----
/**
     * Flush the buffered message immediately
     * Called on timeout or explicit flush
     */
async flush(): Promise<void>
⋮----
/**
     * Check if there's a pending message
     */
hasPending(): boolean
⋮----
/**
     * Clean up any pending timeouts
     */
cleanup(): void
</file>

<file path="src/commands/debug/__tests__/utils.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { debugLog, debugError, debugInfo, debugSection, debugPrompt } from "../utils";
import chalk from "chalk";
⋮----
// Save original console methods
⋮----
// Reset tracking arrays
⋮----
// Mock console methods
⋮----
// Clear environment variables
⋮----
// Restore original methods
⋮----
// In debug mode, it would use logDebug which has specific formatting
expect(consoleLogs).toHaveLength(0); // No direct console.log in debug mode
</file>

<file path="src/commands/debug/claudeCode.ts">
/* eslint-disable no-console */
import { ClaudeCodeExecutor, type ClaudeCodeResult } from "@/claude/executor";
import type { SDKMessage } from "@anthropic-ai/claude-code";
import type { TextBlock } from "@anthropic-ai/sdk/resources/messages/messages";
import { formatAnyError } from "@/utils/error-formatter";
import { logError, logInfo, logDebug } from "@/utils/logger";
import chalk from "chalk";
import { colorizeJSON } from "@/utils/formatting";
⋮----
interface DebugClaudeCodeOptions {
    timeout?: number;
}
⋮----
export async function runDebugClaudeCode(
    prompt: string,
    options: DebugClaudeCodeOptions
): Promise<void>
⋮----
// Create executor with options
⋮----
// Track message types for summary
⋮----
// Execute and stream messages
⋮----
// Create the generator
⋮----
// Process messages using the same pattern as ClaudeTaskOrchestrator
⋮----
// The value is the final ClaudeCodeResult
⋮----
// value is an SDKMessage
⋮----
// Track message type counts
⋮----
// Display message based on type
⋮----
// Track last assistant message for summary
⋮----
// Display execution summary
⋮----
// Display message type breakdown
⋮----
// Display last assistant message if available
⋮----
/**
 * Display an SDK message with appropriate formatting
 */
function displaySDKMessage(message: SDKMessage): void
⋮----
// Truncate very long results
⋮----
// Log unknown message types for debugging
⋮----
console.log(); // Empty line for readability
</file>

<file path="src/commands/debug/conversation.ts">
import { getNDK } from "@/nostr/ndkClient";
import { fetchConversation } from "@/utils/conversationFetcher";
import { formatAnyError } from "@/utils/error-formatter";
import { logError, logInfo } from "@/utils/logger";
import { ensureProjectInitialized } from "@/utils/projectInitialization";
import { debugLog, debugError } from "./utils";
⋮----
export async function runDebugConversation(nevent: string): Promise<void>
⋮----
// Initialize project context
⋮----
// Get NDK instance
⋮----
// Fetch and format conversation
⋮----
// Display the conversation
</file>

<file path="src/commands/mcp/index.ts">
import { Command } from "commander";
import { addCommand } from "./add";
import { listCommand } from "./list";
import { removeCommand } from "./remove";
import { serverCommand } from "./server";
</file>

<file path="src/commands/mcp/remove.ts">
import { configService } from "@/services/ConfigService";
import { logger } from "@/utils/logger";
import { handleCliError } from "@/utils/cli-error";
import { confirm } from "@inquirer/prompts";
import { Command } from "commander";
⋮----
interface RemoveOptions {
    project?: boolean;
    global?: boolean;
    force?: boolean;
}
⋮----
// Determine where to remove from
⋮----
// Default: try project first if in one, otherwise global
⋮----
// Load existing MCP config
⋮----
// Check if server exists
⋮----
// If we defaulted to project, suggest checking global
⋮----
// Confirm deletion unless --force is used
⋮----
// Remove the server
⋮----
// Save updated config
</file>

<file path="src/commands/queue/clear.ts">
import { getProjectContext } from '@/services';
import { ensureProjectInitialized } from '@/utils/projectInitialization';
import { logger } from '@/utils/logger';
import chalk from 'chalk';
import inquirer from 'inquirer';
⋮----
interface ClearOptions {
  confirm?: boolean;
}
⋮----
export async function clearQueueState(options: ClearOptions =
⋮----
// Initialize project context first
⋮----
// Get current status to show what will be cleared
⋮----
// Confirm the clear operation unless --confirm flag is provided
⋮----
// Clear all state
</file>

<file path="src/commands/queue/index.ts">
import { Command } from 'commander';
import { showQueueStatus } from './status';
import { releaseExecutionLock } from './release';
import { removeFromQueue } from './remove';
import { showExecutionHistory } from './history';
⋮----
// Queue status command
⋮----
// Force release command
⋮----
// Remove from queue command
⋮----
// Execution history command
⋮----
// Clear all command (admin only)
</file>

<file path="src/commands/queue/status.ts">
import { ExecutionQueueManager } from '@/conversations/executionQueue';
import { getProjectContext } from '@/services';
import { ensureProjectInitialized } from '@/utils/projectInitialization';
import { logger } from '@/utils/logger';
import chalk from 'chalk';
import { formatDistanceToNow } from 'date-fns';
⋮----
interface StatusOptions {
  detailed?: boolean;
  json?: boolean;
  watch?: boolean;
}
⋮----
export async function showQueueStatus(options: StatusOptions =
⋮----
// Initialize project context first
⋮----
// Exit cleanly after displaying status
⋮----
function displayQueueStatus(status: any, detailed?: boolean): void
⋮----
// Display lock status
⋮----
// Display queue information
⋮----
// Display active timeouts if detailed
⋮----
async function watchQueueStatus(queueManager: ExecutionQueueManager): Promise<void>
⋮----
const displayCurrentStatus = async () =>
⋮----
// Display initial status
⋮----
// Set up event listeners
⋮----
// Also poll periodically as backup
⋮----
}, 30000); // Every 30 seconds
⋮----
// Handle graceful shutdown
</file>

<file path="src/commands/run/__tests__/SubscriptionManager.test.ts">
import { describe, it, expect, mock, beforeEach, afterEach } from "bun:test";
import { SubscriptionManager } from "../SubscriptionManager";
import type { EventHandler } from "@/event-handler";
import { EVENT_KINDS } from "@/llm/types";
⋮----
// Mock NDK types
⋮----
// Mock project context
⋮----
// Mock event tracking
⋮----
// Mock NDKAgentLesson
⋮----
// Mock filterAndRelaySetFromBech32
⋮----
// Create mock event handler
⋮----
// Clear all mocks
⋮----
// Cleanup subscriptions
⋮----
// Should create subscription for project updates
⋮----
// Should create subscription for agent lessons
⋮----
// Should create subscription for text notes
⋮----
// Each subscription should be started
⋮----
// Should have stopped all subscriptions
⋮----
// Find the project update subscription
⋮----
// Simulate receiving a project update event
⋮----
// Should mark event as processed
⋮----
// Find event handler
⋮----
// Should not process the event
⋮----
// Find the text note subscription handler
⋮----
// Should process the text note
⋮----
// Find event handler
⋮----
kind: 99999, // Unknown kind
⋮----
// Should call unknown event handler
⋮----
// Should not throw
⋮----
// Should not throw
</file>

<file path="src/commands/run/processedEventTracking.ts">
import { existsSync } from "node:fs";
import { mkdir, readFile, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { logger } from "@/utils/logger";
⋮----
// State management
⋮----
const SAVE_DEBOUNCE_MS = 1000; // Save at most once per second
⋮----
function getStorePath(projectPath: string): string
⋮----
async function ensureTenexDirectory(storePath: string): Promise<void>
⋮----
/**
 * Load processed event IDs from disk storage
 * @param projectPath - The path to the project directory
 */
export async function loadProcessedEvents(projectPath: string): Promise<void>
⋮----
// Ensure .tenex directory exists
⋮----
// Load existing processed event IDs if file exists
⋮----
// Continue with empty set on error
⋮----
/**
 * Check if an event has already been processed
 * @param eventId - The ID of the event to check
 * @returns True if the event has been processed, false otherwise
 */
export function hasProcessedEvent(eventId: string): boolean
⋮----
/**
 * Add an event ID to the processed set and schedule a save
 * @param projectPath - The path to the project directory
 * @param eventId - The ID of the event to mark as processed
 */
export function addProcessedEvent(projectPath: string, eventId: string): void
⋮----
function debouncedSave(projectPath: string): void
⋮----
// Clear existing timeout
⋮----
// Set new timeout
⋮----
async function saveProcessedEvents(projectPath: string): Promise<void>
⋮----
// Ensure directory exists before saving
⋮----
// Convert Set to Array for JSON serialization
⋮----
/**
 * Immediately save all processed events to disk, canceling any pending saves
 * @param projectPath - The path to the project directory
 */
export async function flushProcessedEvents(projectPath: string): Promise<void>
⋮----
// Cancel any pending saves and save immediately
⋮----
/**
 * Clear all processed event IDs from memory and cancel any pending saves
 */
export function clearProcessedEvents(): void
⋮----
/**
 * Get the total number of processed events
 * @returns The count of processed event IDs
 */
export function getProcessedEventCount(): number
</file>

<file path="src/commands/setup/llm.ts">
import { LLMConfigEditor } from "@/llm/LLMConfigEditor";
import { logger } from "@/utils/logger";
import { Command } from "commander";
⋮----
// Project-specific configuration
⋮----
// Check if we're in a TENEX project
⋮----
// Global configuration
⋮----
// Ensure global config directory exists
</file>

<file path="src/commands/daemon.ts">
import { EventMonitor } from "@/daemon/EventMonitor";
import { ProcessManager } from "@/daemon/ProcessManager";
import { ProjectManager } from "@/daemon/ProjectManager";
import { initNDK, shutdownNDK } from "@/nostr/ndkClient";
import { configService } from "@/services";
import { logger } from "@/utils/logger";
import { setupGracefulShutdown } from "@/utils/process";
import { runInteractiveSetup } from "@/utils/setup";
import { Command } from "commander";
⋮----
// Load configuration
⋮----
// Get whitelisted pubkeys
⋮----
// Check for required configurations
⋮----
// Run interactive setup
⋮----
// Save the setup configuration and reload
⋮----
// Initialize NDK and get singleton
⋮----
// Initialize core components
⋮----
// Set up graceful shutdown
⋮----
// Stop monitoring new events
⋮----
// Stop all running projects
⋮----
// Shutdown NDK singleton
⋮----
// Start monitoring without passing LLM configs - let projects load from global config with proper default detection
⋮----
// Keep the process alive
⋮----
// This promise never resolves, keeping the daemon running
</file>

<file path="src/conversations/__tests__/AgentConversationContext.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import { AgentConversationContext } from "../AgentConversationContext";
import { MessageBuilder } from "../MessageBuilder";
⋮----
// Add the event once
⋮----
// Try to add the same event again
⋮----
expect(messagesAfterSecond.length).toBe(1); // Should still be 1, not 2
⋮----
// Add the triggering event once
⋮----
// Try to add the same triggering event again
⋮----
expect(messagesAfterSecond.length).toBe(1); // Should still be 1, not 2
⋮----
// Add event1
⋮----
// Try to add event1 again (duplicate)
⋮----
expect(context.getMessages().length).toBe(1); // Should still be 1
⋮----
// Add event2 (unique)
⋮----
expect(context.getMessages().length).toBe(2); // Now should be 2
⋮----
// Try to add event2 again (duplicate)
⋮----
expect(context.getMessages().length).toBe(2); // Should still be 2
⋮----
// Try to add event1 again (duplicate)
⋮----
expect(context.getMessages().length).toBe(2); // Should still be 2
⋮----
// Create a context and add some events
⋮----
// Simulate adding events by directly manipulating the processed IDs
// (since we'd need async for the actual addEvent method)
⋮----
// Serialize the context
⋮----
// Restore from JSON
⋮----
// Check that processed event IDs were restored
</file>

<file path="src/conversations/__tests__/ConversationManager.phaseTransition.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { ConversationManager } from "../ConversationManager";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import { PHASES } from "../phases";
import type { AgentInstance } from "@/agents/types";
⋮----
// Mock the persistence module
⋮----
// Mock the tracing module
⋮----
// Mock the logging module
⋮----
// Mock NDK
⋮----
// Setup mock agents
⋮----
// Mock project context
⋮----
// Mock nostr utils
⋮----
// Should have phase instructions injected as system message
⋮----
// First interaction in CHAT phase
⋮----
// Transition to PLAN phase
⋮----
// Second interaction in PLAN phase
⋮----
// Should have phase transition message
⋮----
// Should NOT have phase instructions for orchestrator
⋮----
// First interaction
⋮----
// Second interaction in same phase
⋮----
// Should NOT have new phase instructions
⋮----
// Build messages - should set lastSeenPhase
⋮----
// Check agent state
⋮----
// Transition to new phase
⋮----
// New interaction in new phase
⋮----
// Check agent state updated
</file>

<file path="src/conversations/__tests__/executionTime.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import {
    startExecutionTime,
    stopExecutionTime,
    getTotalExecutionTimeSeconds,
    isExecutionActive,
    initializeExecutionTime,
    ensureExecutionTimeInitialized,
} from "../executionTime";
import type { Conversation, Phase } from "../types";
import { PHASES } from "../phases";
⋮----
// Mock Date.now for controlled time testing
⋮----
// Helper to create test conversation
function createTestConversation(id: string): Conversation
⋮----
startExecutionTime(conversation); // Try to start again
⋮----
// Should not change the start time
⋮----
mockTime += 5000; // 5 seconds later
⋮----
expect(duration).toBe(5000); // Duration in milliseconds
⋮----
conversation.executionTime.totalSeconds = 10; // Previous sessions
⋮----
mockTime += 5000; // 5 seconds of active session
⋮----
expect(totalSeconds).toBe(15); // 10 + 5
⋮----
// First session: 5 seconds
⋮----
// Second session: 3 seconds
mockTime += 10000; // User thinking time (not counted)
⋮----
// Third session: 7 seconds
mockTime += 5000; // User thinking time (not counted)
⋮----
expect(conversation.executionTime.totalSeconds).toBe(15); // 5 + 3 + 7
⋮----
mockTime += 365 * 24 * 60 * 60 * 1000; // 1 year in milliseconds
⋮----
expect(conversation.executionTime.totalSeconds).toBeGreaterThan(0); // No overflow
⋮----
mockTime += 1499; // Just under 1.5 seconds
⋮----
expect(conversation.executionTime.totalSeconds).toBe(1); // Rounds down
⋮----
mockTime += 1500; // Exactly 1.5 seconds
⋮----
expect(conversation.executionTime.totalSeconds).toBe(3); // 1 + 2 (rounds up)
⋮----
executionTime: undefined as any, // Simulate missing executionTime
⋮----
conversation.executionTime.currentSessionStart = mockTime - 45 * 60 * 1000; // 45 minutes ago
⋮----
conversation.executionTime.currentSessionStart = mockTime - 10 * 60 * 1000; // 10 minutes ago
⋮----
expect(conversation.executionTime.isActive).toBe(true); // Still active
⋮----
} as any, // Missing fields
⋮----
expect(conversation.executionTime.totalSeconds).toBe(100); // Preserved
⋮----
// lastUpdated is only set if we need to reset stale sessions
⋮----
// Active session adds 8 more seconds
⋮----
expect(netTime).toBe(50); // 42 + 8
⋮----
// Simulate rapid tool executions with longer durations
⋮----
mockTime += 1000; // 1 second per tool
⋮----
mockTime += 50; // 50ms between tools (not counted)
⋮----
expect(conversation.executionTime.totalSeconds).toBe(5); // 5 * 1s = 5s
</file>

<file path="src/conversations/executionQueue/__tests__/ExecutionQueueManager.test.ts">
import { ExecutionQueueManager } from '../ExecutionQueueManager';
import { ExecutionQueueConfig } from '../types';
⋮----
import { tmpdir } from 'os';
⋮----
maxExecutionDuration: 5000, // 5 seconds for testing
⋮----
// Create a temporary directory for testing
⋮----
// Create manager without Nostr service for unit tests
⋮----
undefined, // no projectPubkey
undefined, // no projectIdentifier
undefined, // no nostrService
⋮----
// Clean up
⋮----
// Remove test directory
⋮----
// Ignore cleanup errors
⋮----
// First conversation acquires lock
⋮----
// Second conversation should be queued
⋮----
// Same conversation requests again
⋮----
// Setup: Two conversations, first holds lock, second queued
⋮----
// Release first conversation
⋮----
// Check that second conversation now holds lock
⋮----
// First conversation gets lock
⋮----
// Queue multiple conversations
⋮----
// Release and check order
⋮----
// Remove conv-2 from queue
⋮----
// Check queue status
⋮----
maxExecutionDuration: 100, // 100ms for testing
⋮----
// Wait for timeout
⋮----
// Release before timeout
⋮----
// Wait a bit to ensure timeout doesn't fire
⋮----
// Create and acquire lock
⋮----
// Create new manager instance (simulating restart)
⋮----
// Check lock is restored
⋮----
// Clean up
⋮----
// Setup queue
⋮----
// Create new manager instance
⋮----
// Check queue is restored
⋮----
// Clean up
⋮----
// Create manager with very short timeout
⋮----
maxExecutionDuration: 1, // 1ms - will expire immediately
⋮----
// Acquire lock
⋮----
// Wait for lock to expire
⋮----
// Create new manager
⋮----
// Lock should be cleared due to expiry
⋮----
// Clean up
</file>

<file path="src/conversations/executionQueue/index.ts">

</file>

<file path="src/conversations/executionQueue/TimeoutManager.ts">
import { EventEmitter } from 'events';
import { ExecutionQueueConfig, DEFAULT_EXECUTION_QUEUE_CONFIG } from './types';
⋮----
export interface TimeoutManagerEvents {
  'timeout': (conversationId: string) => void;
  'warning': (conversationId: string, remainingMs: number) => void;
}
⋮----
export class TimeoutManager extends EventEmitter
⋮----
private readonly WARNING_THRESHOLD = 5 * 60 * 1000; // 5 minutes before timeout
⋮----
constructor(config: Partial<ExecutionQueueConfig> =
⋮----
startTimeout(conversationId: string, duration?: number): void
⋮----
// Set up warning timeout (5 minutes before expiry)
⋮----
// Set up main timeout
⋮----
clearTimeout(conversationId: string): void
⋮----
// Clear main timeout
⋮----
// Clear warning timeout
⋮----
extendTimeout(conversationId: string, additionalMs: number): void
⋮----
return; // No timeout to extend
⋮----
// Clear existing timeouts
⋮----
// Start new timeout with extended duration
⋮----
getRemainingTime(conversationId: string): number | null
⋮----
// Node.js timeout objects have a _idleStart property we can use
// This is a bit hacky but works for our purposes
// In production, we might want to track start times separately
⋮----
isActive(conversationId: string): boolean
⋮----
clearAll(): void
⋮----
// Clear all timeouts
⋮----
// Clear all warnings
⋮----
getActiveTimeouts(): string[]
⋮----
// Utility method for debugging
getTimeoutInfo():
⋮----
// Override EventEmitter methods for type safety
on<K extends keyof TimeoutManagerEvents>(
    event: K,
    listener: TimeoutManagerEvents[K]
): this
⋮----
emit<K extends keyof TimeoutManagerEvents>(
    event: K,
    ...args: Parameters<TimeoutManagerEvents[K]>
): boolean
⋮----
off<K extends keyof TimeoutManagerEvents>(
    event: K,
    listener: TimeoutManagerEvents[K]
): this
</file>

<file path="src/conversations/executionQueue/types.ts">
/**
 * Types and interfaces for the Execution Queue Mutex System
 */
⋮----
export interface ExecutionLock {
  conversationId: string;
  agentPubkey: string;
  timestamp: number;
  maxDuration: number; // Maximum execution time in milliseconds
}
⋮----
maxDuration: number; // Maximum execution time in milliseconds
⋮----
export interface QueueEntry {
  conversationId: string;
  agentPubkey: string;
  timestamp: number; // When added to queue
  retryCount: number; // Number of retry attempts
}
⋮----
timestamp: number; // When added to queue
retryCount: number; // Number of retry attempts
⋮----
export interface QueueStatus {
  totalWaiting: number;
  estimatedWait: number; // Seconds
  queue: QueueEntry[];
}
⋮----
estimatedWait: number; // Seconds
⋮----
export interface ExecutionPermission {
  granted: boolean;
  waitTime?: number; // Estimated wait time in seconds
  queuePosition?: number; // Position in queue (1-based)
  message?: string; // User-friendly message
}
⋮----
waitTime?: number; // Estimated wait time in seconds
queuePosition?: number; // Position in queue (1-based)
message?: string; // User-friendly message
⋮----
export interface PersistedLock {
  conversationId: string;
  agentPubkey: string;
  timestamp: number;
  maxDuration: number;
  projectPath: string;
}
⋮----
export interface ExecutionHistory {
  conversationId: string;
  startTime: number;
  endTime: number;
  agentPubkey: string;
  reason: 'completed' | 'timeout' | 'forced' | 'error';
}
⋮----
export interface ForceReleaseRequest {
  conversationId: string;
  reason: string;
  releasedBy: string;
  timestamp: number;
}
⋮----
export interface ExecutionQueueEvent {
  type: 'lock_acquired' | 'lock_released' | 'queue_joined' | 'queue_left' | 'force_released';
  conversationId: string;
  agentPubkey?: string;
  timestamp: number;
  details?: Record<string, any>;
}
⋮----
export interface ExecutionQueueConfig {
  maxExecutionDuration?: number; // Default: 30 minutes in milliseconds
  maxQueueSize?: number; // Default: 100
  maxHistorySize?: number; // Default: 1000
  persistenceDir?: string; // Default: .tenex/state
  enableAutoTimeout?: boolean; // Default: true
  enablePersistence?: boolean; // Default: true
}
⋮----
maxExecutionDuration?: number; // Default: 30 minutes in milliseconds
maxQueueSize?: number; // Default: 100
maxHistorySize?: number; // Default: 1000
persistenceDir?: string; // Default: .tenex/state
enableAutoTimeout?: boolean; // Default: true
enablePersistence?: boolean; // Default: true
⋮----
maxExecutionDuration: 30 * 60 * 1000, // 30 minutes
</file>

<file path="src/conversations/persistence/__tests__/FileSystemAdapter.integration.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { FileSystemAdapter } from "../FileSystemAdapter";
import { createTempDir, cleanupTempDir } from "@/test-utils";
import { logger } from "@/utils/logger";
⋮----
import type { Conversation } from "@/conversations/types";
import { pathExists } from "@/lib/fs/filesystem";
⋮----
// Mock NDK to avoid initialization errors
⋮----
// Create test directories
⋮----
// Initialize adapter
⋮----
// Cleanup
⋮----
history: [], // Empty history
⋮----
// Save conversation
⋮----
// Verify file was created (files are saved as {id}.json, not in subdirectories)
⋮----
// Load conversation
⋮----
expect(loaded?.phase).toBe("chat"); // Schema transforms to lowercase
⋮----
// Verify agentContexts Map is properly restored
⋮----
// Save multiple conversations
⋮----
// List conversations
⋮----
// Save conversations with different titles
⋮----
// Search for authentication
⋮----
// Save and then archive
⋮----
// Verify it's marked as archived
⋮----
// Verify archive file exists (archived files are in archive/{id}.json)
⋮----
// Verify metadata shows it as archived
⋮----
// Save initial version
⋮----
// Simulate concurrent updates
⋮----
// Wait for all saves
⋮----
// Load and verify final state
⋮----
// Should have one of the concurrent values (race condition is expected)
</file>

<file path="src/conversations/persistence/__tests__/FileSystemAdapter.state-persistence.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { FileSystemAdapter } from "../FileSystemAdapter";
import { createTempDir, cleanupTempDir, createMockNDKEvent } from "@/test-utils";
⋮----
import type { Conversation, AgentContext } from "@/conversations/types";
import { EVENT_KINDS } from "@/llm/types";
import { pathExists } from "@/lib/fs/filesystem";
⋮----
// Mock NDK to avoid initialization errors
⋮----
// Mock NDKEvent to handle deserialization
⋮----
// Create test directories
⋮----
// Initialize adapter
⋮----
// Cleanup
⋮----
// Create a complex conversation with multiple agent contexts
⋮----
phaseStartedAt: Date.now() - 60000, // Started 1 minute ago
⋮----
// Save conversation
⋮----
// Verify file was created
⋮----
// Load conversation
⋮----
// Verify basic properties
⋮----
// Verify history is preserved
⋮----
// Verify agent contexts are preserved
⋮----
// Note: toolCalls are not currently preserved in FileSystemAdapter
// This would require updating the adapter to handle toolCalls in message reconstruction
⋮----
// Note: toolCalls are not currently preserved in FileSystemAdapter
⋮----
// Verify metadata is preserved
⋮----
// Verify the history events are preserved
⋮----
// Verify phase transitions are preserved
⋮----
// Verify execution time is preserved
⋮----
// Note: Custom metrics property is not part of standard Conversation interface
// and would require schema updates to persist
⋮----
// Create multiple conversations
⋮----
// Verify all conversations can be loaded
⋮----
// Verify files exist on disk
⋮----
// Filter to only count the conversation files we created in this test
⋮----
// Create initial conversation
⋮----
// Save initial state
⋮----
// Update conversation
⋮----
// Save updated state
⋮----
// Load and verify updates
⋮----
// Save and load
⋮----
// Verify special characters are preserved
</file>

<file path="src/conversations/persistence/__tests__/FileSystemAdapter.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { FileSystemAdapter } from "../FileSystemAdapter";
import { createTempDir, cleanupTempDir, createMockConversation } from "@/test-utils";
import path from "node:path";
⋮----
import { pathExists } from "@/lib/fs/filesystem";
⋮----
// Initialize again - should not throw
⋮----
// Check the conversations subdirectory
⋮----
// Check base directory
⋮----
// The adapter might sanitize the filename
⋮----
// Update and save again
⋮----
// Should sanitize the filename
⋮----
// Add a non-JSON file
⋮----
// Verify it exists
⋮----
// Delete it
⋮----
// Verify it's gone
⋮----
// Should not throw
⋮----
// Add lots of phase transitions
⋮----
// Save 10 conversations concurrently
</file>

<file path="src/conversations/services/__tests__/ConversationStore.test.ts">
import { describe, expect, it, beforeEach } from "@jest/globals";
import { ConversationStore } from "../ConversationStore";
import type { Conversation } from "../../types";
import { PHASES } from "../../phases";
import { NDKEvent } from "@nostr-dev-kit/ndk";
</file>

<file path="src/conversations/services/__tests__/PhaseManager.test.ts">
import { describe, expect, it, beforeEach, jest } from "@jest/globals";
import { PhaseManager } from "../PhaseManager";
import { PHASES } from "../../phases";
import type { Conversation } from "../../types";
import type { ExecutionQueueManager } from "../../executionQueue";
import { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Create mock queue manager
⋮----
// Now all phases can transition to all others
⋮----
// Test a previously "invalid" transition that's now valid
⋮----
// Should not throw
</file>

<file path="src/conversations/services/AgentResolver.ts">
import type { AgentInstance } from "@/agents/types";
import { getProjectContext } from "@/services";
import { logger } from "@/utils/logger";
⋮----
/**
 * Interface for resolving agents.
 * Allows for different implementations (project-based, standalone, etc.)
 */
export interface IAgentResolver {
    getAgent(slug: string): AgentInstance | undefined;
    getAgentByPubkey(pubkey: string): AgentInstance | undefined;
    getAllAgents(): Map<string, AgentInstance>;
}
⋮----
getAgent(slug: string): AgentInstance | undefined;
getAgentByPubkey(pubkey: string): AgentInstance | undefined;
getAllAgents(): Map<string, AgentInstance>;
⋮----
/**
 * Project-based agent resolver that uses the project context.
 */
export class ProjectAgentResolver implements IAgentResolver
⋮----
getAgent(slug: string): AgentInstance | undefined
⋮----
getAgentByPubkey(pubkey: string): AgentInstance | undefined
⋮----
getAllAgents(): Map<string, AgentInstance>
⋮----
/**
 * Standalone agent resolver for non-project contexts.
 * Agents are provided directly to the resolver.
 */
export class StandaloneAgentResolver implements IAgentResolver
⋮----
constructor(agents: Map<string, AgentInstance>)
⋮----
// Build pubkey lookup map
⋮----
/**
     * Add or update an agent
     */
addAgent(agent: AgentInstance): void
⋮----
/**
     * Remove an agent
     */
removeAgent(slug: string): void
⋮----
/**
 * Mock agent resolver for testing
 */
export class MockAgentResolver implements IAgentResolver
⋮----
constructor(agents?: AgentInstance[])
⋮----
// Test helper methods
addMockAgent(agent: AgentInstance): void
⋮----
clear(): void
</file>

<file path="src/conversations/services/ConversationPersistenceService.ts">
import type { Conversation } from "../types";
import type { 
    ConversationPersistenceAdapter, 
    ConversationMetadata, 
    ConversationSearchCriteria 
} from "../persistence/types";
import { FileSystemAdapter } from "../persistence";
import { logger } from "@/utils/logger";
⋮----
/**
 * Service for persisting conversations to storage.
 * Single Responsibility: Handle all persistence operations.
 */
export interface IConversationPersistenceService {
    initialize(): Promise<void>;
    save(conversation: Conversation): Promise<void>;
    load(id: string): Promise<Conversation | null>;
    loadAll(): Promise<Conversation[]>;
    archive(id: string): Promise<void>;
    search(criteria: ConversationSearchCriteria): Promise<Conversation[]>;
}
⋮----
initialize(): Promise<void>;
save(conversation: Conversation): Promise<void>;
load(id: string): Promise<Conversation | null>;
loadAll(): Promise<Conversation[]>;
archive(id: string): Promise<void>;
search(criteria: ConversationSearchCriteria): Promise<Conversation[]>;
⋮----
export class ConversationPersistenceService implements IConversationPersistenceService
⋮----
constructor(private adapter: ConversationPersistenceAdapter)
⋮----
async initialize(): Promise<void>
⋮----
async save(conversation: Conversation): Promise<void>
⋮----
async load(id: string): Promise<Conversation | null>
⋮----
async loadAll(): Promise<Conversation[]>
⋮----
async archive(id: string): Promise<void>
⋮----
async search(criteria: ConversationSearchCriteria): Promise<Conversation[]>
⋮----
/**
 * Factory function to create a file-based persistence service
 */
export function createFileSystemPersistenceService(projectPath: string): ConversationPersistenceService
⋮----
/**
 * In-memory persistence adapter for testing and standalone usage
 */
export class InMemoryPersistenceAdapter implements ConversationPersistenceAdapter
⋮----
// No initialization needed for in-memory storage
⋮----
async load(conversationId: string): Promise<Conversation | null>
⋮----
async delete(conversationId: string): Promise<void>
⋮----
async list(): Promise<ConversationMetadata[]>
⋮----
async search(criteria: ConversationSearchCriteria): Promise<ConversationMetadata[]>
⋮----
async archive(conversationId: string): Promise<void>
⋮----
async restore(conversationId: string): Promise<void>
</file>

<file path="src/conversations/services/ConversationStore.ts">
import type { Conversation } from "../types";
import { logger } from "@/utils/logger";
⋮----
/**
 * In-memory storage for active conversations.
 * Single Responsibility: Fast lookup and retrieval of conversation objects.
 */
export class ConversationStore
⋮----
/**
     * Get a conversation by ID
     */
get(id: string): Conversation | undefined
⋮----
/**
     * Store a conversation
     */
set(id: string, conversation: Conversation): void
⋮----
/**
     * Delete a conversation
     */
delete(id: string): void
⋮----
/**
     * Check if a conversation exists
     */
exists(id: string): boolean
⋮----
/**
     * Get all conversations
     */
getAll(): Conversation[]
⋮----
/**
     * Find a conversation by event ID
     */
findByEvent(eventId: string): Conversation | undefined
⋮----
/**
     * Clear all conversations
     */
clear(): void
⋮----
/**
     * Get the number of stored conversations
     */
size(): number
</file>

<file path="src/conversations/services/index.ts">

</file>

<file path="src/conversations/MessageBuilder.ts">
import { Message } from "multi-llm-ts";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import { getNDK } from "@/nostr";
import { isEventFromUser, getAgentSlugFromEvent } from "@/nostr/utils";
import { getProjectContext } from "@/services";
import { Phase } from "./phases";
import { logger } from "@/utils/logger";
⋮----
/**
 * Handles message formatting and processing.
 * Single Responsibility: Transform events and content into properly formatted messages.
 */
export class MessageBuilder
⋮----
/**
     * Process nostr entities in content, replacing them with inline content
     */
async processNostrEntities(content: string): Promise<string>
⋮----
// Keep original entity if fetch fails
⋮----
/**
     * Format an NDKEvent as a Message for a specific agent
     */
formatEventAsMessage(
        event: NDKEvent,
        processedContent: string,
        targetAgentSlug: string
): Message
⋮----
// Agent's own message
⋮----
// User message
⋮----
// Another agent's message
⋮----
/**
     * Build phase transition message
     */
buildPhaseTransitionMessage(fromPhase: Phase | undefined, toPhase: Phase): string
⋮----
/**
     * Format a system message with proper attribution
     */
formatSystemMessage(content: string, attribution?: string): Message
⋮----
/**
     * Create a user message
     */
formatUserMessage(content: string): Message
⋮----
/**
     * Create an assistant message
     */
formatAssistantMessage(content: string): Message
⋮----
/**
     * Check if content contains nostr entities
     */
hasNostrEntities(content: string): boolean
⋮----
/**
     * Extract nostr entities from content
     */
extractNostrEntities(content: string): string[]
</file>

<file path="src/daemon/ProcessManager.ts">
import { type ChildProcess, spawn } from "node:child_process";
⋮----
import { logger } from "@/utils/logger";
⋮----
export interface IProcessManager {
    spawnProjectRun(projectPath: string, projectId?: string): Promise<void>;
    isProjectRunning(projectId: string): Promise<boolean>;
    stopProject(projectId: string): Promise<void>;
    stopAll(): Promise<void>;
}
⋮----
spawnProjectRun(projectPath: string, projectId?: string): Promise<void>;
isProjectRunning(projectId: string): Promise<boolean>;
stopProject(projectId: string): Promise<void>;
stopAll(): Promise<void>;
⋮----
interface ProcessInfo {
    process: ChildProcess;
    projectPath: string;
    startedAt: Date;
}
⋮----
export class ProcessManager implements IProcessManager
⋮----
async spawnProjectRun(projectPath: string, projectId?: string): Promise<void>
⋮----
// Check if already running
⋮----
// Get the CLI binary path
⋮----
// Spawn the process
⋮----
stdio: "inherit", // Let output pass through directly
⋮----
// Handle process exit
⋮----
// Handle errors
⋮----
// Store process info
⋮----
async isProjectRunning(projectId: string): Promise<boolean>
⋮----
// Check if process is still alive
⋮----
// Process doesn't exist
⋮----
async stopProject(projectId: string): Promise<void>
⋮----
// Try graceful shutdown first
⋮----
// Wait for process to exit
⋮----
// Force kill if not exited
⋮----
async stopAll(): Promise<void>
⋮----
getRunningProjects(): Array<
</file>

<file path="src/event-handler/__tests__/newConversation.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { handleNewConversation } from "../newConversation";
import { createMockNDKEvent } from "@/test-utils";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Create mock event
⋮----
// Create mock agent registry
⋮----
// Create mock conversation manager
⋮----
// Create mock agent executor
⋮----
// Mock modules
⋮----
constructor()
⋮----
async publishResponse()
async publishError()
⋮----
// Agent lookup happens in the function itself, not through registry
⋮----
// Remove agent tag
⋮----
// Default agent is orchestrator
⋮----
// Should not throw
⋮----
// Should not throw
⋮----
// Should not throw
⋮----
// Should not throw
⋮----
// Should still create conversation with empty content
</file>

<file path="src/event-handler/__tests__/task-reply-routing.test.ts">
import { describe, it, expect, beforeEach, mock, spyOn } from "bun:test";
import { NDKEvent, NDKTask } from "@nostr-dev-kit/ndk";
import { handleChatMessage } from "../reply";
import type { ConversationManager } from "@/conversations/ConversationManager";
import type { AgentExecutor } from "@/agents/execution/AgentExecutor";
import type { Conversation } from "@/conversations/types";
import { logger } from "@/utils/logger";
⋮----
import { AgentInstance } from "@/agents/types";
⋮----
// Mock logger to avoid console output during tests
⋮----
// Setup pubkeys
⋮----
// Create mock agent
⋮----
// Create mock project context
⋮----
// Mock getProjectContext
⋮----
// Create mock conversation manager
⋮----
// Create mock agent executor
⋮----
// Create a reply to a task event
⋮----
["E", taskId],  // Replying to the task
["K", "1934"],   // This is a task reply
["p", projectPubkey],  // Mentioning the project
⋮----
// Create mock conversation
⋮----
// Setup mocks
mockConversationManager.getConversationByEvent.mockReturnValue(undefined); // No direct conversation found
⋮----
// Call the handler
⋮----
// Verify task mapping was checked
⋮----
// Verify conversation was retrieved using the mapped ID
⋮----
// Verify event was added to the conversation
⋮----
// Verify agent executor was called with the correct Claude session ID
⋮----
// Create a reply to a task event
⋮----
// Create mock conversation where task ID is the conversation root
⋮----
// Setup mocks
⋮----
mockConversationManager.getTaskMapping.mockReturnValue(undefined); // No mapping exists
⋮----
// Call the handler
⋮----
// Verify task mapping was checked first
⋮----
// Verify fallback to direct conversation lookup
⋮----
// Verify event was processed
⋮----
// Create a reply with its own claude-session tag
⋮----
["claude-session", eventSessionId],  // Event has its own session tag
⋮----
// Create mock conversation
⋮----
// Setup mocks
⋮----
claudeSessionId: mappedSessionId,  // Mapping has a session ID
⋮----
// Call the handler
⋮----
// Verify the mapped session ID was used (not the event tag)
⋮----
claudeSessionId: mappedSessionId,  // Should use mapped session, not event tag
⋮----
// Create a reply to a non-existent task
⋮----
// Setup mocks - no conversation found anywhere
⋮----
// Call the handler
⋮----
// Verify attempts were made to find the conversation
⋮----
// Verify no execution happened (no conversation found)
⋮----
// Verify error was logged
</file>

<file path="src/event-handler/__tests__/task.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { NDKTask } from "@nostr-dev-kit/ndk";
import { handleTask } from "../task";
import type { AgentExecutor } from "@/agents/execution/AgentExecutor";
import type { ConversationManager } from "@/conversations";
import type { AgentInstance } from "@/agents/types";
import { createMockAgent } from "@/test-utils";
⋮----
// Reset mocks
⋮----
// Create mock agents
⋮----
// Mock project context
⋮----
// Mock getProjectContext
⋮----
// Mock NostrPublisher
⋮----
// Create mock conversation manager
⋮----
// Create mock agent executor
⋮----
// Create mock event
⋮----
// Verify conversation was created
⋮----
// Verify executor was called with orchestrator
⋮----
// Add p-tag for specific agent
⋮----
// Verify executor was called with the p-tagged agent
⋮----
// Add p-tag for unknown agent
⋮----
// Verify conversation was created but no execution happened
⋮----
// Add multiple p-tags
⋮----
// Should route to first matching agent (TestAgent)
⋮----
// Make conversation creation fail
⋮----
// Should not throw
⋮----
// Executor should not be called
⋮----
// Make agent execution fail
⋮----
// Should not throw
⋮----
// Conversation should still be created
⋮----
// Remove claude-session tag
⋮----
// Create long content
⋮----
// Should still process normally
⋮----
// Track NostrPublisher constructor calls
⋮----
// Verify NostrPublisher was created with correct params
</file>

<file path="src/event-handler/newConversation.ts">
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import chalk from "chalk";
import type { AgentExecutor } from "../agents/execution/AgentExecutor";
import type { ConversationManager } from "../conversations";
import { getProjectContext } from "../services";
import { formatAnyError } from "../utils/error-formatter";
import { logger } from "../utils/logger";
import { createNostrPublisher } from "../nostr/factory";
⋮----
interface EventHandlerContext {
    conversationManager: ConversationManager;
    agentExecutor: AgentExecutor;
}
⋮----
export const handleNewConversation = async (
    event: NDKEvent,
    context: EventHandlerContext
): Promise<void> =>
⋮----
// Create conversation
⋮----
// Get project context
⋮----
// Get Project Manager as default coordinator
⋮----
// Check for p-tags to determine if user @mentioned a specific agent
⋮----
let targetAgent = projectManager; // Default to PM for coordination
⋮----
// If there are p-tags, check if any match system agents
⋮----
// Execute with the appropriate agent
</file>

<file path="src/events/index.ts">

</file>

<file path="src/events/NDKAgentDefinition.ts">
import { NDKEvent, type NDKRawEvent } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
⋮----
export class NDKAgentDefinition extends NDKEvent
⋮----
constructor(ndk?: NDK, event?: NDKEvent | NDKRawEvent)
⋮----
static from(event: NDKEvent): NDKAgentDefinition
⋮----
get name(): string | undefined
⋮----
set name(value: string | undefined)
⋮----
get title(): string | undefined
⋮----
set title(value: string | undefined)
⋮----
get description(): string | undefined
⋮----
/**
     * A one-liner description of the agent's purpose or functionality.
     */
set description(value: string | undefined)
⋮----
get role(): string | undefined
⋮----
/**
     * The expertise and personality for this agent.
     * This shapes how the agent interacts with users and other agents.
     */
set role(value: string | undefined)
⋮----
get instructions(): string | undefined
⋮----
/**
     * Detailed instructions or guidelines for the agent's operation.
     */
set instructions(value: string | undefined)
⋮----
get version(): number
⋮----
if (val === undefined) return 1; // Default version if not specified
⋮----
set version(value: number)
⋮----
get useCriteria(): string | undefined
⋮----
/**
     * Criteria for when this agent should be selected or used.
     * This helps with agent routing and selection.
     */
set useCriteria(value: string | undefined)
</file>

<file path="src/lib/__tests__/shell.test.ts">
import { describe, it, expect } from "bun:test";
import { which } from "../shell";
⋮----
// Integration test - only test with real commands that should exist
⋮----
// These commands should exist on most Unix-like systems
⋮----
// If found, it should be an absolute path
⋮----
break; // At least one should work
⋮----
// Should find echo command if it exists
</file>

<file path="src/lib/fs/filesystem.ts">
import type { Stats } from "node:fs";
⋮----
import { formatAnyError } from "@/utils/error-formatter";
import { logError } from "@/utils/logger";
⋮----
/**
 * Unified file system utilities combining patterns from CLI and shared packages
 * Provides both sync and async operations with consistent error handling
 * 
 * @module filesystem
 * @description
 * This module provides a comprehensive set of file system utilities with:
 * - Path resolution and expansion (home directory ~)
 * - Directory and file existence checks
 * - JSON file read/write operations
 * - Text file operations
 * - Directory listing and management
 * - File copying and deletion
 * - Consistent error handling across all operations
 */
⋮----
// File operations
export async function readFile(filePath: string, encoding?: BufferEncoding): Promise<string>;
export async function readFile(filePath: string, encoding: null): Promise<Buffer>;
export async function readFile(
    filePath: string,
    encoding?: BufferEncoding | null
): Promise<string | Buffer>
⋮----
export function expandHome(filePath: string): string
⋮----
export function resolvePath(filePath: string): string
⋮----
// Directory operations
export async function ensureDirectory(dirPath: string): Promise<void>
⋮----
export function ensureDirectorySync(dirPath: string): void
⋮----
export async function directoryExists(dirPath: string): Promise<boolean>
⋮----
export function directoryExistsSync(dirPath: string): boolean
⋮----
// Path existence check (works for both files and directories)
export async function pathExists(filePath: string): Promise<boolean>
⋮----
// File operations
export async function fileExists(filePath: string): Promise<boolean>
⋮----
export function fileExistsSync(filePath: string): boolean
⋮----
// JSON operations with error handling
export async function readJsonFile<T>(filePath: string): Promise<T | null>
⋮----
export function readJsonFileSync<T>(filePath: string): T | null
⋮----
export async function writeJsonFile<T>(
    filePath: string,
    data: T,
    options?: { spaces?: number }
): Promise<void>
⋮----
export function writeJsonFileSync<T>(
    filePath: string,
    data: T,
    options?: { spaces?: number }
): void
⋮----
// Text file operations
export async function readTextFile(filePath: string): Promise<string | null>
⋮----
export function readTextFileSync(filePath: string): string | null
⋮----
export async function writeTextFile(filePath: string, content: string): Promise<void>
⋮----
export function writeTextFileSync(filePath: string, content: string): void
⋮----
// Directory listing
export async function listDirectory(dirPath: string): Promise<string[]>
⋮----
export function listDirectorySync(dirPath: string): string[]
⋮----
// File copying
export async function copyFile(src: string, dest: string): Promise<void>
⋮----
export function copyFileSync(src: string, dest: string): void
⋮----
// File deletion
export async function deleteFile(filePath: string): Promise<void>
⋮----
// File doesn't exist, that's fine
⋮----
export function deleteFileSync(filePath: string): void
⋮----
// File doesn't exist, that's fine
⋮----
// Directory deletion
export async function deleteDirectory(
    dirPath: string,
    options?: { recursive?: boolean }
): Promise<void>
⋮----
// Directory doesn't exist, that's fine
⋮----
export function deleteDirectorySync(dirPath: string, options?:
⋮----
// Directory doesn't exist, that's fine
⋮----
// File stats
export async function getFileStats(filePath: string): Promise<Stats | null>
⋮----
export function getFileStatsSync(filePath: string): Stats | null
</file>

<file path="src/lib/shell.ts">
import { exec } from "node:child_process";
import { promisify } from "node:util";
⋮----
/**
 * Platform-specific command for finding executables
 */
const getWhichCommand = (): string =>
⋮----
/**
 * Find the full path of a command using the system's which/where command
 * @param command - The command name to find
 * @returns The full path to the command, or null if not found
 * @throws Error if command parameter is invalid
 */
export async function which(command: string): Promise<string | null>
⋮----
// Input validation
⋮----
// Get first result if multiple paths are returned
⋮----
// Command not found or execution error
</file>

<file path="src/llm/__tests__/ToolResult.test.ts">
import { describe, it, expect } from "bun:test";
import {
    serializeToolResult,
    isSerializedToolResult,
    deserializeToolResult,
    type SerializedToolResult,
} from "../ToolResult";
import type { ToolExecutionResult } from "@/tools/types";
</file>

<file path="src/llm/pricing.ts">
import { formatAnyError } from "@/utils/error-formatter";
/**
 * OpenRouter pricing service for dynamic LLM cost calculation
 */
⋮----
import { logger } from "@/utils/logger";
⋮----
interface OpenRouterPricing {
    prompt: string;
    completion: string;
    request: string;
    image: string;
    web_search: string;
    internal_reasoning: string;
}
⋮----
interface OpenRouterModel {
    id: string;
    name: string;
    pricing: OpenRouterPricing;
}
⋮----
interface OpenRouterResponse {
    data: OpenRouterModel[];
}
⋮----
interface ModelPricing {
    prompt: number;
    completion: number;
}
⋮----
export class OpenRouterPricingService
⋮----
private readonly cacheValidityMs = 60 * 60 * 1000; // 1 hour
⋮----
/**
     * Get pricing for a specific model
     */
async getModelPricing(modelId: string): Promise<ModelPricing | null>
⋮----
/**
     * Calculate cost for token usage
     */
async calculateCost(
        modelId: string,
        promptTokens: number,
        completionTokens: number
): Promise<number>
⋮----
// Return a minimal default cost
return ((promptTokens + completionTokens) / 1_000_000) * 1.0; // $1 per 1M tokens
⋮----
/**
     * Get all available models with pricing
     */
async getAllModelPricing(): Promise<Map<string, ModelPricing>>
⋮----
/**
     * Force refresh the pricing cache
     */
async refreshCache(): Promise<void>
⋮----
// Clear existing cache
⋮----
// Populate cache with new data
⋮----
// Only cache models with valid pricing
⋮----
/**
     * Ensure cache is fresh, refresh if needed
     */
private async ensureFreshCache(): Promise<void>
⋮----
/**
     * Find best matching model ID for partial model names
     * This helps with cases where the model name doesn't exactly match OpenRouter's ID
     */
async findModelId(partialModelName: string): Promise<string | null>
⋮----
// Exact match first
⋮----
// Partial match
⋮----
// Export singleton instance
</file>

<file path="src/nostr/__tests__/NostrEventService.test.ts">
import { NostrEventService } from '../NostrEventService';
import { NDKEvent, NDKSigner } from '@nostr-dev-kit/ndk';
import { vi, describe, it, expect, beforeEach } from 'vitest';
⋮----
// Create mock signer
⋮----
// Create mock event
⋮----
// Should now work with the new signer
</file>

<file path="src/nostr/__tests__/TypingIndicatorManager.integration.test.ts">
import { describe, it, expect, mock } from "bun:test";
import { TypingIndicatorManager } from "../TypingIndicatorManager";
import type { NostrPublisher } from "../NostrPublisher";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Scenario: Rapid typing indicators that should not flicker
⋮----
// First typing indicator
⋮----
// Quick stop and start again (simulating rapid messages)
⋮----
// Verify no stop was published yet (due to debouncing)
⋮----
// Request final stop to trigger the delayed stop
⋮----
// Since we started at time 0, and last start was at ~200ms,
// we need to wait until 5000ms from the first start
const waitTime = 5000 - (Date.now() - startTime) + 100; // +100ms buffer
⋮----
// Verify the stop was eventually published
⋮----
// Clean up
</file>

<file path="src/nostr/__tests__/voice-mode-propagation.test.ts">
import { describe, expect, it, beforeEach, mock } from "bun:test";
import { NostrPublisher } from "../NostrPublisher";
import type { NostrPublisherContext } from "../NostrPublisher";
import type { AgentInstance } from "@/agents/types";
import type { ConversationManager } from "@/conversations/ConversationManager";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
⋮----
// Mock NDK
⋮----
// Mock triggering event
⋮----
// Mock agent
⋮----
// Mock conversation manager
⋮----
// Create context
⋮----
// Mock getProjectContext and getNDK
⋮----
// Check that the response has the voice mode tag
⋮----
// Mock triggering event without voice mode
⋮----
// Check that the response doesn't have the voice mode tag
⋮----
// Verify that the triggering event has voice mode
⋮----
// Create stream publisher - it will inherit the voice mode from context
⋮----
// Verify the stream publisher has access to voice mode context
⋮----
// The actual streaming event publication would include the voice mode tag
// based on the context.triggeringEvent.tagValue("mode") check
⋮----
// Check that the error event has the voice mode tag
</file>

<file path="src/nostr/event-builder.ts">
import { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
/**
 * Create an NDK event with standard fields
 */
export function createNDKEvent(
    kind: number,
    content: string,
    pubkey?: string,
    tags: string[][] = []
): NDKEvent
⋮----
/**
 * Add tags to an existing event
 */
export function addTagsToEvent(event: NDKEvent, tags: string[][]): void
⋮----
/**
 * Set event timestamp to current time
 */
export function setEventTimestamp(event: NDKEvent): void
</file>

<file path="src/nostr/factory.ts">
import type { AgentInstance } from "@/agents/types";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { ConversationManager } from "@/conversations/ConversationManager";
import { NostrPublisher } from "./NostrPublisher";
⋮----
/**
 * Factory function to create a NostrPublisher with consistent configuration
 */
export async function createNostrPublisher(params: {
    conversationId: string;
    agent: AgentInstance;
    triggeringEvent: NDKEvent;
    conversationManager: ConversationManager;
}): Promise<NostrPublisher>
</file>

<file path="src/nostr/index.ts">
// Centralized publisher
</file>

<file path="src/nostr/ndkClient.ts">
import { getRelayUrls } from "@/utils/relays";
/**
 * TENEX CLI: NDK Singleton
 * Manages a single NDK instance for the CLI
 */
import NDK from "@nostr-dev-kit/ndk";
⋮----
export async function initNDK(): Promise<void>
⋮----
// Disconnect existing instance
⋮----
export function getNDK(): NDK
⋮----
export async function shutdownNDK(): Promise<void>
⋮----
// Disconnect all relays
</file>

<file path="src/nostr/NostrEventService.ts">
import { NDKEvent, NDKSigner } from '@nostr-dev-kit/ndk';
import { getNDK } from './index';
import { logger } from '@/utils/logger';
⋮----
/**
 * Service for handling Nostr event operations including signing and publishing.
 * This centralizes event management for the execution queue system.
 */
export class NostrEventService
⋮----
constructor(signer?: NDKSigner)
⋮----
setSigner(signer: NDKSigner): void
⋮----
/**
   * Signs and publishes an NDKEvent to the Nostr network
   */
async signAndPublishEvent(event: NDKEvent): Promise<void>
⋮----
// Sign the event
⋮----
// Publish to the network
⋮----
/**
   * Publishes an event without signing (assumes already signed)
   */
async publishEvent(event: NDKEvent): Promise<void>
⋮----
/**
   * Creates and configures an NDKEvent with proper NDK instance
   */
createEvent(kind: number): NDKEvent
⋮----
/**
   * Fetches events from the network based on filters
   */
async fetchEvents(filter: any): Promise<Set<NDKEvent>>
⋮----
/**
   * Subscribes to events matching the given filter
   */
subscribe(filter: any, callbacks: {
onEvent?: (event: NDKEvent)
</file>

<file path="src/nostr/TypingIndicatorManager.ts">
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import type { NostrPublisher } from "./NostrPublisher";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
/**
 * Manages typing indicator state to prevent flickering and ensure minimum duration.
 * 
 * Key features:
 * - Ensures typing indicators remain visible for at least 5 seconds
 * - Prevents flickering when multiple messages are sent rapidly
 * - Debounces stop events to batch rapid changes
 */
export class TypingIndicatorManager
⋮----
private static readonly MINIMUM_DURATION_MS = 5000; // 5 seconds
⋮----
private static readonly RETRY_DELAY_MS = 1000; // 1 second between retries
⋮----
constructor(publisher: NostrPublisher)
⋮----
/**
     * Start or update the typing indicator.
     * If already typing, this will update the message and reset the timer.
     */
async start(message?: string): Promise<NDKEvent>
⋮----
// Clear any pending stop timer
⋮----
// If not currently typing, record start time
⋮----
// Update the message if provided
⋮----
// Publish the typing indicator using the raw method to bypass timing logic
// Type assertion needed as publishTypingIndicatorRaw is an internal method
⋮----
publishTypingIndicatorRaw(state: "start" | "stop", message?: string): Promise<NDKEvent>;
⋮----
this.retryCount = 0; // Reset retry count on success
⋮----
// Attempt retry with exponential backoff
⋮----
return this.start(message); // Recursive retry
⋮----
// After max retries, reset state and throw
⋮----
/**
     * Request to stop the typing indicator.
     * This will be delayed to ensure minimum duration is met.
     */
async stop(): Promise<void>
⋮----
return; // Already stopped
⋮----
// Clear any existing stop timer
⋮----
// Calculate how long we've been typing
⋮----
// Schedule the actual stop
⋮----
// Always reset state on error to prevent stuck indicators
⋮----
// Ensure timer is cleared
⋮----
/**
     * Force immediate stop, bypassing minimum duration.
     * Use this only when necessary (e.g., on error or shutdown).
     */
async forceStop(): Promise<void>
⋮----
// Clear any pending stop timer
⋮----
// Always reset state on error
⋮----
// Always reset state when force stopping
⋮----
/**
     * Check if currently typing.
     */
isCurrentlyTyping(): boolean
⋮----
/**
     * Clean up any pending timers.
     */
cleanup(): void
</file>

<file path="src/prompts/core/PromptBuilder.ts">
import { formatAnyError } from "@/utils/error-formatter";
import { fragmentRegistry } from "./FragmentRegistry";
import type { FragmentConfig, PromptFragment } from "./types";
⋮----
export class PromptBuilder
⋮----
add<T>(fragmentId: string, args: T, condition?: (args: T) => boolean): this
⋮----
addFragment<T>(fragment: PromptFragment<T>, args: T, condition?: (args: T) => boolean): this
⋮----
build(): string
⋮----
// Validate arguments if validator is provided
⋮----
clear(): this
⋮----
getFragmentCount(): number
</file>

<file path="src/prompts/fragments/__tests__/available-agents.test.ts">
import { PromptBuilder } from "../../core/PromptBuilder";
import "../available-agents"; // Ensure fragment is registered
import type { AgentInstance } from "@/agents/types";
⋮----
currentAgentPubkey: "pm123", // Orchestrator agent
⋮----
currentAgentPubkey: "dev456", // Specialist agent
</file>

<file path="src/prompts/fragments/10-referenced-article.ts">
import { fragmentRegistry } from "../core/FragmentRegistry";
⋮----
interface ReferencedArticleArgs {
    title: string;
    content: string;
    dTag: string;
}
⋮----
priority: 10, // High priority to appear early in the prompt
</file>

<file path="src/prompts/fragments/15-specialist-available-agents.ts">
import type { AgentInstance } from "@/agents/types";
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
/**
 * Available agents fragment for SPECIALISTS.
 * Shows coworkers they can hand off to.
 * No conditionals, no isOrchestrator checks.
 */
interface SpecialistAvailableAgentsArgs {
    agents: AgentInstance[];
    currentAgent: AgentInstance;
}
⋮----
// Filter out current agent
⋮----
// Register the fragment
</file>

<file path="src/prompts/fragments/20-phase-constraints.ts">
import type { Phase } from "@/conversations/phases";
import { PHASE_DEFINITIONS } from "@/conversations/phases";
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
// Phase constraints fragment - used by AgentExecutor
interface PhaseConstraintsArgs {
    phase: string;
}
⋮----
function getPhaseConstraints(phase: string): string[]
⋮----
// Register fragments
</file>

<file path="src/prompts/fragments/20-voice-mode.ts">
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
export interface VoiceModeOptions {
    isVoiceMode: boolean;
}
⋮----
priority: 20, // High priority to ensure voice instructions are prominent
⋮----
// Register the fragment
⋮----
/**
 * Helper function to check if an event has voice mode enabled
 */
export function isVoiceMode(event: NDKEvent | undefined): boolean
</file>

<file path="src/prompts/fragments/24-retrieved-lessons.ts">
import type { AgentInstance } from "@/agents/types";
import type { Phase } from "@/conversations/phases";
import type { Conversation } from "@/conversations/types";
import type { NDKAgentLesson } from "@/events/NDKAgentLesson";
import { logger } from "@/utils/logger";
import { formatLessonsForAgent } from "@/utils/lessonFormatter";
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
// Retrieved lessons fragment - formats lessons from ProjectContext
interface RetrievedLessonsArgs {
    agent: AgentInstance;
    phase: Phase;
    conversation: Conversation;
    agentLessons: Map<string, NDKAgentLesson[]>;
}
⋮----
priority: 24, // Before learn-tool-directive
⋮----
// Debug: Log what's being passed in
⋮----
// Get only this agent's lessons
⋮----
return ""; // No lessons learned yet
⋮----
// Use the formatter to create formatted lessons
⋮----
// Add the lesson_learn tool reminder if lessons exist
⋮----
// Register the fragment
</file>

<file path="src/prompts/fragments/85-specialist-reasoning.ts">
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
/**
 * Reasoning fragment for specialist agents ONLY.
 * No conditionals, no isOrchestrator checks.
 */
⋮----
// Register the fragment
</file>

<file path="src/prompts/fragments/90-inventory-generation.ts">
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
// Helper function to convert git status codes to descriptions
function getStatusDescription(status: string): string
⋮----
interface InventoryGenerationArgs {
    repomixContent: string;
    focusFiles?: Array<{ path: string; status: string }>;
}
⋮----
interface ModuleGuideArgs {
    repomixContent: string;
    moduleName: string;
    modulePath: string;
    complexityReason: string;
}
⋮----
interface ComplexModulesExtractionArgs {
    content: string;
}
⋮----
// Register fragments
</file>

<file path="src/prompts/utils/llmMetadata.ts">
import { openRouterPricing } from "@/llm/pricing";
import type { CompletionResponse } from "@/llm/types";
import type { LLMMetadata } from "@/nostr/types";
import type { Message } from "multi-llm-ts";
⋮----
interface ResponseWithUsage {
    usage?: {
        promptTokens: number;
        completionTokens: number;
        totalTokens?: number;
    };
    experimental_providerMetadata?: {
        openrouter?: { usage?: { total_cost?: number } };
    };
    model?: string;
}
⋮----
export async function buildLLMMetadata(
    response: CompletionResponse,
    messages: Message[]
): Promise<LLMMetadata | undefined>
⋮----
// Convert CompletionResponse to ResponseWithUsage format
⋮----
export async function calculateCost(response: ResponseWithUsage, model: string): Promise<number>
⋮----
// Check if OpenRouter already calculated the cost
⋮----
// Calculate cost based on model pricing
⋮----
// Fallback: rough estimate based on typical pricing
</file>

<file path="src/services/mcp/__tests__/mcpInstaller.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import fs from "node:fs/promises";
import path from "node:path";
import os from "node:os";
import { 
    installMCPServerFromEvent, 
    isMCPToolInstalled, 
    getInstalledMCPEventIds,
    removeMCPServerByEventId 
} from "../mcpInstaller";
import { NDKMCPTool } from "@/events/NDKMCPTool";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Create a temporary directory for testing
⋮----
// Create .tenex directory
⋮----
// Create initial empty mcp.json
⋮----
// Clean up temp directory
⋮----
// Create mock MCP tool event
⋮----
// Install the tool
⋮----
// Verify it was installed
⋮----
// Install once
⋮----
// Try to install again
⋮----
// Should still only have one entry
⋮----
// Use the actual installer to add a tool with event ID
⋮----
// Add a manually installed tool without event ID
⋮----
// No eventId field
⋮----
// Install tools using the actual installer
⋮----
// Also manually add a tool without event ID using configService
⋮----
// No eventId
⋮----
// Install tools first
⋮----
// Now remove one
⋮----
// Check the result using configService
⋮----
// Should not throw
</file>

<file path="src/test-utils/mock-llm/scenarios/error-handling.ts">
import type { MockLLMScenario } from "../types";
⋮----
/**
 * Error handling scenarios for testing edge cases and failures
 */
⋮----
// Tool execution failure
⋮----
// Recovery after tool failure
⋮----
// Network timeout simulation
⋮----
streamDelay: 5000, // 5 second delay
⋮----
// Invalid tool arguments
⋮----
args: "{ invalid json }" // Intentionally malformed
⋮----
// LLM service error
⋮----
// Empty response handling
⋮----
content: "", // Empty content
toolCalls: [] // No tool calls
⋮----
// Multiple tool calls with mixed success
⋮----
// Infinite loop prevention
⋮----
// Phase transition failure
⋮----
suggestedPhase: "INVALID_PHASE", // Invalid phase
⋮----
// Concurrent execution conflict
⋮----
// Memory/context overflow simulation
⋮----
content: "A".repeat(10000), // Very large response
</file>

<file path="src/test-utils/mock-llm/scenarios/inventory-generation.ts">
import type { MockLLMScenario } from "../types";
import { PHASES } from "@/conversations/phases";
⋮----
/**
 * Inventory generation workflow scenario
 * Tests the complete flow of generating project inventory including:
 * - Initial request in CHAT phase
 * - Transitioning to EXECUTE phase
 * - Using generate_inventory tool
 * - Handling task progress updates
 * - Completing the workflow
 */
⋮----
// Initial chat phase - user asks to generate inventory
⋮----
// EXECUTE phase - Executor generates inventory
⋮----
// Handle inventory generation completion
⋮----
// Orchestrator handles completion
⋮----
// VERIFICATION phase - confirm inventory was created
⋮----
// Verification complete
⋮----
// Alternative flow: Inventory already exists
⋮----
// Error handling: Inventory generation fails
</file>

<file path="src/test-utils/mock-llm/scenarios/orchestrator-workflow.ts">
import type { MockLLMScenario } from "../types";
⋮----
/**
 * Complete orchestrator workflow scenario covering all phases:
 * CHAT -> PLAN -> EXECUTE -> VERIFICATION
 */
⋮----
// Initial chat phase - user asks to create a feature
⋮----
// Chat phase - gathering requirements
⋮----
// Orchestrator transitions to PLAN phase
⋮----
// PLAN phase - Planner creates implementation plan
⋮----
// Planner completes planning
⋮----
// Orchestrator transitions to EXECUTE phase
⋮----
// EXECUTE phase - Executor implements the feature
⋮----
// Executor creates multiple files
⋮----
// Executor runs tests
⋮----
// Executor completes implementation
⋮----
// Orchestrator transitions to VERIFICATION
⋮----
// VERIFICATION phase - final checks
⋮----
// Final orchestrator completion
</file>

<file path="src/test-utils/mock-llm/index.ts">
import { MockLLMService } from "./MockLLMService";
import type { MockLLMConfig, MockLLMScenario } from "./types";
import type { ToolCall } from "@/llm/types";
import { allScenarios } from "./scenarios";
⋮----
/**
 * Create a mock LLM service with predefined scenarios
 */
export function createMockLLMService(
    scenarios?: string[] | MockLLMScenario[],
    config?: Partial<MockLLMConfig>
): MockLLMService
⋮----
// Load by name
⋮----
// Direct scenario object
⋮----
/**
 * Create a simple mock that always returns the same response
 */
export function createSimpleMock(
    content: string,
    toolCalls?: ToolCall[]
): MockLLMService
⋮----
/**
 * Create a mock that simulates errors
 */
export function createErrorMock(error: Error): MockLLMService
</file>

<file path="src/test-utils/mocks/events.ts">
import { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
export const createConversationEvent = (
    id: string,
    content = "",
    title = ""
): NDKEvent =>
⋮----
export const createReplyEvent = (id: string, content: string): NDKEvent =>
⋮----
export const createAgentMessageEvent = (
    id: string,
    agentPubkey: string,
    content: string
): NDKEvent =>
</file>

<file path="src/tools/__tests__/executor.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { ToolExecutor, createToolExecutor } from "../executor";
import type { Tool } from "../core";
import type { ExecutionContext } from "../types";
import { createMockExecutionContext } from "@/test-utils";
</file>

<file path="src/tools/__tests__/tool-helpers.test.ts">
import { describe, expect, it } from "bun:test";
import { z } from "zod";
import { defineToolParameters, createToolDefinition } from "../types";
import type { ExecutionContext } from "@/agents/execution/types";
import { createMockExecutionContext } from "@/test-utils";
⋮----
// Test parameter validation
</file>

<file path="src/tools/__tests__/zod-schema.test.ts">
import { describe, it, expect } from "bun:test";
import { z } from "zod";
import { createZodSchema, mcpSchemaToZod, ToolSchemas } from "../zod-schema";
import type { ExecutionContext } from "../types";
⋮----
// Test valid input
⋮----
// Test invalid input
⋮----
// Should accept without optional field
⋮----
// Should accept with optional field
⋮----
// Should fail without required field
⋮----
const validPubkey = "a".repeat(64); // 64 hex chars
</file>

<file path="src/tools/implementations/__tests__/agents-discover.test.ts">
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { discoverAgents } from '../agents-discover';
import { getNDK } from '@/nostr/ndkClient';
import type NDK from '@nostr-dev-kit/ndk';
import type { NDKEvent } from '@nostr-dev-kit/ndk';
⋮----
// Arrange
⋮----
// Act
⋮----
// Assert
⋮----
// Arrange
⋮----
// Act
⋮----
// Assert
⋮----
// Arrange
⋮----
// Act
⋮----
// Assert
</file>

<file path="src/tools/implementations/__tests__/claude_code.test.ts">
import { describe, it, expect } from "bun:test";
import { claudeCode } from "../claude_code";
</file>

<file path="src/tools/implementations/__tests__/delegate-simple.test.ts">
import { describe, it, expect } from "bun:test";
import { delegateTool } from "../delegate";
⋮----
// Validate single recipient as string
⋮----
// Should transform single string to array
⋮----
// Validate array of recipients
⋮----
// Missing recipients
⋮----
// Missing fullRequest
⋮----
// Empty object
⋮----
// Empty array should be valid structurally (will fail in execution)
</file>

<file path="src/tools/implementations/__tests__/mcp-discover.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { mcpDiscover } from "../mcp-discover";
import { getNDK } from "@/nostr";
import { NDKMCPTool } from "@/events/NDKMCPTool";
import type NDK from "@nostr-dev-kit/ndk";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import type { ExecutionContext } from "../../types";
⋮----
// Mock dependencies
⋮----
// Create mock NDKMCPTool events
⋮----
// Override the encode method to avoid accessing NDK internals
⋮----
// Check that markdown contains the expected content
⋮----
// Check header
⋮----
// Check Database Manager (should be first due to newer timestamp)
⋮----
// Check Git Helper (should be second)
⋮----
// Check installation instructions
⋮----
// Verify the filter used
⋮----
// Generate valid hex ID
⋮----
// Check that we have exactly 5 tool sections
</file>

<file path="src/tools/implementations/__tests__/nostr-projects-empty-args.test.ts">
import { nostrProjectsTool } from "../nostr-projects";
import { z } from "zod";
⋮----
// The schema should allow an empty object since pubkey is optional
</file>

<file path="src/tools/implementations/__tests__/writeContextFile.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock, spyOn } from "bun:test";
import { writeContextFileTool } from "../writeContextFile";
import { createTempDir, cleanupTempDir } from "@/test-utils";
import { writeFileSync, readFileSync, existsSync, mkdirSync, chmodSync } from "node:fs";
⋮----
import type { ToolContext } from "@/tools/types";
⋮----
// Mock logger to avoid console output during tests
⋮----
// Mock Nostr-related modules
⋮----
// Mock NDKArticle
⋮----
// Store a reference to this instance in mockNDKArticle
⋮----
// Override property definitions to capture values
⋮----
get()
set(value: string | undefined)
⋮----
set(value: number | undefined)
⋮----
// Reset mocks
⋮----
// Reset reply mock
⋮----
// Reset publish and sign implementations
⋮----
// Create mock conversation manager
⋮----
// Create test context
⋮----
// Verify file was written to correct location
⋮----
// Create context directory and existing file
⋮----
// Update mock to include file in readFiles
⋮----
// Verify file was updated
⋮----
// Create context directory and existing file
⋮----
// Mock has empty readFiles by default
⋮----
// Verify file was not modified
⋮----
// Verify file was created
⋮----
// Create existing file
⋮----
// Mock conversation with no metadata
⋮----
// Verify directory was created
⋮----
// Create a file with the same name as the directory we want to create
⋮----
// Create context directory
⋮----
// Make directory read-only (no write permission)
⋮----
// Restore permissions
⋮----
// Verify NDKArticle properties were set
⋮----
// Verify article methods were called
⋮----
// Verify article was published
⋮----
// Verify reply was created
⋮----
// Verify reply content and timestamp were set
⋮----
// Verify reply was signed and published
⋮----
// Verify article was published
⋮----
// Verify reply was NOT created
⋮----
// Make reply.publish throw an error
⋮----
// File write should still succeed
⋮----
// Verify article was published
⋮----
// Verify reply was attempted
⋮----
// Make publish throw an error
⋮----
// Tool should still succeed
⋮----
// File should have been written
⋮----
// Make sign throw an error
⋮----
// Tool should still succeed (error is logged but not thrown)
⋮----
// File should have been written
⋮----
// Create existing file
⋮----
// Mock with empty readFiles (default)
⋮----
// Should still work for new files
⋮----
// Verify file was created
⋮----
// Verify file was created with the long name
</file>

<file path="src/tools/implementations/claude_code.ts">
import { ClaudeTaskOrchestrator } from "@/claude/orchestrator";
import { TaskPublisher } from "@/nostr/TaskPublisher";
import { getNDK } from "@/nostr/ndkClient";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { z } from "zod";
import { createToolDefinition } from "../types";
⋮----
/**
 * Strips thinking blocks from content.
 * Removes everything between <thinking> and </thinking> tags.
 */
function stripThinkingBlocks(content: string): string
⋮----
interface ClaudeCodeOutput {
    sessionId?: string;
    totalCost: number;
    messageCount: number;
    duration: number;
    response: string;
}
⋮----
// Strip thinking blocks from prompts
⋮----
// Log if we stripped any thinking blocks
⋮----
// Get the current Claude session ID from the conversation's agent state
⋮----
// Create instances for Claude Code execution
⋮----
// Create abort controller for this execution
⋮----
// Execute Claude Code through the orchestrator with cleaned prompts
⋮----
// Update the Claude session ID in the conversation's agent state
⋮----
// Return the result
</file>

<file path="src/tools/implementations/nostr-projects.ts">
import { getNDK } from "@/nostr";
import { getProjectContext } from "@/services/ProjectContext";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { z } from "zod";
import type { Tool } from "../types";
import { createZodSchema } from "../types";
import { NDKArticle, NDKUser } from "@nostr-dev-kit/ndk";
⋮----
// Define schema that gracefully handles no arguments, empty strings, or optional pubkey
// This handles cases where LLMs send "", {}, or {pubkey: "..."}
⋮----
}).partial(); // Make all properties optional, effectively allowing empty object
⋮----
interface NostrProjectsInput {
    pubkey?: string;
}
⋮----
interface NostrProjectsOutput {
    projects: Array<{
        id: string;
        title?: string;
        description?: string;
        website?: string;
        repository?: string;
        image?: string;
        online: boolean;
        agents?: Record<string, string>;
        pubkey: string;
        date?: number;
        specs: Array<{
            title?: string;
            summary?: string;
            id: string;
            date?: number;
        }>;
    }>;
    summary: {
        totalProjects: number;
        onlineProjects: number;
        offlineProjects: number;
        totalSpecDocuments: number;
    };
}
⋮----
// Determine which pubkey to use
⋮----
// Try to get project owner's pubkey from context
⋮----
// Calculate 1 minute ago timestamp for online status check
⋮----
// Fetch both kinds of events in parallel
⋮----
// Fetch 31933 events (NDKProject)
⋮----
// Fetch 24010 events (project status - online agents)
// Only get status events from the last minute to determine if online
⋮----
kinds: [24010 as any],  // Cast to any since NDKKind doesn't include 24010 yet
⋮----
// Build a map of online agents by project (keyed by project tagId)
⋮----
// Process status events to find online agents
⋮----
// Get the project reference from the "a" tag (this identifies which project the status is for)
⋮----
// Get agent tags from the 24010 event
⋮----
// agent tag format: ["agent", "<pubkey>", "<slug>"]
⋮----
// Convert pubkey to npub format
⋮----
// Store agents for this specific project using its tagId as the key
⋮----
// Once we have the list of projects, fetch spec documents that tag them
⋮----
// Create array of project tag IDs for fetching articles
⋮----
// Fetch NDKArticles (kind 30023) that tag these projects
⋮----
// Process articles
⋮----
// Get project references from the article's tags (for internal filtering only)
⋮----
// Get summary or first 300 bytes of content
⋮----
_projectRefs: projectRefs, // Keep for internal filtering but prefix with underscore
⋮----
// Process project events (31933)
⋮----
// Get the project's tagId for matching with status events and articles
⋮----
// Check if this project has online agents using its tagId
⋮----
// Get the encoded project ID with nostr: prefix
⋮----
// Find spec articles for this project
⋮----
.map(({ _projectRefs, ...article }) => article); // Remove internal _projectRefs field
⋮----
// Sort projects by creation time (newest first)
</file>

<file path="src/tools/implementations/readPath.ts">
import { readFile } from "node:fs/promises";
import { stat, readdir } from "node:fs/promises";
import type { Tool } from "../types";
import { createZodSchema } from "../types";
import { resolveAndValidatePath } from "../utils";
import { z } from "zod";
import { formatAnyError } from "@/utils/error-formatter";
⋮----
type ReadPathInput = z.infer<typeof readPathSchema>;
type ReadPathOutput = string;
⋮----
/**
 * Read path tool - effect tool that reads files or directories from filesystem
 * Performs I/O side effects
 */
⋮----
// Resolve path and ensure it's within project
⋮----
// Check if path is a directory first
⋮----
// Get directory contents
⋮----
// Track file read in conversation metadata if path starts with context/
⋮----
// Only add if not already tracked
⋮----
// If it's an EISDIR error that we somehow missed, provide helpful guidance
⋮----
// If we can't read the directory, fall back to the original error
</file>

<file path="src/tools/implementations/writeContextFile.ts">
import { mkdir, writeFile, access } from "node:fs/promises";
⋮----
import { z } from "zod";
import type { Tool } from "../types";
import { createZodSchema } from "../types";
import { NDKArticle } from "@nostr-dev-kit/ndk";
import { getNDK } from "@/nostr";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { getProjectContext } from "@/services";
⋮----
interface WriteContextFileInput {
    filename: string;
    content: string;
    title: string;
    changelog?: string;
}
⋮----
interface WriteContextFileOutput {
    message: string;
}
⋮----
// Agent role check: Only project-manager should use this tool
// This is enforced at the agent configuration level
⋮----
// Extract just the filename from any path
// If given ../../context/TEST.md or TEST.md, just use TEST.md
⋮----
// Only allow markdown files
⋮----
// Construct the full path
⋮----
// Check if this file was recently read from persisted conversation metadata
⋮----
// Check if file exists
⋮----
// File doesn't exist, allow creation
⋮----
// If file exists and wasn't recently read, deny access
⋮----
// Ensure context directory exists
⋮----
// Write the file
⋮----
// Publish NDKArticle for this context file update
⋮----
// Use the filename without .md extension as the dTag
⋮----
// Set article properties
⋮----
// Tag the article with the project
⋮----
// Sign with the agent's signer
⋮----
// If changelog is provided, create a NIP-22 reply
⋮----
// Create a reply to the spec article event
⋮----
// Sign and publish the reply
⋮----
// Log error but don't fail the tool execution
</file>

<file path="src/tools/types.ts">
/**
 * Simplified tool system for TENEX
 */
⋮----
import { z } from "zod";
import type { ParameterSchema, Validated, ToolError, Result, Tool } from "./core";
import { createZodSchema } from "./zod-schema";
import type { ExecutionContext } from "@/agents/execution/types";
⋮----
// Re-export core types
⋮----
// Re-export unified ExecutionContext from agents
⋮----
/**
 * Helper function to create a tool's parameters object directly from a Zod schema
 */
export function defineToolParameters<T>(schema: z.ZodType<T>): ParameterSchema<T>
⋮----
/**
 * Helper function to create a complete tool definition with less boilerplate
 */
export function createToolDefinition<Input, Output>(config: {
    name: string;
    description: string;
    schema: z.ZodType<Input>;
    promptFragment?: string;
    execute: (
        input: Validated<Input>,
        context: ExecutionContext
)
</file>

<file path="src/tools/zod-schema.ts">
/**
 * Zod-based schema system for TENEX tools
 */
⋮----
import { z } from "zod";
import type { ParameterSchema, SchemaShape, Validated, ValidationError, Result } from "./core";
⋮----
// MCP schema type definitions
interface MCPPropertyDefinition {
    type?: "string" | "number" | "integer" | "boolean" | "array" | "object";
    description?: string;
    enum?: string[];
    minLength?: number;
    maxLength?: number;
    minimum?: number;
    maximum?: number;
    items?: MCPPropertyDefinition;
    properties?: Record<string, MCPPropertyDefinition>;
    required?: string[];
    minItems?: number;
    maxItems?: number;
}
⋮----
interface MCPSchema {
    properties?: Record<string, MCPPropertyDefinition>;
    required?: string[];
}
⋮----
/**
 * Convert a Zod schema to our SchemaShape format
 */
function zodToSchemaShape(schema: z.ZodType<unknown>, isOptional = false): SchemaShape
⋮----
// Handle undefined/null/void schemas
⋮----
// Handle union schemas (like z.undefined().or(z.null()))
⋮----
// If it's a union of undefined/null/void, treat it as no parameters
⋮----
// Otherwise, use the first option
⋮----
// For enum values, we need to check if it's a ZodEnum
⋮----
// Get min/max from the schema definition more safely
⋮----
// Fallback for unknown types
⋮----
/**
 * Create a ParameterSchema from a Zod schema
 */
export function createZodSchema<T>(schema: z.ZodType<T>): ParameterSchema<T>
⋮----
// Extract the first error for simplicity
⋮----
/**
 * Helper function to create schemas with descriptions
 */
export function withDescription<T extends z.ZodType<unknown>>(schema: T, description: string): T
⋮----
/**
 * Common schema patterns for tools
 */
⋮----
/**
     * File path schema with validation
     */
⋮----
/**
     * Command schema with safety checks
     */
⋮----
/**
     * Phase schema
     */
⋮----
// Import here to avoid circular dependencies
⋮----
/**
     * Agent pubkey schema
     */
⋮----
/**
     * Non-empty string
     */
⋮----
/**
     * Optional field helper
     */
⋮----
/**
     * Array with at least one element
     */
⋮----
/**
 * Convert MCP tool input schema to Zod schema
 */
export function mcpSchemaToZod(mcpSchema: MCPSchema): z.ZodType<unknown>
⋮----
/**
 * Convert a single MCP property definition to Zod schema
 */
function mcpPropertyToZod(propDef: MCPPropertyDefinition): z.ZodType<unknown>
⋮----
/**
 * Type inference helper for Zod schemas
 */
export type InferZodSchema<T extends z.ZodType<unknown>> = z.infer<T>;
</file>

<file path="src/utils/__tests__/cli-error.test.ts">
import { describe, expect, it, mock, spyOn } from "bun:test";
import { handleCliError, handleCliWarning } from "../cli-error";
import { logger } from "../logger";
</file>

<file path="src/utils/__tests__/conversationFetcher.test.ts">
import { describe, test, expect, mock, beforeEach, spyOn } from "bun:test";
import { fetchConversation } from "../conversationFetcher";
import type NDK from "@nostr-dev-kit/ndk";
import { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Mock the services module before importing anything that uses it
⋮----
// Create mock events
⋮----
// Create mock NDK instance
⋮----
// The result should differentiate between human and agent
// We can't test colors directly but we can verify the content is there
expect(result).toContain("This is the root message"); // Human message
expect(result).toContain("This is a reply"); // Agent message
⋮----
olderEvent.created_at = 1234567880; // Earlier timestamp
⋮----
// Verify events appear in tree structure (root first, then replies)
⋮----
// Root should appear first
⋮----
// Other events should appear after root (as replies in the tree)
⋮----
// Should show truncated pubkey when profile fetch fails
</file>

<file path="src/utils/__tests__/lessonFormatter.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { formatLessonsForAgent } from "../lessonFormatter";
import type { NDKAgentLesson } from "@/events/NDKAgentLesson";
⋮----
// Check that Lesson 3 (newest) comes first
⋮----
// Should include newest lessons (59, 58, etc)
⋮----
// Should not include oldest lessons
⋮----
expect(doublNewlines).toBeGreaterThanOrEqual(2); // At least 2 separators for 3 lessons
</file>

<file path="src/utils/__tests__/logger.test.ts">
import { describe, expect, it, beforeEach, afterEach, spyOn } from "bun:test";
import {
    configureLogger,
    parseModuleVerbosity,
    logInfo,
    logError,
    logSuccess,
    logWarning,
    logDebug,
    AgentLogger,
    ScopedLogger,
    logger,
    type VerbosityLevel,
    type LogModule,
} from "../logger";
⋮----
expect(consoleLogSpy).toHaveBeenCalledTimes(3); // info, success, debug
expect(consoleWarnSpy).toHaveBeenCalledTimes(1); // warning
expect(consoleErrorSpy).toHaveBeenCalledTimes(1); // error
⋮----
expect(consoleLogSpy).toHaveBeenCalledTimes(3); // info, success, debug
expect(consoleWarnSpy).toHaveBeenCalledTimes(1); // warning
expect(consoleErrorSpy).toHaveBeenCalledTimes(1); // error
</file>

<file path="src/utils/__tests__/string.test.ts">
import { describe, it, expect } from "bun:test";
import { toKebabCase } from "../string";
</file>

<file path="src/utils/__tests__/validation.test.ts">
import { describe, it, expect } from "bun:test";
import {
    isValidSlug,
    isMarkdownFile,
    isValidPubkey,
    isValidNpub,
    isAbsolutePath,
    isValidUuid
} from "../validation";
⋮----
expect(isValidPubkey("g".repeat(64))).toBe(false); // Invalid hex char
⋮----
expect(isValidNpub("npub1")).toBe(false); // Too short
expect(isValidNpub("invalid" + "a".repeat(57))).toBe(false); // Wrong prefix
expect(isValidNpub("npub1" + "a".repeat(57))).toBe(false); // Wrong length
expect(isValidNpub("npub1" + "a".repeat(59))).toBe(false); // Too long
⋮----
// These will be recognized on all platforms
⋮----
expect(isValidUuid("6BA7B810-9DAD-41D1-80B4-00C04FD430C8")).toBe(true); // Case insensitive
⋮----
expect(isValidUuid("550e8400-e29b-11d4-a716-446655440000")).toBe(false); // v1, not v4
expect(isValidUuid("550e8400-e29b-41d4-a716-44665544000")).toBe(false); // Too short
expect(isValidUuid("550e8400-e29b-41d4-a716-4466554400000")).toBe(false); // Too long
expect(isValidUuid("550e8400e29b41d4a716446655440000")).toBe(false); // No hyphens
</file>

<file path="src/utils/git/gitignore.ts">
import { logger } from "@/utils/logger";
⋮----
/**
 * Ensures .tenex is in the project's .gitignore file
 */
export async function ensureTenexInGitignore(projectPath: string): Promise<void>
⋮----
// Check if .gitignore exists
⋮----
// .gitignore doesn't exist, we'll create it
⋮----
// Check if .tenex is already in .gitignore
⋮----
// Add .tenex to .gitignore
</file>

<file path="src/utils/git/initializeGitRepo.ts">
import { exec } from "node:child_process";
⋮----
import { promisify } from "node:util";
import { logger } from "@/utils/logger";
⋮----
/**
 * Check if a directory is a git repository (has its own .git directory)
 */
export async function isGitRepository(projectPath: string): Promise<boolean>
⋮----
/**
 * Initialize a git repository in the given directory
 */
export async function initializeGitRepository(projectPath: string): Promise<void>
</file>

<file path="src/utils/cli-config-scope.ts">
import { configService } from "@/services/ConfigService";
⋮----
export interface ConfigScope {
    basePath: string;
    isGlobal: boolean;
    isProject: boolean;
    error?: string;
}
⋮----
/**
 * Resolves the configuration scope for CLI commands
 * Consolidates the logic for determining whether to use global or project config
 * 
 * @param options Command line options with optional project/global flags
 * @param currentPath The current working directory path
 * @returns ConfigScope object with resolved path and scope information
 */
export async function resolveConfigScope(
    options: { project?: boolean; global?: boolean },
    currentPath: string = process.cwd()
): Promise<ConfigScope>
⋮----
// Check for conflicting flags
⋮----
// Determine if we're in a project directory (check for main config file)
⋮----
// Handle explicit flags
⋮----
// Default behavior: use project config if available, otherwise global
⋮----
/**
 * Helper to format config scope for display
 */
export function formatConfigScope(scope: ConfigScope): string
⋮----
/**
 * Check if the current directory is a TENEX project
 * @param projectPath - The path to check (defaults to current working directory)
 * @returns True if the directory contains a TENEX project configuration
 */
export async function isProjectDirectory(projectPath: string = process.cwd()): Promise<boolean>
⋮----
/**
 * Get the appropriate configuration path based on project detection
 * @param projectPath - The path to check (defaults to current working directory)
 * @returns The configuration path (project path if in a project, global path otherwise)
 */
export async function getConfigPath(projectPath: string = process.cwd()): Promise<string>
⋮----
/**
 * Determine whether to use project or global configuration based on flags and project detection
 * @param options - Command options with optional global and project flags
 * @param projectPath - The path to check (defaults to current working directory)
 * @returns Configuration scope information
 * @deprecated Use resolveConfigScope instead
 */
export async function determineConfigScope(
    options: { global?: boolean; project?: boolean },
    projectPath: string = process.cwd()
): Promise<
</file>

<file path="src/utils/error-formatter.ts">
import type { ToolError } from "@/tools/types";
⋮----
/**
 * Comprehensive error formatter that handles all error types in the codebase
 * Consolidates error formatting logic from various parts of the system
 */
export function formatAnyError(error: unknown): string
⋮----
// Handle null/undefined
⋮----
// Handle strings
⋮----
// Handle Error instances
⋮----
// Handle objects
⋮----
// Check for ToolError structure (with type guard)
⋮----
// Check for simple message property
⋮----
// Try to extract meaningful properties from the error object
⋮----
// Common error properties
⋮----
// If we found specific properties, use them
⋮----
// Otherwise, try to stringify the object
⋮----
// Don't return huge JSON strings
⋮----
// Fallback to String conversion
⋮----
/**
 * Format ToolError objects into human-readable strings
 */
export function formatToolError(error: ToolError): string
⋮----
// If the field is empty and message is just "Required", make it clearer
⋮----
// This should never happen with proper ToolError types
</file>

<file path="src/utils/file-persistence.ts">
import { logger } from "./logger";
⋮----
/**
 * Write JSON data to a file with consistent formatting
 */
export async function writeJsonFile<T>(filePath: string, data: T): Promise<void>
⋮----
/**
 * Read and parse JSON data from a file
 */
export async function readJsonFile<T>(filePath: string): Promise<T>
⋮----
/**
 * Create directory recursively if it doesn't exist
 */
export async function ensureDirectory(dirPath: string): Promise<void>
⋮----
/**
 * Handle persistence errors consistently
 */
export function handlePersistenceError(operation: string, error: unknown): void
⋮----
/**
 * Check if a file exists
 */
export async function fileExists(filePath: string): Promise<boolean>
</file>

<file path="src/utils/formatting.ts">
import chalk from "chalk";
⋮----
/**
 * Format duration in human-readable format
 * @param ms - Duration in milliseconds
 * @returns Formatted duration string
 */
export function formatDuration(ms: number): string
⋮----
// Handle invalid input
⋮----
// Round to nearest integer to avoid floating point issues
⋮----
// Handle edge case where rounding seconds results in 60
⋮----
/**
 * Format markdown text with chalk styling
 */
export function formatMarkdown(text: string): string
⋮----
/**
 * Colorize JSON string with chalk styling
 */
export function colorizeJSON(json: string): string
</file>

<file path="src/utils/process.ts">
import { logger } from "@/utils/logger";
⋮----
/**
 * Handler function called during graceful shutdown
 */
export type ShutdownHandler = (signal: string) => Promise<void>;
⋮----
/**
 * Sets up graceful shutdown handlers for various termination signals
 * @param shutdownHandler - Async function to handle cleanup during shutdown
 * @description Handles SIGTERM, SIGINT, SIGHUP signals and uncaught exceptions/rejections
 */
export function setupGracefulShutdown(shutdownHandler: ShutdownHandler): void
⋮----
const shutdown = async (signal: string): Promise<void> =>
⋮----
// Handle various termination signals
⋮----
// Handle uncaught errors
</file>

<file path="src/utils/project-detection.ts">
import { configService } from "@/services/ConfigService";
⋮----
/**
 * Check if the current directory is a TENEX project
 * @param projectPath - The path to check (defaults to current working directory)
 * @returns True if the directory contains a TENEX project configuration
 */
export async function isProjectDirectory(projectPath: string = process.cwd()): Promise<boolean>
⋮----
/**
 * Get the appropriate configuration path based on project detection
 * @param projectPath - The path to check (defaults to current working directory)
 * @returns The configuration path (project path if in a project, global path otherwise)
 */
export async function getConfigPath(projectPath: string = process.cwd()): Promise<string>
⋮----
/**
 * Determine whether to use project or global configuration based on flags and project detection
 * @param options - Command options with optional global and project flags
 * @param projectPath - The path to check (defaults to current working directory)
 * @returns Configuration scope information
 */
export async function determineConfigScope(
    options: { global?: boolean; project?: boolean },
    projectPath: string = process.cwd()
): Promise<
⋮----
// Validate conflicting flags
⋮----
// Determine scope based on flags or auto-detection
⋮----
// Default: use project if in one, otherwise global
</file>

<file path="src/utils/string.ts">
/**
 * Converts a string to kebab-case format
 * @param str - The input string to convert
 * @returns The kebab-case formatted string
 * @example
 * toKebabCase("HelloWorld") // "hello-world"
 * toKebabCase("hello_world") // "hello-world"
 * toKebabCase("Hello World") // "hello-world"
 */
export function toKebabCase(str: string): string
</file>

<file path="src/utils/validation.ts">
/**
 * Centralized validation utilities for common patterns
 */
⋮----
/**
 * Validates if a string is a valid slug format (alphanumeric with hyphens and underscores)
 */
export function isValidSlug(name: string): boolean
⋮----
/**
 * Validates if a filename has a markdown extension
 */
export function isMarkdownFile(filename: string): boolean
⋮----
/**
 * Validates if a string is a valid Nostr pubkey (64 hex characters)
 */
export function isValidPubkey(pubkey: string): boolean
⋮----
/**
 * Validates if a string is a valid Nostr npub (starts with npub1)
 */
export function isValidNpub(npub: string): boolean
⋮----
/**
 * Validates if a path is absolute
 */
export function isAbsolutePath(path: string): boolean
⋮----
/**
 * Validates if a string is a valid UUID v4
 */
export function isValidUuid(uuid: string): boolean
</file>

<file path="tests/e2e/state-persistence.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import {
    setupE2ETest,
    cleanupE2ETest,
    createConversation,
    executeConversationFlow,
    getConversationState,
    assertAgentSequence,
    assertPhaseTransitions,
    assertToolCalls,
    type E2ETestContext
} from "./test-harness";
import { ConversationManager } from "@/conversations/ConversationManager";
import { AgentRegistry } from "@/agents/AgentRegistry";
import type { MockLLMResponse } from "@/test-utils/mock-llm/types";
import path from "path";
⋮----
// Enable debug logging
⋮----
// Define persistence test scenarios
⋮----
// Initial orchestrator routing
⋮----
// Executor initial response
⋮----
// Orchestrator routes to planner
⋮----
// Planner creates plan
⋮----
// Orchestrator routes to executor for build
⋮----
// Executor implements (first part) - stop the flow here for persistence test
⋮----
// For recovery test - executor continues after crash
⋮----
// Default fallback
⋮----
// Step 1: Create conversation and execute initial workflow
⋮----
// Execute workflow up to BUILD phase
⋮----
maxIterations: 6, // Stop after reaching BUILD phase
⋮----
// Verify we reached BUILD phase
⋮----
// Check if agentContexts exists before checking size
⋮----
// It might be serialized as an object or array
⋮----
// Verify phase transitions occurred
⋮----
// Step 3: Simulate system restart by creating new instances
⋮----
// Step 4: Load conversation from persistence
⋮----
// Verify recovered agent contexts
⋮----
// Step 5: Continue workflow after recovery using the new conversation manager
// Create updated context with new manager
⋮----
// Add response for continuation
⋮----
// Execute one more step to verify recovery works
⋮----
// Verify continuation worked
⋮----
// Verify complete tool sequence
⋮----
// Create multiple conversations
⋮----
// Execute initial phases for all conversations in parallel
⋮----
// Add specific routing for each task
⋮----
// Verify all conversations progressed
⋮----
// Get states for all conversations
⋮----
// Verify all have progressed past initial state
⋮----
// Verify persistence files exist
⋮----
// Should have one file per conversation (if using file persistence)
// Note: TestPersistenceAdapter might store differently
⋮----
// Verify each conversation file exists and contains valid data
⋮----
// Simulate restart and recover all conversations
⋮----
// Load and verify all conversations
⋮----
// Create conversation
⋮----
// Add specific response for analysis
⋮----
// Start execution
⋮----
// Wait a moment to accumulate execution time
⋮----
// Get state before restart
⋮----
// Simulate restart
⋮----
// Load conversation
⋮----
// Verify metrics are preserved
⋮----
// Continue execution with updated context
⋮----
// Add continuation response
⋮----
// Verify metrics continue to accumulate
⋮----
// Create conversation
⋮----
// Execute initial phase
⋮----
// Make persistence directory read-only to simulate write error
⋮----
// Note: This test is simplified because filesystem permissions are complex
// In a real scenario, we would test various failure modes:
// - Disk full
// - Permission denied
// - Corrupted JSON files
// - Network failures for remote persistence
⋮----
// Instead, we'll test recovery from corrupted data
⋮----
// Try to corrupt the persisted file (if it exists)
⋮----
// File might not exist with TestPersistenceAdapter
⋮----
// Attempt to load with new manager
⋮----
// Should handle corrupted file gracefully
⋮----
// The current implementation might return null or throw
// This test verifies the system doesn't crash completely
⋮----
// Expected behavior - unable to recover from corrupted data
⋮----
// If recovery succeeded (e.g., using in-memory adapter), verify it's in a valid state
⋮----
// Create conversation
⋮----
// Execute multiple interactions
⋮----
// Get state before restart
⋮----
// Simulate restart
⋮----
// Load conversation
⋮----
// Verify history is preserved in correct order
⋮----
// Check that history entries match
⋮----
// Tool calls should also match if present
⋮----
// Verify execution trace matches history
// Each agent execution should correspond to history entries
</file>

<file path=".npmignore">
# Source maps (these add a lot of weight)
*.map
**/*.map

# Keep source files (needed for Bun runtime)
# src/ is NOT ignored

# Exclude test files from src and dist
**/test-utils
**/__tests__
*.test.ts
*.test.js
*.spec.ts  
*.spec.js
src/test-utils/
dist/test-utils/

# Configuration files  
# Keep tsconfig.json (needed for Bun runtime)
tsconfig.build.json
.eslintrc*
.prettierrc*
biome.json

# Development files
scripts/
tests/

# Exclude all test files (remove from both sections for clarity)

# Build artifacts
*.tsbuildinfo

# Documentation
*.md
!README.md
!LICENSE

# Git
.git/
.gitignore

# Dependencies
node_modules/

# IDE
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Coverage
coverage/
.nyc_output/

# Local config
.env
.env.local
.env.*.local

# Temporary files
tmp/
temp/
</file>

<file path=".repomixignore">
documentation
</file>

<file path="CLEANUP_COMPLETE.md">
# Cleanup Complete! ✅

## What We Actually Accomplished

### Clean Separation - NO MORE `isOrchestrator` Checks!

We now have properly separated fragments with **ZERO conditionals**:

#### Specialist Fragments (no conditionals):
- `specialist-identity.ts` - Identity, role, and domain expert guidelines
- `specialist-tools.ts` - All tools (agent + MCP) listing
- `specialist-reasoning.ts` - Thinking tag format
- `specialist-available-agents.ts` - Coworkers they can hand off to
- `specialist-completion-guidance.ts` - When to use complete()

#### Orchestrator Fragments (no conditionals):
- `orchestrator-identity.ts` - Minimal identity
- `orchestrator-reasoning.ts` - Routing analysis format
- `orchestrator-routing.ts` - Detailed routing instructions
- `orchestrator-available-agents.ts` - Agents to route to

#### Shared/Context Fragments:
- `phase-definitions.ts` - Phase descriptions (both use)
- `retrieved-lessons.ts` - Past lessons (both use)
- `project.ts`, `project-md.ts` - Project context
- `phase.ts`, `phase-context.ts` - Phase management
- `voice-mode.ts`, `referenced-article.ts` - Conditional context

### The Key Achievement

**ALL agent-type logic is now in `systemPromptBuilder.ts`:**

```typescript
// Clean, clear logic at the builder level
if (agent.isOrchestrator) {
    systemPromptBuilder
        .add("orchestrator-identity", { ... })
        .add("orchestrator-reasoning", {})
        .add("orchestrator-available-agents", { ... })
        .add("orchestrator-routing-instructions", {});
} else {
    systemPromptBuilder
        .add("specialist-identity", { ... })
        .add("specialist-reasoning", {})
        .add("specialist-tools", { ... })
        .add("specialist-available-agents", { ... });
}
```

### Files Deleted (Good Riddance!)
- `agentFragments.ts` - Had conditionals, redundant
- `available-agents.ts` - Had conditionals, replaced with two clean fragments
- `agent-completion-guidance.ts` - Had conditionals, replaced with specialist-only
- All the "consolidated" mess I initially created

### Verification
```bash
# Check for any remaining isOrchestrator conditionals in fragments
grep -r "isOrchestrator" src/prompts/fragments/*.ts
# Result: No matches found ✅

# Build status
npm run build
# Result: ✅ Build completed successfully!
```

## The Result

From a mess of scattered conditionals and redundant fragments to:
- **19 clean, single-purpose fragments**
- **Zero conditionals in fragments**
- **Clear separation**: specialist vs orchestrator vs shared
- **All logic at the right level**: builder decides what to include

The fragment system is now actually maintainable and understandable!
</file>

<file path="CONSOLIDATION_COMPLETE.md">
# Fragment Consolidation Complete

## What Was Done

Successfully consolidated the prompt fragment system from 20 files down to a cleaner, more maintainable structure.

### Fragments Consolidated

#### 1. **agent-identity.ts** (NEW)
Consolidated these redundant fragments:
- `agent-common.ts` - Basic identity building
- `expertise-boundaries.ts` - Specialist limitations
- `domain-expert-guidelines.ts` - Advisory role guidelines
- Parts of `agentFragments.ts` - Identity section

#### 2. **available-tools.ts** (NEW)
Consolidated these tool-related fragments:
- `agent-tools.ts` - Agent-specific tools
- `mcp-tools.ts` - MCP server tools
- `tool-use.ts` - General tool usage guidelines

#### 3. **reasoning-instructions.ts** (NEW)
Consolidated these reasoning fragments:
- `agent-reasoning.ts` - General agent reasoning
- `orchestrator-reasoning.ts` - Routing-specific reasoning
- `expert-reasoning.ts` - Domain expert reasoning

### Files Deleted
- `src/prompts/fragments/agent-common.ts`
- `src/prompts/fragments/expertise-boundaries.ts`
- `src/prompts/fragments/domain-expert-guidelines.ts`
- `src/prompts/fragments/agent-tools.ts`
- `src/prompts/fragments/mcp-tools.ts`
- `src/prompts/fragments/tool-use.ts`
- `src/prompts/fragments/agent-reasoning.ts`

### Key Improvements

1. **Cleaner Separation**: Orchestrator vs Specialist logic is now handled at the builder level, not scattered across fragments

2. **Single Source of Truth**: Each concept (identity, tools, reasoning) now has ONE fragment instead of 3-4

3. **Reduced Complexity**: From ~20 fragment files to ~13, with much clearer purposes

4. **Better Organization**: New consolidated fragments are in `src/prompts/fragments/consolidated/` directory

### Updated Files
- `src/prompts/utils/systemPromptBuilder.ts` - Uses new consolidated fragments
- `src/prompts/index.ts` - Imports new fragments
- `src/agents/execution/AgentExecutor.ts` - Updated imports
- Various test files updated to match new structure

### Build & Test Status
- ✅ Build passes successfully
- ✅ Core prompt tests pass
- ✅ Integration tests updated and passing
- Some unrelated test failures exist (logger, CLI tests) but are not related to this consolidation

## Benefits Achieved

1. **50% reduction in fragment complexity** - From complex scattered logic to simple, focused fragments
2. **Clearer code organization** - Easy to understand what each fragment does
3. **Eliminated redundancy** - No more 3 fragments saying "specialists can't modify things"
4. **Maintained functionality** - All existing features preserved while simplifying structure
5. **Better maintainability** - Future changes will be much easier to implement

## Next Steps (Optional)

If you want to further simplify:
1. Consider moving phase-related fragments into a single phase management fragment
2. Potentially merge `agentFragments.ts` functionality into the consolidated fragments
3. Review if `available-agents.ts` could be merged with multi-agent setup

The consolidation successfully reduced complexity while maintaining all functionality. The fragment system is now much cleaner and easier to work with.
</file>

<file path="conversation-manager-refactor-plan.md">
# ConversationManager Refactoring Plan

## Executive Summary
ConversationManager is a 1,034-line god object handling 12+ distinct responsibilities. This refactoring breaks it into 7 focused services following Single Responsibility Principle, improving maintainability, testability, and comprehension.

**Status**: Planning Phase  
**Created**: 2025-01-13  
**Priority**: High - Core architectural improvement

## Current Problems
- **1,034 lines** handling too many concerns
- **Difficult to test** - can't test phase management without persistence
- **Hard to modify** - changes risk breaking unrelated features
- **Poor separation** - business logic mixed with infrastructure
- **Cognitive overload** - too much to understand at once

## Proposed Architecture

### Core Services

#### 1. ConversationStore (Data Layer)
**Responsibility**: In-memory storage and retrieval of conversations
```typescript
interface ConversationStore {
  get(id: string): Conversation | undefined
  set(id: string, conversation: Conversation): void
  delete(id: string): void
  getAll(): Conversation[]
  findByEvent(eventId: string): Conversation | undefined
  exists(id: string): boolean
}
```

#### 2. ConversationPersistenceService (Infrastructure)
**Responsibility**: Persistence operations only
```typescript
interface ConversationPersistenceService {
  save(conversation: Conversation): Promise<void>
  load(id: string): Promise<Conversation | null>
  loadAll(): Promise<Conversation[]>
  archive(id: string): Promise<void>
  search(criteria: SearchCriteria): Promise<Conversation[]>
}
```

#### 3. PhaseManager (Business Logic)
**Responsibility**: Phase transitions and validation
```typescript
interface PhaseManager {
  canTransition(from: Phase, to: Phase): boolean
  transition(conversation: Conversation, to: Phase, context: TransitionContext): Promise<PhaseTransition>
  getCurrentPhaseRules(phase: Phase): PhaseRules
  validatePhaseRequirements(conversation: Conversation, phase: Phase): ValidationResult
}
```

#### 4. ConversationEventProcessor (Business Logic)
**Responsibility**: Processing and adding events to conversations
```typescript
interface ConversationEventProcessor {
  processIncomingEvent(conversation: Conversation, event: NDKEvent): Promise<void>
  createConversationFromEvent(event: NDKEvent): Promise<Conversation>
  extractMetadataFromEvent(event: NDKEvent): ConversationMetadata
  updateConversationSummary(conversation: Conversation, event: NDKEvent): void
}
```

#### 5. AgentContextBuilder (Business Logic)
**Responsibility**: Building message contexts for agents
```typescript
interface AgentContextBuilder {
  buildContext(conversation: Conversation, agent: AgentInstance, trigger?: NDKEvent): Promise<AgentContext>
  buildOrchestratorContext(conversation: Conversation, trigger?: NDKEvent): Promise<OrchestratorRoutingContext>
  handleDelegationResponses(conversation: Conversation, agent: string, response: NDKEvent): Promise<DelegationResult>
}
```

#### 6. OrchestratorTurnTracker (Business Logic)
**Responsibility**: Managing orchestrator routing decisions
```typescript
interface OrchestratorTurnTracker {
  startTurn(conversationId: string, phase: Phase, agents: string[], reason?: string): string
  addCompletion(conversationId: string, agent: string, message: string): void
  isCurrentTurnComplete(conversationId: string): boolean
  getCurrentTurn(conversationId: string): OrchestratorTurn | null
  getRoutingHistory(conversationId: string): RoutingEntry[]
}
```

#### 7. ConversationCoordinator (Orchestration Layer)
**Responsibility**: Coordinating between services (thin layer)
```typescript
class ConversationCoordinator {
  constructor(
    private store: ConversationStore,
    private persistence: ConversationPersistenceService,
    private phaseManager: PhaseManager,
    private eventProcessor: ConversationEventProcessor,
    private contextBuilder: AgentContextBuilder,
    private turnTracker: OrchestratorTurnTracker,
    private queueManager?: ExecutionQueueManager
  ) {}

  // Thin orchestration methods that delegate to appropriate services
  async createConversation(event: NDKEvent): Promise<Conversation>
  async updatePhase(id: string, phase: Phase, context: TransitionContext): Promise<boolean>
  async buildAgentMessages(id: string, agent: AgentInstance, trigger?: NDKEvent): Promise<AgentMessages>
}
```

## Data Flow

```
User Event → ConversationCoordinator
              ├→ EventProcessor (process event)
              ├→ Store (update in-memory)
              ├→ PhaseManager (if phase change)
              ├→ TurnTracker (if orchestrator routing)
              ├→ ContextBuilder (when agent needs context)
              └→ PersistenceService (save to disk)
```

## Migration Strategy

### Phase 1: Extract Pure Services (Week 1)
1. **ConversationStore** - Simple in-memory Map wrapper
2. **OrchestratorTurnTracker** - Extract turn management logic
3. **ConversationEventProcessor** - Extract event processing

### Phase 2: Extract Complex Services (Week 2)
4. **PhaseManager** - Extract phase logic with queue integration
5. **AgentContextBuilder** - Extract context building (uses existing AgentConversationContext)
6. **ConversationPersistenceService** - Wrap existing FileSystemAdapter

### Phase 3: Create Coordinator (Week 3)
7. **ConversationCoordinator** - Thin orchestration layer
8. Update all callers to use coordinator instead of ConversationManager
9. Keep ConversationManager as deprecated facade during transition

### Phase 4: Cleanup (Week 4)
10. Remove old ConversationManager
11. Update tests to test services independently
12. Performance optimization and monitoring

## Benefits

### Immediate
- **Testability**: Each service can be tested in isolation
- **Comprehension**: Each file ~150-200 lines focused on one thing
- **Maintainability**: Changes isolated to relevant service

### Long-term
- **Reusability**: Services can be used independently
- **Performance**: Can optimize each service separately (e.g., caching in Store)
- **Scalability**: Can distribute services if needed
- **Team velocity**: Developers can work on different services without conflicts

## Example: Phase Transition (Before vs After)

### Before (ConversationManager - mixed concerns)
```typescript
async updatePhase(id: string, phase: Phase, message: string, agentPubkey: string, agentName: string, reason?: string): Promise<boolean> {
  // 150+ lines mixing:
  // - Conversation retrieval
  // - Queue management
  // - Tracing/logging
  // - Phase validation
  // - State updates
  // - Persistence
  // - Event notifications
}
```

### After (Clean separation)
```typescript
// ConversationCoordinator
async updatePhase(id: string, phase: Phase, context: TransitionContext): Promise<boolean> {
  const conversation = this.store.get(id);
  if (!conversation) throw new Error(`Conversation ${id} not found`);
  
  const transition = await this.phaseManager.transition(conversation, phase, context);
  if (!transition.success) return false;
  
  conversation.phase = phase;
  conversation.phaseTransitions.push(transition);
  
  await this.persistence.save(conversation);
  return true;
}

// PhaseManager (focused on phase logic only)
async transition(conversation: Conversation, to: Phase, context: TransitionContext): Promise<PhaseTransition> {
  if (!this.canTransition(conversation.phase, to)) {
    return { success: false, reason: "Invalid transition" };
  }
  
  if (to === PHASES.EXECUTE && this.queueManager) {
    const permission = await this.queueManager.requestExecution(conversation.id, context.agentPubkey);
    if (!permission.granted) {
      return { success: false, queued: true, queuePosition: permission.queuePosition };
    }
  }
  
  return {
    success: true,
    from: conversation.phase,
    to: to,
    timestamp: Date.now(),
    ...context
  };
}
```

## Testing Strategy

### Unit Tests (per service)
```typescript
describe('PhaseManager', () => {
  it('should validate phase transitions', () => {
    const manager = new PhaseManager();
    expect(manager.canTransition(PHASES.CHAT, PHASES.PLAN)).toBe(true);
    expect(manager.canTransition(PHASES.EXECUTE, PHASES.PLAN)).toBe(false);
  });
  
  it('should queue EXECUTE phase requests', async () => {
    const mockQueue = createMockQueueManager();
    const manager = new PhaseManager(mockQueue);
    // Test queue integration in isolation
  });
});
```

### Integration Tests
```typescript
describe('ConversationCoordinator', () => {
  it('should coordinate phase transition', async () => {
    const coordinator = createTestCoordinator();
    const conversation = await coordinator.createConversation(testEvent);
    const result = await coordinator.updatePhase(conversation.id, PHASES.PLAN, context);
    expect(result).toBe(true);
    // Verify all services were called correctly
  });
});
```

## Risk Mitigation

1. **Backwards Compatibility**: Keep ConversationManager as facade initially
2. **Incremental Migration**: Extract one service at a time
3. **Feature Flags**: Can toggle between old/new implementation
4. **Extensive Testing**: Each extraction includes comprehensive tests
5. **Monitoring**: Add metrics to track service performance

## Success Metrics

- **Code Coverage**: Each service >90% tested
- **File Size**: No service >300 lines
- **Cyclomatic Complexity**: Reduced by 60%
- **Team Velocity**: 30% faster feature development after refactor
- **Bug Rate**: 50% reduction in conversation-related bugs

## Next Steps

1. Review and approve this plan
2. Create feature branch `refactor/conversation-manager`
3. Begin Phase 1 extractions
4. Daily progress updates
5. Code review after each service extraction
</file>

<file path="E2E_FRAMEWORK.md">
# TENEX E2E Testing Framework

## Overview

This document describes the End-to-End (E2E) testing framework for TENEX, which enables comprehensive testing of agent workflows without relying on actual LLM services. The framework uses deterministic mock responses to simulate complete agent interactions, including multi-agent conversations, phase transitions, and tool executions.

## Architecture

### Core Components

1. **Test Harness** (`test-harness.ts`) - Provides the complete test environment setup and execution utilities
2. **Mock LLM Service** - Simulates LLM responses based on predefined triggers
3. **Execution Flow Engine** - Automatically orchestrates multi-agent conversations
4. **Assertion Utilities** - Specialized assertions for validating agent workflows
5. **Execution Tracing** - Comprehensive tracking of all agent interactions

### Key Design Decisions

1. **Deterministic Responses**: All LLM responses are predefined based on configurable triggers
2. **Real Component Integration**: Uses real ConversationManager, AgentRegistry, and tool implementations
3. **Automatic Orchestration**: The framework automatically handles orchestrator routing and agent handoffs
4. **Comprehensive Mocking**: Mocks LLM, Nostr publisher, file system, and other external dependencies
5. **Execution Tracing**: Records every agent execution, phase transition, tool call, and routing decision

## Test Structure

### 1. Setup Phase
```typescript
import { 
    setupE2ETest, 
    cleanupE2ETest,
    createConversation,
    executeConversationFlow,
    type E2ETestContext
} from "./test-harness";

let context: E2ETestContext;

beforeEach(async () => {
    // Setup test environment with optional scenarios
    context = await setupE2ETest([]);
    
    // Define mock LLM responses
    const scenarios = [
        {
            trigger: {
                systemPrompt: /You must respond with ONLY a JSON object/,
                userMessage: /implement authentication/i
            },
            response: {
                content: JSON.stringify({
                    agents: ["executor"],
                    phase: "execute",
                    reason: "Routing to executor for implementation"
                })
            },
            priority: 100
        }
    ];
    
    // Add responses to mock LLM
    scenarios.forEach(s => context.mockLLM.addResponse(s));
});

afterEach(async () => {
    await cleanupE2ETest(context);
});
```

### 2. Execution Phase
```typescript
// Create a conversation
const conversationId = await createConversation(
    context,
    "Task Title",
    "User request content",
    [["additional", "tags"]] // optional
);

// Execute the complete conversation flow automatically
const trace = await executeConversationFlow(
    context,
    conversationId,
    "Initial user message",
    {
        maxIterations: 10,
        onAgentExecution: (agent, phase) => {
            console.log(`Executing ${agent} in ${phase} phase`);
        },
        onPhaseTransition: (from, to) => {
            console.log(`Phase transition: ${from} → ${to}`);
        }
    }
);
```

### 3. Validation Phase
```typescript
// Verify agent execution sequence
assertAgentSequence(trace,
    "orchestrator",
    "executor",
    "orchestrator",
    "project-manager"
);

// Verify phase transitions
assertPhaseTransitions(trace,
    "execute",
    "verification",
    "complete"
);

// Verify tool calls by agent
assertToolCalls(trace, "executor", "continue", "complete");

// Verify feedback propagation
const feedbackPropagated = assertFeedbackPropagated(
    trace,
    "project-manager",  // from agent
    "executor",         // to agent
    "security"          // keyword to find
);
expect(feedbackPropagated).toBe(true);
```

## Mock LLM Response Configuration

### Response Triggers

The mock LLM matches responses based on various trigger conditions:

```typescript
interface MockLLMTrigger {
    // Agent-based triggers
    agentName?: string;              // Match specific agent (e.g., "executor")
    
    // Message content triggers
    systemPrompt?: string | RegExp;  // Match system prompt content
    userMessage?: string | RegExp;   // Match user message content
    messageContains?: string | RegExp; // Match any message content
    
    // Context triggers
    phase?: string;                  // Match conversation phase
    previousAgent?: string;          // Match after specific agent execution
    previousTools?: string[];        // Match after specific tools used
    iterationCount?: number;         // Match on nth execution of agent
}
```

### Response Structure

```typescript
interface MockLLMResponse {
    trigger: MockLLMTrigger;
    response: {
        content: string;             // Text response
        toolCalls?: ToolCall[];      // Optional tool invocations
    };
    priority: number;                // Higher priority checked first
}
```

### Example Scenarios

#### 1. Orchestrator Routing Response
```typescript
{
    trigger: {
        systemPrompt: /You must respond with ONLY a JSON object/,
        userMessage: /implement authentication/i
    },
    response: {
        content: JSON.stringify({
            agents: ["executor"],
            phase: "execute",
            reason: "User wants authentication implemented"
        })
    },
    priority: 100
}
```

#### 2. Agent with Tool Call
```typescript
{
    trigger: {
        agentName: "executor",
        phase: "execute"
    },
    response: {
        content: "I've implemented the authentication system",
        toolCalls: [{
            id: "1",
            type: "function",
            function: {
                name: "continue",
                arguments: JSON.stringify({
                    agents: ["orchestrator"],
                    phase: "verification",
                    reason: "Ready for verification"
                })
            }
        }]
    },
    priority: 90
}
```

#### 3. Iteration-Based Response
```typescript
{
    trigger: {
        agentName: "project-manager",
        iterationCount: 2  // Second time PM is called
    },
    response: {
        content: "All issues resolved, approving implementation",
        toolCalls: [{
            id: "2",
            type: "function",
            function: {
                name: "complete",
                arguments: JSON.stringify({
                    summary: "Task completed successfully"
                })
            }
        }]
    },
    priority: 85
}

```

## Key Features

### executeConversationFlow

The `executeConversationFlow` function is the centerpiece of the E2E framework. It automatically:

1. **Executes the orchestrator** after each agent to determine routing
2. **Parses routing decisions** from orchestrator JSON responses
3. **Executes target agents** based on routing decisions
4. **Handles tool calls** including `continue` and `complete`
5. **Updates conversation phases** based on routing decisions
6. **Tracks everything** in a comprehensive execution trace

### Execution Trace

The execution trace provides complete visibility into the conversation flow:

```typescript
interface ExecutionTrace {
    conversationId: string;
    executions: AgentExecutionRecord[];      // All agent executions
    phaseTransitions: PhaseTransitionRecord[]; // Phase changes
    toolCalls: ToolCallRecord[];             // Tool invocations
    routingDecisions: RoutingDecisionRecord[]; // Orchestrator decisions
}
```

### Available Test Utilities

- `setupE2ETest()` - Initialize test environment with mocked dependencies
- `cleanupE2ETest()` - Clean up test environment
- `createConversation()` - Create a new conversation
- `executeAgent()` - Execute a single agent (manual mode)
- `executeConversationFlow()` - Execute complete conversation flow (automatic)
- `getConversationState()` - Get current conversation state
- `waitForPhase()` - Wait for specific phase transition

### Assertion Helpers

- `assertAgentSequence()` - Verify agents executed in correct order
- `assertPhaseTransitions()` - Verify phase transitions occurred
- `assertToolCalls()` - Verify specific tools were called by agents
- `assertFeedbackPropagated()` - Verify information passed between agents

## Test Patterns

### 1. Complete Workflow Test
```typescript
it("should handle complete authentication implementation", async () => {
    // Setup mock responses for entire flow
    const scenarios = createAuthenticationScenarios();
    scenarios.forEach(s => context.mockLLM.addResponse(s));
    
    // Execute flow
    const trace = await executeConversationFlow(
        context,
        conversationId,
        "Implement secure authentication"
    );
    
    // Verify complete workflow
    assertAgentSequence(trace,
        "orchestrator", "planner",
        "orchestrator", "executor",
        "orchestrator", "project-manager",
        "orchestrator", "executor",  // Fix cycle
        "orchestrator", "project-manager"  // Final approval
    );
});
```

### 2. Feedback Loop Test
```typescript
it("should propagate feedback between agents", async () => {
    const trace = await executeConversationFlow(context, conversationId, message);
    
    // Verify PM feedback reaches executor
    const feedbackPropagated = assertFeedbackPropagated(
        trace,
        "project-manager",
        "executor",
        "security vulnerabilities"
    );
    expect(feedbackPropagated).toBe(true);
    
    // Verify executor addresses feedback
    const executorMessages = trace.executions
        .filter(e => e.agent === "executor")
        .map(e => e.message);
    expect(executorMessages[1]).toContain("fixed security");
});
```

### 3. Phase Transition Test
```typescript
it("should transition through correct phases", async () => {
    const phaseChanges: string[] = [];
    
    const trace = await executeConversationFlow(
        context,
        conversationId,
        "Build feature with testing",
        {
            onPhaseTransition: (from, to) => {
                phaseChanges.push(`${from}->${to}`);
            }
        }
    );
    
    expect(phaseChanges).toContain("plan->execute");
    expect(phaseChanges).toContain("execute->verification");
    expect(phaseChanges).toContain("verification->complete");
});
```

### 4. Error Recovery Test
```typescript
it("should handle agent errors gracefully", async () => {
    // Add error response
    context.mockLLM.addResponse({
        trigger: { agentName: "executor" },
        response: {
            content: "Error: Unable to access database",
            toolCalls: [{
                function: {
                    name: "continue",
                    arguments: JSON.stringify({
                        agents: ["orchestrator"],
                        phase: "error",
                        reason: "Database connection failed"
                    })
                }
            }]
        }
    });
    
    const trace = await executeConversationFlow(context, conversationId, message);
    
    // Verify error handling
    expect(trace.phaseTransitions.some(t => t.to === "error")).toBe(true);
});

```

## Running Tests

```bash
# Run all E2E tests
bun test tests/e2e

# Run specific test file
bun test tests/e2e/executor-verification-flow.test.ts

# Run with debug output (shows mock LLM matching)
DEBUG=true bun test tests/e2e/executor-verification-flow.test.ts

# Run with extended timeout
bun test tests/e2e/executor-verification-flow.test.ts --timeout 30000

# Run tests matching pattern
bun test tests/e2e --test-name-pattern "feedback"
```

## Best Practices

### 1. Mock Response Design
- **Use high priority (90-120)** for specific scenarios
- **Add low priority (1-10)** fallback responses
- **Match on multiple conditions** for precision
- **Use RegExp** for flexible content matching

### 2. Test Organization
```typescript
// Group related scenarios
const authenticationScenarios = [
    orchestratorInitialRouting,
    executorImplementation,
    projectManagerVerification,
    executorFixes,
    projectManagerApproval
];

// Add all at once
authenticationScenarios.forEach(s => context.mockLLM.addResponse(s));
```

### 3. Debugging Failed Tests
```typescript
// Get request history
const history = context.mockLLM.getRequestHistory();
console.log("Requests made:", history.length);

// Examine specific request
const lastRequest = history[history.length - 1];
console.log("Last request:", {
    agent: lastRequest.options?.agentName,
    messages: lastRequest.messages,
    response: lastRequest.response
});
```

### 4. Complex Workflow Testing
```typescript
// Use previousAgent trigger for sequential flows
{
    trigger: {
        systemPrompt: /orchestrator/,
        previousAgent: "executor"  // Only match after executor
    },
    response: {
        content: JSON.stringify({
            agents: ["project-manager"],
            phase: "verification"
        })
    }
}
```

## Mocked Dependencies

The test harness mocks the following modules:

1. **@/lib/fs** - File system operations
2. **@/llm/router** - LLM service routing
3. **@/nostr** - Nostr publisher and NDK
4. **@/agents/AgentPublisher** - Agent profile publishing
5. **@/agents/execution/ClaudeBackend** - Claude Code execution
6. **@/logging/ExecutionLogger** - Execution logging
7. **@/tracing** - Tracing context
8. **@/services/ProjectContext** - Project context

## Available Test Files

Current E2E tests cover various scenarios:

- `executor-verification-flow.test.ts` - Complete verification cycle with feedback
- `orchestrator-workflow.test.ts` - Basic orchestrator routing
- `complete-tool-integration.test.ts` - Tool execution flows
- `state-persistence.test.ts` - Conversation state management
- `concurrency-multiple-conversations.test.ts` - Parallel conversations
- `agent-error-recovery.test.ts` - Error handling scenarios

## Writing New E2E Tests

### Step 1: Define Your Scenario
```typescript
describe("E2E: My Feature", () => {
    let context: E2ETestContext;
    
    beforeEach(async () => {
        context = await setupE2ETest([]);
        
        // Define your mock responses
        const scenarios = [
            // ... your scenarios
        ];
        
        scenarios.forEach(s => context.mockLLM.addResponse(s));
    });
});
```

### Step 2: Execute the Flow
```typescript
it("should handle my feature", async () => {
    const conversationId = await createConversation(
        context,
        "Feature Test",
        "Test my feature"
    );
    
    const trace = await executeConversationFlow(
        context,
        conversationId,
        "Test my feature"
    );
    
    // Assertions...
});
```

### Step 3: Verify Results
```typescript
// Use provided assertions
assertAgentSequence(trace, "orchestrator", "my-agent");
assertPhaseTransitions(trace, "plan", "execute");
assertToolCalls(trace, "my-agent", "my-tool");

// Or custom checks
expect(trace.executions[0].message).toContain("expected text");
expect(trace.routingDecisions[0].toAgents).toContain("my-agent");
```

## Troubleshooting

### Common Issues

1. **"No matching response found"**
   - Enable debug mode: `process.env.DEBUG = 'true'`
   - Check trigger conditions match exactly
   - Verify priority ordering

2. **Unexpected agent sequence**
   - Check orchestrator routing responses
   - Verify `previousAgent` triggers
   - Ensure phase transitions are correct

3. **Tool calls not executing**
   - Verify tool call JSON is valid
   - Check tool name matches exactly
   - Ensure arguments are properly stringified

### Debug Utilities

```typescript
// Enable verbose logging
process.env.DEBUG = 'true';

// Examine mock LLM state
console.log("Request count:", context.mockLLM.getRequestHistory().length);
console.log("Active scenarios:", context.mockLLM.scenarios);

// Track execution flow
const trace = await executeConversationFlow(context, conversationId, message, {
    onAgentExecution: (agent, phase) => {
        console.log(`[EXEC] ${agent} in ${phase}`);
    },
    onPhaseTransition: (from, to) => {
        console.log(`[PHASE] ${from} → ${to}`);
    }
});
```
</file>

<file path="NEW-FLOW.md">
# PM-Centric Routing Architecture

## Overview

We are fundamentally reimagining how TENEX orchestrates agent collaboration. Instead of a hidden, system-level orchestrator making routing decisions behind the scenes, we're moving to a model where the Project Manager (PM) agent is the visible, intelligent coordinator of all workflows. This shift brings transparency, flexibility, and simplicity to the system.

## The Core Insight

The key realization is that orchestration doesn't need to be a system-level concern. By making the PM the explicit orchestrator, we turn routing decisions into visible parts of the conversation. Users can see why the PM chose a particular workflow, agents can understand the context of their invocation, and the entire system becomes debuggable through conversation history.

## How the New System Works

### The Entry Point

When a user starts a new conversation, the system now follows a simple rule:
- If the user @mentions a specific agent (e.g., "@executor fix the bug"), that agent receives the message directly
- Otherwise, ALL new conversations route to the Project Manager

This means the PM becomes the default entry point for all user interactions. The PM's first job is to understand what the user wants - and critically, the PM can engage in conversation to clarify ambiguous requests rather than immediately delegating.

```
User: "Hey, I have a question"
PM: "I'd be happy to help! What would you like to know about the project?"
User: "How does the authentication work?"
PM: [Might answer directly from project knowledge, or delegate to architect for detailed explanation]
```

### The Phase System: Vocabulary, Not State Machine

We maintain the concept of "phases" (CHAT, PLAN, EXECUTE, VERIFICATION, CHORES, REFLECTION), but these are now **modes of work** rather than rigid states. The PM uses phases as a shared vocabulary that all agents understand, but there are no hardcoded transition rules.

The PM might decide:
- "This is a one-line typo fix" → Skip directly to EXECUTE phase
- "This is a complex feature" → Full workflow: PLAN → EXECUTE → VERIFICATION → CHORES → REFLECTION  
- "User wants to explore ideas" → BRAINSTORM → PLAN → EXECUTE
- "Emergency production fix" → EXECUTE → END (fix now, clean up later)

### Phase Transitions Through Tools

The PM changes phases explicitly using a new `switch_phase` tool:

```typescript
switch_phase("EXECUTE", "Implementing the authentication fix the user requested")
```

This tool call:
1. Updates the conversation's current phase in ConversationManager
2. Provides the "reason" which becomes the goal/context for the next phase
3. Creates an auditable record of why the PM chose this transition

When agents are invoked after a phase switch, ConversationManager injects context:

```
=== CURRENT PHASE: EXECUTE ===
Goal: Implementing the authentication fix the user requested
Your role: Implementation and code changes
Expected outcome: Working authentication system
```

### The Delegation Model: Event-Driven Callbacks, Not State Machines

Delegation is the universal mechanism for agent collaboration, but it's much simpler than it might first appear. Every delegation creates formal NDKTask events (Nostr kind 1934) that enable event-driven callbacks - not complex state machines.

#### The Key Insight: "Dormant" Means "Data Record", Not "Waiting Process"

The term "dormant state" is misleading. There is NO process waiting in a loop. Instead, think of it like **asynchronous callback registration**:

1. **Agent delegates** → Creates NDKTask events, notes the task IDs in `agentState.pendingDelegation`, then **completely exits**
2. **System continues** → Other agents work, no resources consumed by "waiting" agent  
3. **Completion arrives** → EventHandler sees it, checks if all tasks done, **starts a fresh execution** of the original agent

It's like a manager sending emails and then going home. The only thing that exists is a calendar reminder (the data record). When replies arrive, that triggers a new action - the manager isn't sitting at their desk waiting.

#### The Literal Execution Flow

1. **Delegation (Agent Execution Ends)**
   - Planner calls `delegate(["security-expert", "architect"], "Review this plan")`
   - The delegate tool creates NDKTask events and updates `agentState.pendingDelegation`
   - **The Planner's execution completely finishes** - no loops, no waiting
   - Only a JSON record remains: `{ taskIds: ["task_123", "task_456"], status: "pending" }`

2. **Passive Data Record (Not a Process)**
   ```json
   "agentStates": {
     "planner": {
       "pendingDelegation": {
         "taskIds": ["task_123", "task_456"],
         "tasks": { "task_123": { "status": "pending" } }
       }
     }
   }
   ```
   This is just data in the Conversation object - no active process exists.

3. **Task Completion (Event-Driven Callback)**
   - Security Expert completes, publishes completion event with `["status", "complete"]`
   - EventHandler receives this event (it's always listening)
   - Checks: "Is this completing a task someone is waiting for?"
   - Updates the data record: `tasks["task_123"].status = "complete"`
   - Checks: "Are ALL tasks complete?" If yes, triggers NEW execution of Planner

This is why the architecture is robust - it's completely event-driven, not stateful in a procedural sense. The system can stop and restart at any point, and as long as the events are on Nostr relays, it picks up exactly where it left off.

#### How Delegation Works

When an agent (the "Delegator") calls the `delegate()` tool with one or more recipients (the "Delegatees"), the system decomposes this into individual, parallel sub-tasks:

1. **Task Creation**: For EACH recipient agent, the system:
   - Creates a new, unique NDKTask event
   - Signs it with the Delegator's key
   - Sets the task content to the delegation request
   - Adds a p-tag for the recipient's pubkey (formal assignment)
   - **Crucially**: Adds an e-tag pointing to the root conversation event (context link)

2. **State Management**: After creating all NDKTask events, the Delegator:
   - Enters a dormant `pendingDelegation` state
   - ConversationManager tracks all taskIds it's waiting for
   - The agent becomes inactive until ALL sub-tasks complete

3. **Parallel Execution**: Each Delegatee:
   - Gets activated by their NDKTask event
   - Works independently and in parallel with other Delegatees
   - Publishes progress updates as replies to their NDKTask (not the main conversation)
   - This isolates "workflow noise" from the main conversation thread

4. **Completion and Return**: When a Delegatee finishes:
   - Calls `complete()` with their results
   - System recognizes this is a sub-task completion
   - Publishes completion as a reply to the NDKTask, p-tagging the Delegator

5. **Re-activation**: The Delegator:
   - Receives each completion reply
   - Updates its `pendingDelegation` state
   - Remains dormant until ALL tasks complete
   - Gets re-activated with a synthesized summary of all responses

#### Visual Example: Parallel Delegation

```
PM creates tasks for multiple agents:
├── NDKTask #1 → Planner
│   - content: "Create implementation plan"
│   - p-tag: planner-pubkey
│   - e-tag: conversation-root
│
├── NDKTask #2 → Architect
│   - content: "Review architecture implications"
│   - p-tag: architect-pubkey
│   - e-tag: conversation-root
│
└── NDKTask #3 → Security Expert
    - content: "Identify security considerations"
    - p-tag: security-pubkey
    - e-tag: conversation-root

[PM enters dormant state, waiting for all 3 tasks]

Parallel execution:
- Planner working on Task #1...
- Architect working on Task #2...
- Security Expert working on Task #3...

Completions arrive (in any order):
- Security Expert completes → PM's state updates (1/3 done)
- Planner completes → PM's state updates (2/3 done)
- Architect completes → PM's state updates (3/3 done)

[PM re-activates with all three responses synthesized]
```

#### The Call Stack with NDKTasks

When delegations are nested, they create a natural task hierarchy:

```
PM delegates to Planner (creates NDKTask #1)
│
└── Planner receives Task #1
    ├── Delegates to Expert A (creates NDKTask #2)
    ├── Delegates to Expert B (creates NDKTask #3)
    └── [Planner goes dormant]
    
    Expert A works on Task #2
    └── Completes → replies to Task #2 → Planner updated
    
    Expert B works on Task #3
    └── Completes → replies to Task #3 → Planner updated
    
    [Planner re-activates with both expert responses]
    └── Completes Task #1 → replies to Task #1 → PM updated

[PM re-activates with Planner's synthesized response]
```

#### Benefits of NDKTask-Based Delegation

1. **Formal Structure**: Each delegation is a first-class task with ID, status, and history
2. **True Parallelism**: Multiple agents work simultaneously without blocking
3. **Audit Trail**: Every sub-task is recorded as a Nostr event
4. **Context Preservation**: e-tags ensure delegatees can access full conversation history
5. **Progress Isolation**: Intermediate updates don't clutter main conversation
6. **Clean Synthesis**: Delegator receives organized summary of all sub-responses

### Phase Leadership: Mini-Orchestrators

The key insight is that when PM delegates to a phase lead (like Planner or Executor), it's not just asking for a deliverable - it's **handing over temporary leadership of that entire phase**. The phase lead becomes a mini-orchestrator with full autonomy to manage their phase's workflow.

#### The Planner as PLAN Phase Orchestrator

When PM delegates planning to the Planner, here's the complete workflow the Planner orchestrates:

**Step 1: PM Initiates Planning**
```
PM: switch_phase("PLAN", "Design secure authentication feature")
PM: delegate(["planner"], "Create comprehensive auth implementation plan")
PM: [Goes dormant, waiting for planner's final output]
```

**Step 2: Planner Gathers Guidelines**
The Planner, now active, analyzes what expertise is needed:
```
Planner: "This involves security and architecture. I need expert input first."
Planner: delegate(["security-expert", "architect"], 
                  "Provide guidelines for auth feature design")
Planner: [Goes dormant, waiting for expert responses]
```

**Step 3: Experts Provide Guidelines (in parallel)**
```
Security Expert: "Use Argon2 hashing, implement rate limiting, require MFA"
Architect: "Separate auth service, use JWTs with short access tokens"
[Both complete back to Planner]
```

**Step 4: Planner Creates Plan**
Planner re-activates with synthesized expert guidelines:
```
Planner: "Now I'll create the plan incorporating all guidelines"
Planner: claude_code("Generate auth plan with: [expert guidelines + requirements]")
[Receives detailed plan from claude_code]
```

**Step 5: Planner Validates Plan**
Before returning to PM, Planner ensures quality:
```
Planner: delegate(["security-expert", "architect"],
                  "Validate this plan: [full plan text]")
Planner: [Goes dormant again]

Security Expert: "LGTM, but add CSRF protection"
Architect: "Approved with minor suggestions"
[Both complete back to Planner]
```

**Step 6: Planner Completes to PM**
```
Planner: [Incorporates final feedback]
Planner: complete("Plan complete and validated by experts: [final plan]")
[Returns control to PM]
```

The entire multi-step planning workflow is **encapsulated within the Planner's execution**, keeping the main conversation clean. The PM only sees the initial delegation and the final, validated plan.

#### The Executor as EXECUTE Phase Orchestrator

The Executor is a sophisticated implementation manager that orchestrates the entire code-review-revise cycle:

**Step 1: PM Initiates Execution**
```
PM: switch_phase("EXECUTE", "Implement Share to Nostr button")
PM: delegate(["executor"], "Implement the Share to Nostr button per plan")
PM: [Goes dormant]
```

**Step 2: Executor's First Action - Always Delegate to claude_code**
```
Executor: [Receives high-level task]
Executor: "My first step is always to pass this to claude_code"
Executor: claude_code("Implement the Share to Nostr button per plan")
Executor: [Goes dormant, waiting for claude_code]
```

**Step 3: claude_code Implements**
```
claude_code: [Creates src/components/ShareButton.tsx]
claude_code: [Updates src/pages/UserProfile.tsx]
claude_code: Returns report: "Created ShareButton component with NDK integration"
[Tool completes back to Executor]
```

**Step 4: Executor Orchestrates Review**
```
Executor: [REACTIVATES with claude_code's report]
Executor: "Implementation done. Need expert review of UI and Nostr integration"
Executor: delegate(["ui-expert", "nostr-expert"], 
                  "Review implementation: [claude_code's report]")
Executor: [Goes dormant, waiting for reviews]
```

**Step 5: Experts Review (in parallel)**
```
UI Expert: "Functional but needs aria-label for accessibility"
Nostr Expert: "NDK call correct but needs try/catch for errors"
[Both complete to Executor]
```

**Step 6: Executor Decides - Loop or Complete**
```
Executor: [REACTIVATES with expert feedback]
Executor: "Reviews require changes. Sending back to claude_code with feedback"
Executor: claude_code("Revise implementation with feedback:
                      - Add aria-label for accessibility
                      - Wrap NDK call in try/catch")
Executor: [Goes dormant again]

[claude_code makes revisions, returns updated report]

Executor: [REACTIVATES]
Executor: delegate(["ui-expert", "nostr-expert"], "Verify fixes: [updated report]")
[Experts approve]

Executor: complete("Implementation complete with all reviews passed:
                   - Share button with accessibility
                   - Error handling for NDK
                   - All expert approvals received")
[Returns control to PM]
```

**Key Points:**
- Executor NEVER implements directly - always delegates to claude_code first
- Executor manages the implementation-review-revise loop
- Executor only completes when all reviews pass
- This keeps implementation quality high without PM involvement

#### Key Principles of Phase Leadership

1. **Full Autonomy**: Phase leads have complete control over their phase workflow
2. **Encapsulation**: Internal delegations and iterations are hidden from PM
3. **Quality Gates**: Phase leads ensure deliverables meet standards before returning
4. **Parallel Work**: Phase leads can delegate to multiple experts simultaneously
5. **Iterative Refinement**: Phase leads can iterate based on feedback without PM involvement
6. **Delegate Intent, Not Implementation**: Phase leads receive high-level goals, not specific implementation details. When PM delegates to Planner or Executor, it passes the user's intent (e.g., "implement password reset"), NOT file paths or code snippets. The specialist agent is responsible for using its tools (analyze, shell, readFile) to discover the necessary implementation details. This boundary ensures specialists own their domain expertise.

### Handling Ambiguity and Context

The PM no longer needs to immediately understand and route every request. It can engage in conversation:

```
User: "Make it better"
PM: "I'd like to help improve things! Could you clarify what aspect you'd like me to focus on? 
     Are you concerned about performance, code quality, user experience, or something else?"
User: "The API is too slow"
PM: "I understand - you're experiencing performance issues with the API. Let me coordinate 
     a performance analysis and optimization workflow."
[PM switches to EXECUTE phase and delegates to executor with full context]
```

### Loop Prevention Through Intelligence

Without the OrchestratorTurnTracker's elaborate routing history, how does PM prevent loops? Through intelligent analysis of the conversation history. The PM's prompt includes instructions to recognize patterns like:

- Same error occurring multiple times
- Agents requesting the same information repeatedly  
- Circular delegation patterns
- Lack of progress despite multiple attempts

When PM detects these patterns, it can:
- Try a different approach
- Engage the user for guidance
- Skip to a different phase
- Bring in different experts

### The Complete Workflow

Here's how a typical feature request flows through the system, showing the full depth of phase leadership:

```
1. USER: "Add password reset functionality"
   ↓
2. PM: [Recognizes this is a feature request needing planning]
   - Calls switch_phase("PLAN", "Design password reset feature")
   - Delegates to Planner: "Create implementation plan for password reset"
   - [PM GOES DORMANT]
   ↓
3. PLANNER TAKES OVER PLAN PHASE:
   
   3a. Planner: "Need expert guidelines first"
       - delegate(["security-expert", "architect"], "Guidelines for password reset?")
       - [PLANNER GOES DORMANT]
   
   3b. Experts work in parallel:
       - Security: "Use time-limited tokens, implement rate limiting..."
       - Architect: "Separate reset service, event-driven flow..."
       - [Both complete to Planner]
   
   3c. Planner: [REACTIVATES with expert responses]
       - claude_code("Create plan with these guidelines: [expert inputs]")
       - Gets detailed plan from Claude
   
   3d. Planner: "Need validation before returning to PM"
       - delegate(["security-expert", "architect"], "Validate plan: [full plan]")
       - [PLANNER GOES DORMANT]
   
   3e. Experts validate:
       - Security: "Add CSRF protection, otherwise good"
       - Architect: "Consider caching strategy for tokens"
       - [Both complete to Planner]
   
   3f. Planner: [REACTIVATES, incorporates feedback]
       - complete("Validated plan ready: [final plan with all feedback]")
   ↓
4. PM: [REACTIVATES with completed plan]
   - Reviews plan output
   - Calls switch_phase("EXECUTE", "Implement password reset functionality")
   - Delegates to Executor: "Implement the password reset feature as planned"
   - [PM GOES DORMANT - Note: PM does NOT specify files or implementation details]
   ↓
5. EXECUTOR TAKES OVER EXECUTE PHASE:
   
   5a. Executor: [First action - always delegate to claude_code]
       - claude_code("Implement the password reset feature as planned")
       - [EXECUTOR GOES DORMANT]
   
   5b. claude_code: [Does all implementation work]
       - Analyzes codebase structure
       - Creates src/services/passwordReset.ts
       - Updates src/models/user.ts with reset token fields
       - Adds endpoints to src/api/auth.routes.ts
       - Returns: "Implemented password reset with token service"
   
   5c. Executor: [REACTIVATES, orchestrates review]
       - "Need security and architecture review"
       - delegate(["security-expert", "architect"], 
                  "Review password reset implementation: [claude_code report]")
       - [EXECUTOR GOES DORMANT]
   
   5d. Experts review in parallel:
       - Security: "Found timing attack in token comparison"
       - Architect: "Extract token service interface for testability"
       - [Both complete to Executor]
   
   5e. Executor: [REACTIVATES, sends back for revision]
       - claude_code("Revise implementation with feedback:
                     - Fix timing attack in token comparison
                     - Extract token service interface")
       - [EXECUTOR GOES DORMANT]
   
   5f. claude_code: [Makes revisions]
       - Implements constant-time comparison
       - Extracts TokenService interface
       - Returns: "Revisions complete"
   
   5g. Executor: [REACTIVATES, final review]
       - delegate(["security-expert", "architect"], "Verify fixes: [revision report]")
       - [EXECUTOR GOES DORMANT]
       - Experts: "All issues resolved"
   
   5h. Executor: [REACTIVATES, completes]
       - complete("Implementation complete with all reviews passed")
   ↓
6. PM: [REACTIVATES with implementation complete]
   - Calls switch_phase("VERIFICATION", "Verify password reset works")
   - Might handle verification itself or delegate to QA expert
   ↓
7. [Continue through CHORES, REFLECTION as needed]
   ↓
8. PM: "Password reset feature successfully implemented and tested!"
```

Note how the main conversation only shows PM's high-level orchestration, while each phase lead manages complex sub-workflows internally. This keeps the conversation clean while ensuring thorough, expert-validated work.

## Implementation Architecture

### What We've Already Done

We've successfully completed the first major step: **Unified Execution Backend**

All agents now use the ReasonActLoop (RAL) execution model. We've:
- Deleted `ClaudeBackend.ts` and `RoutingBackend.ts`
- Removed the `backend` property from agent definitions
- Made `claude_code` available as a tool rather than a backend
- Simplified AgentExecutor to use one consistent execution path

The PM has been given initial workflow coordination responsibilities and access to the `delegate()` tool.

### What Needs to Be Built

#### The switch_phase Tool

We need to create `src/tools/implementations/switch_phase.ts`:

```typescript
const switchPhaseSchema = z.object({
    phase: z.enum(["CHAT", "BRAINSTORM", "PLAN", "EXECUTE", "VERIFICATION", "CHORES", "REFLECTION"]),
    reason: z.string().describe("The goal or purpose of entering this phase")
});

export const switchPhaseTool = createToolDefinition({
    name: "switch_phase",
    description: "Switch the conversation to a new phase",
    schema: switchPhaseSchema,
    execute: async (input, context) => {
        const { phase, reason } = input.value;
        
        // Update conversation phase
        await context.conversationManager.updatePhase(
            context.conversationId,
            phase,
            reason,
            context.agent.pubkey,
            context.agent.name,
            reason
        );
        
        return success({
            message: `Switched to ${phase} phase`,
            phase,
            reason
        });
    }
});
```

This tool will be exclusive to the PM - added only to its toolset.

#### NDKTask-Based Delegation Implementation

The `delegate()` tool needs to be enhanced to create formal NDKTask events:

```typescript
// In delegate tool execute function
for (const recipientPubkey of resolvedPubkeys) {
    // Create a new NDKTask for this specific recipient
    const task = new NDKTask(ndk);
    task.content = fullRequest;
    task.tags = [
        ["p", recipientPubkey],  // Assign to this agent
        ["e", conversationRootEvent.id, "", "root"],  // Link to conversation
        ["status", "pending"],
    ];
    
    // Sign and publish the task
    await task.sign(context.agent.signer);
    await task.publish();
    
    // Track this task in pendingDelegation state
    pendingTasks.set(task.id, {
        recipientPubkey,
        status: "pending",
        createdAt: Date.now()
    });
}

// Update agent state to track all pending tasks
await context.conversationManager.updateAgentState(
    context.conversationId,
    context.agent.slug,
    {
        pendingDelegation: {
            taskIds: Array.from(pendingTasks.keys()),
            tasks: pendingTasks,
            originalRequest: fullRequest,
            timestamp: Date.now(),
        }
    }
);
```

The `complete()` tool needs to detect if it's completing a sub-task:

```typescript
// In handleAgentCompletion
if (context.triggeringEvent?.kind === NDKKind.Task) {
    // This is a sub-task completion
    const completionReply = new NDKEvent(ndk);
    completionReply.content = response;
    completionReply.tags = [
        ["e", context.triggeringEvent.id, "", "reply"],  // Reply to the task
        ["p", context.triggeringEvent.pubkey],  // Notify the delegator
        ["status", "complete"],
    ];
    await completionReply.sign(agent.signer);
    await completionReply.publish();
} else {
    // Regular conversation completion (existing logic)
}
```

#### Task-Scoped Claude Code Session Management

To support intelligent, iterative refinement of code, the `claude_code` session is scoped to the agent's current NDKTask, not the entire conversation. This ensures that when an agent gets feedback and re-invokes `claude_code`, it's iterating within the same context.

The workflow is as follows:

**1. Session Creation**
On the first call to `claude_code` within an NDKTask, a new Claude Code session is created. The resulting `sessionId` is immediately persisted to that agent's `AgentState` in the ConversationManager:

```typescript
// In claude_code tool execute function
const result = await claudeCodeSDK.execute(prompt);
if (result.sessionId && !context.claudeSessionId) {
    // First call - persist the new session ID
    await context.conversationManager.updateAgentState(
        context.conversationId,
        context.agent.slug,
        { claudeSessionId: result.sessionId }
    );
}
```

**2. Session Retrieval**
Before any subsequent tool call, the AgentExecutor reads the agent's current state. If a `claudeSessionId` exists, it is passed into the ExecutionContext:

```typescript
// In AgentExecutor.execute()
const agentState = conversation?.agentStates.get(context.agent.slug);
const claudeSessionId = agentState?.claudeSessionId;

const fullContext: ExecutionContext = {
    ...context,
    claudeSessionId, // Pass existing session if available
};
```

**3. Session Resumption**
When the agent calls `claude_code` again for revisions, the tool receives the `sessionId` from the context and passes it to the Claude Code SDK, successfully resuming the session with full context:

```typescript
// In claude_code tool
const sessionId = context.claudeSessionId; // From ExecutionContext
const result = await claudeCodeSDK.execute(prompt, { sessionId });
// Claude Code now has full context of previous implementation
```

**4. Session Cleanup**
When an agent calls `complete()`, signaling the end of its work on that NDKTask, the completionHandler is responsible for clearing the `claudeSessionId` from the agent's state. This ensures the agent starts fresh on its next delegated task:

```typescript
// In handleAgentCompletion
if (context.triggeringEvent?.kind === NDKKind.Task) {
    // Clear the Claude session as task is complete
    await context.conversationManager.updateAgentState(
        context.conversationId,
        context.agent.slug,
        { claudeSessionId: null }
    );
}
```

This scoping ensures:
- Each NDKTask gets its own isolated Claude Code session
- Revisions within a task maintain full context
- No session bleed between different tasks
- Clean slate for each new delegation

#### Task Activation and Response Synthesis

The event handler needs to recognize and route NDKTask events:

```typescript
// In event handler
case NDKKind.Task:
    const task = NDKTask.from(event);
    const assignedAgent = findAgentByPubkey(task.assignee);
    
    if (assignedAgent) {
        // Activate the agent with the task
        await agentExecutor.execute({
            agent: assignedAgent,
            conversationId: task.rootEventId,  // From e-tag
            triggeringEvent: task,
            isSubTask: true,
            // ... other context
        });
    }
    break;
```

When all sub-tasks complete, the system synthesizes responses:

```typescript
// In ConversationManager or AgentExecutor
function checkPendingDelegations(agentState) {
    const pending = agentState.pendingDelegation;
    if (!pending) return;
    
    // Check if all tasks are complete
    const allComplete = pending.taskIds.every(taskId => 
        pending.tasks.get(taskId).status === "complete"
    );
    
    if (allComplete) {
        // Synthesize all responses into a summary
        const synthesis = pending.tasks.map(task => ({
            agent: task.recipientPubkey,
            response: task.completionResponse
        }));
        
        // Re-activate the delegator with synthesized responses
        reactivateAgent(agentState.agentId, synthesis);
    }
}
```

#### PM Instructions Overhaul

The PM needs comprehensive instructions that include:

1. **Workflow Patterns** - When to use which phases
2. **Routing Logic** - Transferred from the old orchestrator prompt
3. **Loop Detection** - How to recognize and break cycles
4. **Completion Detection** - When the user's request has been fulfilled
5. **Ambiguity Handling** - How to engage users for clarification
6. **Task Management** - How to create and track NDKTask delegations
7. **CRITICAL Delegation Boundary**: 
   - **DO NOT** make assumptions about implementation details
   - **DO NOT** specify file paths, function names, or code snippets in delegation requests
   - **DO** pass the user's high-level intent to specialist agents
   - **DO** trust specialists to figure out the "how" and "where"
   - Example: Say "implement user authentication" NOT "modify src/auth/login.ts"

#### Specialist Agent Instructions Update

Specialist agents (Planner, Executor) need updated instructions:

**Executor Instructions - Complete Rewrite:**
```
You are the manager of the implementation phase. Your workflow is a strict, multi-step process:

Step 1: Initial Implementation
- Upon receiving a request from the Project Manager, your ONLY first action is to call the claude_code tool
- Pass the request to claude_code VERBATIM - do not analyze or modify it

Step 2: Orchestrate Review  
- After claude_code returns its report, analyze what was changed
- Determine which expert agents should review the implementation
- Use delegate() to send the report to appropriate experts for feedback

Step 3: Synthesize and Decide
After receiving all expert reviews, you must decide:
a) If work is approved: Call complete() with final implementation report
b) If revisions needed: Do NOT complete(). Instead, call claude_code again with:
   - The original request
   - Clear, synthesized summary of feedback to address

CRITICAL: You must NOT use file system or shell tools directly. Your entire job is to coordinate between claude_code and expert reviewers until implementation is approved.

Your toolset: ["claude_code", "delegate", "complete"] only.
```

**Planner Instructions Addition:**
- "You receive high-level objectives, not implementation details"
- "First gather guidelines from relevant experts via delegation"
- "Use claude_code to generate the actual plan with expert input"
- "Get plan validated by experts before completing back to PM"
- "Your plan should be based on expert consensus, not assumptions"

#### Universal Delegation

Currently only PM has the `delegate()` tool. We need to:
1. Add it to the default toolset in `getDefaultToolsForAgent()`
2. Ensure all agents understand when and how to use it
3. Update agent instructions to include delegation patterns
4. Ensure specialists know they own discovery and implementation details

#### Entry Point Modification

In `handleNewConversation`, we need to change:

```typescript
// OLD: Complex logic to find orchestrator
const orchestratorAgent = projectCtx.getProjectAgent();

// NEW: Simple default to PM
const targetAgent = mentionedAgent || projectCtx.getAgent("project-manager");
```

#### Phase Context Injection

ConversationManager needs to inject phase context into agent prompts:

```typescript
// In buildAgentMessages
if (conversation.phase) {
    messages.push(new Message("system", `
=== CURRENT PHASE: ${conversation.phase} ===
Goal: ${conversation.phaseTransitions[conversation.phaseTransitions.length - 1]?.reason}
Your role: ${getPhaseRoleForAgent(agent, conversation.phase)}
Expected outcome: ${getPhaseExpectations(conversation.phase)}
    `));
}
```

#### Cleanup

We need to remove:
- Orchestrator prompt fragments (`01-orchestrator-identity.ts`, `25-orchestrator-routing.ts`)
- OrchestratorTurnTracker (the workflow narrative system)
- Phase transition validation in PhaseManager
- All references to "orchestrator" throughout the codebase

## Benefits of This Architecture

### Transparency
Every routing decision is visible in the conversation. Users can see the PM's reasoning: "I'm routing this to the executor because it's a simple fix that doesn't require planning."

### Flexibility  
The PM can adapt workflows to context. A critical production bug might skip planning entirely. A complex architectural change might involve multiple rounds of planning and validation.

### Natural Collaboration
Agents work together like a human team would. The executor can ask the architect for clarification. The planner can get input from domain experts. It's peer-to-peer, not hub-and-spoke.

### Simplicity
One execution model (ReasonActLoop), one coordination mechanism (delegation), one source of truth (conversation history). The system is conceptually much simpler.

### Debuggability
When something goes wrong, the entire workflow is visible in the conversation. You can see exactly what the PM decided, why it made that decision, and how agents collaborated.

## Design Tradeoffs

### PM as Single Point of Failure
If the PM fails, the conversation stalls. This is acceptable because:
- PM has the simplest logic (mostly routing decisions)
- PM is less likely to fail than complex agents like executor
- Users can manually recover by @mentioning another agent
- We could add PM health monitoring if needed

### No Concurrent Phases
We explicitly chose not to support concurrent phases. One conversation = one phase at a time. This keeps the mental model simple and avoids complex synchronization issues.

### Loss of Workflow Narrative
The OrchestratorTurnTracker's elaborate narrative system is gone. Instead, PM builds its understanding from conversation history. This is simpler but potentially less structured.

## Migration Path

The beauty of this architecture is that it's largely a simplification. We're not adding complex new systems; we're removing abstraction layers and making the system more direct. The migration can happen incrementally:

1. **Phase 1**: Create switch_phase tool, update PM instructions
2. **Phase 2**: Modify delegation return paths, make delegate() universal
3. **Phase 3**: Update entry points to route to PM
4. **Phase 4**: Remove orchestrator infrastructure
5. **Phase 5**: Update specialist agents for phase leadership

Each phase can be tested independently, reducing risk.

## Implementation Tracking

**NOTE: This document serves as both the architectural plan AND the implementation tracker. All progress, decisions, and discoveries are tracked here in a single source of truth.**

### Core Implementation Principle
**NO BACKWARDS COMPATIBILITY. CLEAN ARCHITECTURE ONLY.**
We are building the system right, not maintaining legacy code. Breaking changes are not just acceptable - they are encouraged if they lead to cleaner architecture.

### Implementation Milestones

#### MILESTONE 1: Phase Management Tools ✅
- [x] Create `src/tools/implementations/switch_phase.ts`
- [x] Register switch_phase in `src/tools/registry.ts`
- [x] Add switch_phase to PM's toolset exclusively in project-manager.ts
- [ ] Test phase transitions work correctly

**Status:** COMPLETED (except testing)

#### MILESTONE 2: Remove Orchestrator Infrastructure ✅
- [x] Delete `src/agents/built-in/orchestrator.ts` (was already deleted)
- [x] Update `handleNewConversation` to route to PM by default
- [x] Update `handleTask` to route to PM by default
- [x] Update ProjectContext to use PM instead of orchestrator
- [x] Remove `isOrchestrator` from AgentInstance type
- [x] Delete OrchestratorTurnTracker
- [x] Delete orchestrator prompt fragments

**Status:** COMPLETED

**Notes:** 
- getProjectAgent() kept for compatibility but now returns PM
- Some test files still reference orchestrator but those can be cleaned up later

#### MILESTONE 3: NDKTask-Based Delegation ✅
- [x] Update delegate tool to create NDKTask events for each recipient
- [x] Update complete tool to detect task completions
- [x] Add delegate to ALL agents' default toolsets
- [x] Implement NDKTask routing in event handler
- [x] Implement response synthesis for reactivation
- [ ] Add claude session management scoped to tasks

**Status:** MOSTLY COMPLETE

**Implementation Details:**
- Delegate tool now creates NDKTask events (kind 1934) for each recipient
- Complete tool detects task completions and replies appropriately
- Event handler recognizes task completions and reactivates agents when all tasks done
- Response synthesis creates clear summary of all task responses
- Only remaining: Claude session scoping (can be added incrementally)

#### MILESTONE 4: Agent Instructions Overhaul ✅
- [x] Rewrite PM instructions with full routing logic
- [x] Update Planner for phase leadership pattern
- [x] Update Executor for claude_code orchestration
- [x] Change Executor toolset to only: ["claude_code", "delegate", "complete"]
- [x] Add delegation boundary instructions to PM
- [x] Add discovery responsibility to specialists

**Status:** COMPLETED

**Implementation Details:**
- PM now has comprehensive routing logic, phase management, and delegation boundary principles
- Planner updated to be phase lead with expert gathering → plan creation → validation workflow
- Executor updated to be implementation orchestrator with strict claude_code → review → revise cycle
- Both Planner and Executor toolsets updated to include delegate and complete
- Clear boundary: PM passes intent, specialists discover implementation details

#### MILESTONE 5: Clean Up Legacy Systems ✅
- [x] Remove phase validation from PhaseManager (phases.ts updated to allow any→any)
- [x] Delete OrchestratorTurnTracker completely
- [x] Delete orchestrator prompt fragments
- [x] Clean up unused routing imports
- [x] Remove PHASE_TRANSITIONS constants (commented out in phases.ts)
- [ ] Update tests to remove orchestrator references

**Status:** MOSTLY COMPLETE (test cleanup pending)

#### MILESTONE 6: Testing & Validation ✅
- [x] Create test conversations for new PM routing
- [x] Verify delegation chains work
- [x] Test phase transitions
- [x] Validate loop prevention (architectural tests)
- [ ] Check task-scoped sessions (deferred - can be added incrementally)

**Status:** COMPLETED (except Claude session scoping)

### Implementation Summary

#### What We've Accomplished

We have successfully transformed TENEX from a hidden orchestrator model to a PM-centric routing architecture:

1. **Created Phase Management System**
   - Built switch_phase tool for explicit phase transitions
   - PM now controls phases as "modes of work" not rigid states
   - Phases can transition freely based on PM's judgment

2. **Removed Orchestrator Infrastructure**
   - Deleted OrchestratorTurnTracker and its workflow narrative system
   - Removed all orchestrator-specific code and references
   - Updated entry points to route to PM by default
   - Cleaned up type system (removed isOrchestrator flag)

3. **Implemented Phase Leadership Pattern**
   - Planner is now mini-orchestrator for PLAN phase
   - Executor is now mini-orchestrator for EXECUTE phase
   - Both have delegation capabilities for expert collaboration
   - Clear workflow: gather → create → validate → return

4. **Established Clear Delegation Boundaries**
   - PM passes high-level intent, not implementation details
   - Specialists own discovery and implementation
   - No more file paths or code snippets in delegation requests
   - Example: "implement authentication" not "modify auth.ts"

5. **Updated Agent Instructions**
   - PM has comprehensive routing logic and phase management
   - Planner orchestrates planning with expert input
   - Executor manages implement-review-revise cycles
   - All agents understand their role in the new architecture

#### What's Still Needed

1. **NDKTask Implementation** (MILESTONE 3)
   - This is the most complex remaining task
   - Requires updating delegate/complete tools
   - Need proper event handling and task tracking
   - Task-scoped Claude sessions for iterative refinement

2. **Testing & Validation** (MILESTONE 6)
   - Test the new PM routing patterns
   - Verify delegation chains work correctly
   - Clean up test files that reference orchestrator
   - End-to-end validation of workflows

### Implementation Notes

#### Gaps Discovered During Implementation
- NDKTask implementation is complex and requires careful coordination with event handling
- The delegate tool currently uses a simpler event-based approach, upgrading to NDKTask requires:
  - Creating NDKTask events for each recipient
  - Tracking task IDs in pendingDelegation state
  - Handling task completion events differently
- Many test files still reference orchestrator - need comprehensive test update

#### Critical Decisions Made
- Kept PM as single entry point (no concurrent orchestrators)
- Made phases vocabulary not state machine (soft transitions)
- Phase leads get full autonomy during their phase
- Delegation creates formal sub-tasks not just messages
- Complete() returns to delegator not PM (call stack pattern)
- Claude sessions scoped to tasks not conversations
- **"Dormant state" is just passive data, not an active process** - event-driven callbacks, not state machines
- NDKTask provides semantic clarity and structure without complexity

#### Files to Delete (Be Ruthless)
- `src/agents/built-in/orchestrator.ts`
- `src/conversations/services/OrchestratorTurnTracker.ts`
- `src/prompts/fragments/01-orchestrator-identity.ts`
- `src/prompts/fragments/25-orchestrator-routing.ts`
- `src/prompts/fragments/15-orchestrator-available-agents.ts`
- All orchestrator debugger code

#### Critical Success Criteria
1. PM can engage users in conversation without immediate delegation
2. PM correctly routes to appropriate phases based on task complexity
3. Agents can delegate to multiple recipients in parallel
4. Complete() returns to the delegating agent, not PM
5. Claude sessions are properly scoped to NDKTasks
6. No routing loops occur
7. The system is simpler than before

## Conclusion

This architecture transforms TENEX from a system with hidden orchestration to one with transparent, intelligent coordination. The PM becomes a true project manager - understanding context, making decisions, and coordinating the team. Agents become more autonomous, able to collaborate directly when needed. The entire system becomes simpler, more flexible, and more maintainable.

The key insight is that orchestration doesn't need to be magic - it can be a visible, understandable part of the conversation. By making the PM the orchestrator, we align the system architecture with how human teams actually work.
</file>

<file path="project-less-agents-analysis.md">
# Project-Less Agents: Analysis & Design Suggestions

## Executive Summary
Enable agents to operate independently of projects, allowing direct chat interactions without requiring project context. This would create a more flexible, modular agent system suitable for standalone tools, personal assistants, and microservices.

## Current Architecture Analysis

### Core Dependencies on Projects

#### 1. **ProjectContext Coupling** 
- `src/services/ProjectContext.ts:51-86`: Orchestrator hardwired to project
- `src/agents/AgentRegistry.ts:296-304`: Project-manager agent uses project title
- All agent operations assume ProjectContext exists

#### 2. **Event Routing Architecture**
- `src/event-handler/index.ts:9`: Requires getProjectContext()
- Events filtered by project naddr (NDKProject reference)
- Orchestrator assumed to exist for all routing decisions

#### 3. **Conversation Persistence**
- `src/conversations/ConversationManager.ts:34-45`: Tied to projectPath
- Conversations stored in `.tenex/conversations/` under project

#### 4. **Agent Discovery & Registration**
- `src/agents/AgentRegistry.ts:54-106`: Loads both global and project agents
- Project agents override global agents with same slug/eventId

## Design Suggestions

### Solution 1: **Standalone Agent Mode** (KISS/YAGNI)
*Minimal changes, maximum compatibility*

```typescript
// New: src/agents/StandaloneAgentRunner.ts
class StandaloneAgentRunner {
    private agent: AgentInstance;
    private conversationManager: StandaloneConversationManager;
    
    constructor(agentSlug: string) {
        // Load from global registry only
        const registry = new AgentRegistry(getGlobalPath(), true);
        this.agent = registry.getAgent(agentSlug);
        
        // Use memory-only conversation management
        this.conversationManager = new StandaloneConversationManager();
    }
    
    async handleDirectMessage(event: NDKEvent): Promise<void> {
        // Direct execution without orchestrator routing
        const executor = new AgentExecutor(this.llmService, this.ndk);
        await executor.executeAgent(this.agent, event.content);
    }
}
```

**Changes Required:**
- Extract conversation management interface (SRP)
- Add memory-only persistence adapter
- New CLI command: `tenex agent chat <agent-slug>`
- Skip orchestrator for standalone mode

### Solution 2: **Virtual Project Context** (DRY)
*Reuse existing infrastructure with minimal modifications*

```typescript
// Modify: src/services/ProjectContext.ts
class ProjectContext {
    static createVirtual(agent: AgentInstance): ProjectContext {
        // Create lightweight context without NDKProject
        const virtualProject = {
            id: `virtual-${agent.pubkey}`,
            title: agent.name,
            tagValue: (tag: string) => null,
            pubkey: agent.pubkey
        };
        
        // Agent acts as its own orchestrator
        return new ProjectContext(virtualProject as any, new Map([
            [agent.slug, { ...agent, isOrchestrator: true }]
        ]));
    }
}
```

**Changes Required:**
- Make NDKProject optional in ProjectContext
- Add virtual project support to EventHandler
- Modify SubscriptionManager to handle agent-only subscriptions

### Solution 3: **Agent Service Architecture** (Clean Architecture)
*Proper separation of concerns, most flexible*

```typescript
// New: src/agents/service/AgentService.ts
interface AgentRuntime {
    handleMessage(message: string, context?: RuntimeContext): Promise<string>;
    getCapabilities(): AgentCapabilities;
}

class ProjectAgentRuntime implements AgentRuntime {
    constructor(private projectContext: ProjectContext) {}
    // Existing project-based logic
}

class StandaloneAgentRuntime implements AgentRuntime {
    constructor(private agent: AgentInstance) {}
    // Direct agent execution
}

// Factory pattern for runtime selection
class AgentRuntimeFactory {
    static create(options: RuntimeOptions): AgentRuntime {
        if (options.projectPath) {
            return new ProjectAgentRuntime(await loadProject(options.projectPath));
        }
        return new StandaloneAgentRuntime(await loadAgent(options.agentSlug));
    }
}
```

**Changes Required:**
- Extract agent runtime interface
- Implement standalone and project runtimes
- Update CLI to use factory pattern
- Separate concerns: routing, execution, persistence

## Implementation Recommendations

### Phase 1: Foundation (Week 1)
1. Extract interfaces for ConversationManager, AgentExecutor
2. Create memory-only persistence adapter
3. Add `isStandalone` flag to AgentInstance

### Phase 2: Standalone Mode (Week 2)
1. Implement StandaloneAgentRunner
2. Add `tenex agent chat` command
3. Create direct NDK subscription for agent pubkey

### Phase 3: Enhanced Features (Week 3)
1. Add conversation history for standalone agents
2. Implement agent-to-agent communication without projects
3. Create agent marketplace/registry integration

## Key Design Decisions

### 1. **Conversation Persistence**
- **Option A**: Memory-only for standalone (simpler, stateless)
- **Option B**: SQLite per agent (persistent, complex)
- **Recommendation**: Start with A, migrate to B if needed

### 2. **Event Subscription**
- **Option A**: Direct pubkey subscription (simple, efficient)
- **Option B**: Virtual project events (reuses infrastructure)
- **Recommendation**: Option A for true independence

### 3. **Orchestrator Role**
- **Option A**: No orchestrator for standalone (direct execution)
- **Option B**: Agent as self-orchestrator (maintains patterns)
- **Recommendation**: Option A, cleaner separation

### 4. **Configuration Storage**
- **Current**: Global agents in ~/.tenex/agents/
- **Enhancement**: Add ~/.tenex/standalone/ for runtime state
- **Recommendation**: Keep using global registry as-is

## Migration Path

### Backwards Compatibility
- All existing project-based flows unchanged
- Global agents can work in both modes
- Progressive enhancement approach

### Configuration Changes
```json
// ~/.tenex/agents.json
{
  "my-assistant": {
    "nsec": "...",
    "file": "my-assistant.json",
    "standalone": true,  // New flag
    "subscriptions": {   // New: direct subscription config
      "relays": ["wss://relay.example.com"],
      "filters": { "kinds": [1], "#p": ["agent-pubkey"] }
    }
  }
}
```

## Benefits

1. **Modularity**: Agents become true microservices
2. **Scalability**: Deploy agents independently
3. **Flexibility**: Mix project and standalone agents
4. **Simplicity**: Direct agent interaction without overhead
5. **Marketplace**: Easier agent distribution and discovery

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Code duplication | Medium | Extract shared interfaces early |
| Feature parity | Low | Document standalone limitations |
| User confusion | Medium | Clear CLI help and docs |
| State management | High | Start stateless, add persistence later |

## Conclusion

The **Standalone Agent Mode** (Solution 1) offers the best balance of simplicity and functionality while adhering to KISS/YAGNI principles. It requires minimal changes to existing code, maintains backwards compatibility, and provides a clear upgrade path to more sophisticated solutions if needed.

The implementation should focus on:
1. Clean interface extraction (SRP)
2. Memory-only operation initially (YAGNI)
3. Direct NDK subscriptions (KISS)
4. Reusing existing AgentExecutor without orchestrator overhead (DRY)

This approach enables immediate value while keeping the door open for future enhancements like persistent conversations, agent marketplaces, and sophisticated routing mechanisms.
</file>

<file path="standalone-agent-nostr-plan.md">
# Standalone Agent Nostr Communication Plan

## Current State Analysis

### How P-Tag Subscriptions Work Now
From `SubscriptionManager.ts:65-67`:
- The system subscribes to events with `#p` tags matching agent pubkeys
- This allows direct messaging to agents by p-tagging them
- Works within project context where all agents are known

### Event Flow
1. User creates Nostr event with `#p: [agent-pubkey]`
2. SubscriptionManager catches it via `{ "#p": agentPubkeys }` filter
3. EventHandler routes to appropriate conversation/agent
4. AgentExecutor builds context and executes

## Standalone Agent Communication Design

### Option 1: Direct P-Tag Subscription (Recommended)
**Simple, clean, follows existing patterns**

```typescript
// StandaloneAgentListener.ts
export class StandaloneAgentListener {
    private subscription?: NDKSubscription;
    
    constructor(
        private agent: AgentInstance,
        private llmService: LLMService,
        private ndk: NDK
    ) {}
    
    async start(): Promise<void> {
        // Subscribe to events that p-tag this agent
        const filter: NDKFilter = {
            "#p": [this.agent.pubkey],
            kinds: [1, 1111], // Text notes and replies
        };
        
        this.subscription = this.ndk.subscribe(filter, {
            closeOnEose: false,
            groupable: false,
        });
        
        this.subscription.on("event", async (event: NDKEvent) => {
            await this.handleDirectMessage(event);
        });
    }
    
    private async handleDirectMessage(event: NDKEvent): Promise<void> {
        // Create standalone components
        const persistence = new InMemoryPersistenceAdapter();
        const resolver = new StandaloneAgentResolver(
            new Map([[this.agent.slug, this.agent]])
        );
        
        // Create conversation manager with standalone components
        const conversationManager = new ConversationManager(
            `/tmp/standalone-${this.agent.slug}`,
            persistence
        );
        await conversationManager.initialize();
        
        // Create or get conversation
        let conversation = conversationManager.getConversationByEvent(event.id);
        if (!conversation) {
            conversation = await conversationManager.createConversation(event);
        }
        
        // Create standalone context
        const standaloneContext: StandaloneAgentContext = {
            agents: new Map([[this.agent.slug, this.agent]]),
            pubkey: this.agent.pubkey,
            signer: this.agent.signer,
        };
        
        // Execute with standalone context
        const executor = new AgentExecutor(
            this.llmService, 
            conversationManager,
            standaloneContext
        );
        
        const context: ExecutionContext = {
            conversationId: conversation.id,
            agent: this.agent,
            phase: PHASES.CHAT, // Default to CHAT for standalone
            triggeringEvent: event,
            conversationManager,
        };
        
        await executor.execute(context);
    }
}
```

### Option 2: Virtual Project Wrapper
**Reuses more existing code but adds complexity**

```typescript
// Create a minimal virtual project
const virtualProject = {
    id: `standalone-${agent.slug}`,
    encode: () => `standalone-${agent.slug}`,
    tagValue: (tag: string) => {
        if (tag === "title") return agent.name;
        if (tag === "d") return agent.slug;
        return null;
    },
    filter: () => ({ "#d": [agent.slug] }),
    tags: [],
    pubkey: agent.pubkey,
} as any as NDKProject;

// Use existing SubscriptionManager with virtual project
```

### Option 3: Agent-as-a-Service
**Most flexible, supports multiple conversation types**

```typescript
interface StandaloneAgentService {
    // Direct messages (kind 1 with p-tag)
    handleDirectMessage(event: NDKEvent): Promise<void>;
    
    // Mentions in conversations (kind 1 with p-tag in existing conversation)
    handleMention(event: NDKEvent, conversationId: string): Promise<void>;
    
    // Task assignments (kind 5206)
    handleTask(task: NDKTask): Promise<void>;
    
    // Spec requests (kind 1111 with K:30023)
    handleSpecRequest(event: NDKEvent): Promise<void>;
}
```

## Implementation Recommendations

### Phase 1: Basic Direct Messaging
1. Implement `StandaloneAgentListener` (Option 1)
2. Add CLI command: `tenex agent chat <agent-slug>`
3. Test with simple text exchanges

### Phase 2: Conversation Threading
1. Track conversation threads via `e` tags
2. Maintain conversation history in memory
3. Support multi-turn conversations

### Phase 3: Enhanced Features
1. Persistent conversation storage (SQLite)
2. Multiple standalone agents in same process
3. Agent-to-agent communication

## CLI Command Implementation

```typescript
// src/commands/agent/chat.ts
import { Command } from "commander";
import { StandaloneAgentListener } from "@/agents/standalone/StandaloneAgentListener";

export const agentChatCommand = new Command("chat")
    .description("Start a standalone agent that responds to Nostr messages")
    .argument("<agent-slug>", "Agent to run in standalone mode")
    .option("--relay <url>", "Custom relay URL", "wss://relay.damus.io")
    .action(async (agentSlug: string, options) => {
        // 1. Load agent from global registry
        const registry = new AgentRegistry(getGlobalPath(), true);
        await registry.loadFromProject();
        const agent = registry.getAgent(agentSlug);
        
        if (!agent) {
            logger.error(`Agent "${agentSlug}" not found in global registry`);
            process.exit(1);
        }
        
        // 2. Initialize NDK with custom relay if provided
        const ndk = await initializeNDK({
            relays: [options.relay],
        });
        
        // 3. Load LLM service
        const llmService = await loadLLMRouter(getGlobalPath());
        
        // 4. Start standalone listener
        const listener = new StandaloneAgentListener(agent, llmService, ndk);
        await listener.start();
        
        logger.info(`✅ Agent "${agent.name}" is now listening for messages`);
        logger.info(`   Pubkey: ${agent.pubkey}`);
        logger.info(`   Relay: ${options.relay}`);
        logger.info(`   `);
        logger.info(`To chat with this agent, p-tag it in a Nostr event:`);
        logger.info(`   Event content: "Hello agent!"`);
        logger.info(`   Tags: [["p", "${agent.pubkey}"]]`);
        
        // Keep process running
        await new Promise(() => {});
    });
```

## Testing Strategy

### Unit Tests
```typescript
describe('StandaloneAgentListener', () => {
    it('should respond to p-tagged events', async () => {
        const mockAgent = createMockAgent();
        const listener = new StandaloneAgentListener(mockAgent, mockLLM, mockNDK);
        
        const event = createMockEvent({
            content: "Hello agent",
            tags: [["p", mockAgent.pubkey]]
        });
        
        await listener.handleDirectMessage(event);
        
        expect(mockPublisher.publish).toHaveBeenCalledWith(
            expect.objectContaining({
                content: expect.stringContaining("Hello"),
                tags: expect.arrayContaining([["e", event.id]])
            })
        );
    });
});
```

### Integration Tests
1. Start standalone agent
2. Send Nostr event with p-tag
3. Verify response event is published
4. Check conversation threading works

## Benefits of This Approach

1. **Minimal Changes**: Reuses existing AgentExecutor with standalone context
2. **Clean Separation**: No project dependencies in standalone mode
3. **Nostr Native**: Uses standard p-tagging for agent communication
4. **Flexible**: Can be extended for groups, channels, etc.
5. **Testable**: Each component can be tested independently

## Migration Path

1. **Week 1**: Implement StandaloneAgentListener and basic CLI
2. **Week 2**: Add conversation persistence and threading
3. **Week 3**: Support multiple agents and agent-to-agent communication
4. **Week 4**: Production hardening and monitoring

## Security Considerations

1. **Rate Limiting**: Prevent spam by tracking event rates per pubkey
2. **Authentication**: Verify event signatures before processing
3. **Resource Limits**: Cap conversation history and memory usage
4. **Relay Selection**: Use trusted relays or allow user configuration
</file>

<file path="SYSTEM_PROMPT_ARCHITECTURE_REPORT.md">
# System Prompt Architecture Analysis & Restructuring Proposals

## Executive Summary

The TENEX system prompt generation architecture is sophisticated but shows signs of organic growth that has led to complexity and inconsistencies. This report provides a deep analysis of the current system and proposes three restructuring plans ranging from incremental improvements to a complete architectural overhaul.

## Current Architecture Overview

### Core Components

1. **PromptBuilder** (`src/prompts/core/PromptBuilder.ts`)
   - Central orchestrator for assembling prompt fragments
   - Handles fragment prioritization and conditional inclusion
   - Concatenates fragments with proper formatting

2. **FragmentRegistry** (`src/prompts/core/FragmentRegistry.ts`)
   - Singleton pattern for managing all prompt fragments
   - Auto-registration on import
   - Global access to all fragments

3. **System Prompt Builder** (`src/prompts/utils/systemPromptBuilder.ts`)
   - Main entry point: `buildSystemPromptMessages()`
   - Returns array of `SystemMessage` objects with caching metadata
   - Orchestrates fragment assembly for different agent types

4. **ConversationManager** (`src/conversations/ConversationManager.ts`)
   - Injects dynamic conversation context
   - Handles "messages while you were away" blocks
   - Manages phase transitions and instructions

5. **Phase Instructions Builder** (`src/prompts/utils/phaseInstructionsBuilder.ts`)
   - Generates dynamic phase-specific instructions
   - Handles phase transitions
   - Injected as system messages during conversation

## Key Issues Identified

### 1. Multiple Injection Points for Dynamic Content

**Problem**: System prompts are assembled at multiple stages:
- Static fragments in `buildSystemPromptMessages()`
- Dynamic phase instructions in `ConversationManager.buildAgentMessages()` 
- Debug mode injection in `AgentExecutor.buildMessages()`
- Backend-specific additions (e.g., JSON-only instruction in `RoutingBackend`)

**Impact**: Difficult to understand the complete prompt an agent receives without tracing through multiple files.

### 2. Orchestrator Logic Scattered Across Fragments

**Problem**: Many fragments contain `if (isOrchestrator)` conditional logic:
- `agent-system-prompt`
- `conversation-history-instructions`
- `expertise-boundaries`
- Others

**Impact**: Orchestrator-specific behavior is spread across multiple files rather than centralized.

### 3. Inconsistent Dynamic vs Static Content Separation

**Problem**: Some dynamic content is in fragments (e.g., `retrieved-lessons`), while other dynamic content is injected later (e.g., phase instructions, debug mode).

**Impact**: No clear principle for what belongs in a fragment vs what should be injected dynamically.

### 4. Phase Management Complexity

**Problem**: Phase-related prompts are handled in three different places:
- `phase-definitions` fragment (static definitions)
- `phase-context` and `phase-constraints` fragments (removed from main prompt, injected dynamically)
- `buildPhaseInstructions()` for dynamic transitions

**Impact**: Phase logic is fragmented and hard to follow.

### 5. Tool Prompt Fragment Inconsistency

**Problem**: 
- Native tools use manual `promptFragment` strings
- MCP tools dynamically generate from schemas
- No standardized format for tool instructions

**Impact**: Inconsistent tool documentation quality in prompts.

### 6. Caching Strategy Unclear

**Problem**: The `SystemMessage` interface includes caching metadata, but:
- Only PROJECT.md and inventory are marked cacheable
- No clear strategy for what should be cached
- Caching keys don't account for all variables

**Impact**: Potential performance optimizations are not fully realized.

### 7. Message Role Attribution Complexity

**Problem**: `ConversationManager.buildAgentMessages()` has complex logic for:
- Determining message roles (user/assistant/system)
- Attribution of other agents' messages
- Handling "messages while away" blocks

**Impact**: High cognitive load to understand conversation history formatting.

## Restructuring Proposals

### Plan A: Incremental Improvements (Low Risk, 2-3 weeks)

Focus on improving the existing architecture without major breaking changes.

#### Changes:
1. **Centralize Dynamic Injections**
   - Create `DynamicPromptInjector` class
   - Move all dynamic injections (phase, debug, backend-specific) to one place
   - Clear interface for when/what gets injected

2. **Agent Type Profiles**
   - Create `OrchestratorPromptProfile` and `SpecialistPromptProfile`
   - Move type-specific logic from fragments to profiles
   - Fragments become purely content-focused

3. **Standardize Tool Documentation**
   - Create `ToolDocumentationGenerator` interface
   - Implement for both native and MCP tools
   - Consistent format for all tool instructions

4. **Improve Fragment Organization**
   - Group fragments by category (identity, guidelines, tools, context)
   - Clear naming convention (prefix with category)
   - Documentation for each fragment's purpose

5. **Enhanced Caching Strategy**
   - Define clear caching rules
   - Add cache key generation utilities
   - Mark more static content as cacheable

#### Benefits:
- Minimal disruption to existing code
- Gradual migration possible
- Immediate clarity improvements

#### Drawbacks:
- Doesn't address fundamental architectural issues
- Still multiple injection points
- Complexity remains, just better organized

### Plan B: Unified Prompt Pipeline (Medium Risk, 4-6 weeks)

Redesign prompt generation as a single, clear pipeline with defined stages.

#### Architecture:
```typescript
interface PromptPipeline {
  stages: PromptStage[];
  execute(context: PromptContext): SystemMessage[];
}

interface PromptStage {
  name: string;
  priority: number;
  canCache: boolean;
  process(context: PromptContext): PromptContent | null;
}
```

#### Stages:
1. **Identity Stage**: Agent identity and role
2. **Guidelines Stage**: General behavioral guidelines
3. **Project Context Stage**: PROJECT.md, inventory
4. **Tools Stage**: Available tools and instructions
5. **Conversation Stage**: History and context
6. **Phase Stage**: Current phase and transitions
7. **Dynamic Stage**: Runtime injections (debug, etc.)
8. **Backend Stage**: Backend-specific requirements

#### Implementation:
```typescript
// Single entry point for ALL prompt generation
class UnifiedPromptBuilder {
  private pipeline: PromptPipeline;
  
  buildPrompt(context: CompletePromptContext): SystemMessage[] {
    return this.pipeline.execute(context);
  }
}

// All context in one place
interface CompletePromptContext {
  agent: AgentInstance;
  conversation: Conversation;
  phase: Phase;
  triggeringEvent: NDKEvent;
  debugMode: boolean;
  backend: ExecutionBackend;
  // ... all other context
}
```

#### Benefits:
- Single source of truth for prompt generation
- Clear, traceable pipeline
- Easy to add/remove/reorder stages
- Better testability
- Clear caching boundaries

#### Drawbacks:
- Requires significant refactoring
- All consumers need updates
- Risk of regression

### Plan C: Component-Based Architecture (High Risk, 6-8 weeks)

Complete architectural overhaul using a component-based system with dependency injection.

#### Core Concepts:

```typescript
// Prompt components with dependencies
interface PromptComponent {
  id: string;
  dependencies: string[];
  provides: string[];
  render(context: RenderContext): PromptContent;
}

// Component registry with dependency resolution
class PromptComponentRegistry {
  register(component: PromptComponent): void;
  resolve(requirements: string[]): PromptComponent[];
}

// Agent-specific prompt specifications
interface PromptSpecification {
  agentType: "orchestrator" | "specialist";
  requires: string[];
  phases: PhaseSpecification[];
}

// Phase-specific modifications
interface PhaseSpecification {
  phase: Phase;
  add: string[];
  remove: string[];
  modify: ComponentModification[];
}
```

#### Example Usage:
```typescript
// Define what each agent needs
const specialistSpec: PromptSpecification = {
  agentType: "specialist",
  requires: ["identity", "guidelines", "tools", "boundaries"],
  phases: [
    {
      phase: "PLAN",
      add: ["planning-guidelines"],
      remove: ["execution-tools"]
    },
    {
      phase: "EXECUTE", 
      add: ["execution-guidelines", "mcp-tools"],
      remove: ["planning-guidelines"]
    }
  ]
};

// Components declare what they provide
const identityComponent: PromptComponent = {
  id: "agent-identity",
  dependencies: [],
  provides: ["identity"],
  render: (ctx) => generateIdentity(ctx.agent)
};

// Automatic dependency resolution
const builder = new ComponentPromptBuilder(registry);
const messages = builder.build(specialistSpec, context);
```

#### Advanced Features:

1. **Component Composition**
   - Components can depend on other components
   - Automatic ordering based on dependencies
   - Circular dependency detection

2. **Dynamic Component Loading**
   - Load components based on agent configuration
   - Plugin system for custom components
   - Hot-reloading in development

3. **Prompt Versioning**
   ```typescript
   interface VersionedPromptComponent extends PromptComponent {
     version: string;
     compatibleWith: string[];
   }
   ```

4. **Testing Framework**
   ```typescript
   class PromptTestHarness {
     withComponents(components: PromptComponent[]): this;
     withContext(context: Partial<RenderContext>): this;
     assertContains(text: string): this;
     assertOrder(first: string, second: string): this;
   }
   ```

#### Benefits:
- Maximum flexibility and extensibility
- Clear separation of concerns
- Highly testable
- Supports complex agent types
- Future-proof architecture

#### Drawbacks:
- Complete rewrite required
- High complexity initially
- Steep learning curve
- Risk of over-engineering

## Recommendation

**Recommended Approach: Plan B (Unified Prompt Pipeline)**

This provides the best balance of improvement vs risk. It addresses the core issues while maintaining a reasonable implementation timeline.

### Implementation Strategy:

1. **Phase 1** (Week 1-2): Build pipeline infrastructure alongside existing system
2. **Phase 2** (Week 2-3): Migrate fragments to pipeline stages
3. **Phase 3** (Week 3-4): Update consumers to use new pipeline
4. **Phase 4** (Week 4-5): Remove old system
5. **Phase 5** (Week 5-6): Optimization and caching improvements

### Success Metrics:

- Reduced lines of code for prompt generation
- Improved test coverage (target: >80%)
- Faster prompt generation (target: 20% improvement)
- Easier onboarding for new developers
- Clear documentation and examples

## Migration Path

Regardless of chosen plan, migration should follow these principles:

1. **Parallel Implementation**: Build new system alongside old
2. **Feature Flags**: Toggle between old/new per agent
3. **Incremental Migration**: One agent type at a time
4. **Comprehensive Testing**: Full regression suite
5. **Performance Monitoring**: Track metrics before/after
6. **Documentation First**: Update docs before code
7. **Team Review**: Architecture review at each milestone

## Conclusion

The current system prompt architecture, while functional, has accumulated technical debt through organic growth. The proposed restructuring plans offer paths to a more maintainable, performant, and understandable system. Plan B (Unified Prompt Pipeline) offers the best return on investment, providing significant improvements without excessive risk or complexity.
</file>

<file path="test-delegate-tools.js">
// Test different agent types
⋮----
console.log("Agent Tool Configuration Test:\n");
console.log("=".repeat(50));
⋮----
agents.forEach(agent => {
const tools = getDefaultToolsForAgent(agent);
const hasDelegate = tools.includes("delegate");
⋮----
console.log(`\n${agent.name} (${agent.slug}):`);
console.log(`  Has delegate tool: ${hasDelegate ? '✅ YES' : '❌ NO'}`);
console.log(`  Total tools: ${tools.length}`);
⋮----
console.log(`  Tools: ${tools.join(', ')}`);
⋮----
console.log("\n" + "=".repeat(50));
console.log("\n✅ Summary: Only project-manager should have delegate tool");
</file>

<file path="patches/multi-llm-ts+4.3.6.patch">
diff --git a/node_modules/multi-llm-ts/dist/index.js b/node_modules/multi-llm-ts/dist/index.js
index f69336c..7a365e6 100644
--- a/node_modules/multi-llm-ts/dist/index.js
+++ b/node_modules/multi-llm-ts/dist/index.js
@@ -776,7 +776,12 @@ var openai_default = class extends LlmEngine {
         logger_default.log(`[openai] tool call ${tool_call.function.name} with ${tool_call.function.arguments}`);
         let args = null;
         try {
-          args = JSON.parse(tool_call.function.arguments);
+          // Handle empty string as empty object for tools with no required parameters
+          if (tool_call.function.arguments === "" || tool_call.function.arguments === "{}") {
+            args = {};
+          } else {
+            args = JSON.parse(tool_call.function.arguments);
+          }
         } catch (err) {
           throw new Error(`[openai] tool call ${tool_call.function.name} with invalid JSON args: "${tool_call.function.arguments}"`, { cause: err });
         }
</file>

<file path="scripts/build-bundled.js">
const packageJson = JSON.parse(
readFileSync(join(process.cwd(), 'package.json'), 'utf8')
⋮----
// Get all dependencies to mark as external
⋮----
...Object.keys(packageJson.dependencies || {}),
...Object.keys(packageJson.peerDependencies || {}),
⋮----
const aliasPlugin = alias({
'@': resolve(process.cwd(), 'src'),
⋮----
// Resolve TypeScript paths
⋮----
async function buildAll() {
⋮----
console.log('🏗️  Building TENEX CLI...');
⋮----
// Build all TypeScript files without bundling
await build({
⋮----
// Build CLI executable with bundling
⋮----
// Mark all Node built-ins as external
⋮----
console.log('✅ Build completed successfully!');
⋮----
console.error('❌ Build failed:', error);
process.exit(1);
⋮----
buildAll();
</file>

<file path="src/agents/__tests__/AgentPublisher.test.ts">
import { describe, it, expect, beforeEach, mock, spyOn } from "bun:test";
import { AgentPublisher } from "../AgentPublisher";
import type { AgentConfig } from "../types";
import { EVENT_KINDS } from "@/llm";
import type NDK from "@nostr-dev-kit/ndk";
import { type NDKPrivateKeySigner } from "@nostr-dev-kit/ndk";
⋮----
// Mock implementations
⋮----
// Mock the NDKEvent constructor
⋮----
// Module mock
⋮----
// Mock logger
⋮----
// Import logger after mocking
import { logger } from "@/utils/logger";
⋮----
// Clear all mocks
⋮----
// Reset mock event
⋮----
// Mock project event (kind:31933)
⋮----
// Verify NDKEvent was created with correct data
⋮----
// Verify project was tagged properly
⋮----
// Verify profile content includes all required fields
⋮----
// Verify event was signed and published
⋮----
// Set up mock to track tags being added
⋮----
// Verify project was tagged
⋮----
// Verify e-tag was added
⋮----
// Verify event was signed and published
⋮----
// Verify NDKEvent was created
⋮----
// Verify project was tagged
⋮----
// Verify name tag was added
⋮----
// Verify event was signed and published
⋮----
// Verify returned event
⋮----
// Set up mock to track tags being added
⋮----
// Verify project was tagged
⋮----
// Verify e-tag was added for NDKAgentDefinition event
⋮----
// Verify both events were created
⋮----
// First call should be profile event (kind 0)
⋮----
// Second call should be request event
⋮----
// Verify both were signed and published
⋮----
// Set up mock to track tags
⋮----
// Both events should have been created
⋮----
// Both events should tag the project
⋮----
// Verify request was not attempted after profile failure
⋮----
// First publish succeeds, second fails
⋮----
// Verify both events were attempted
</file>

<file path="src/agents/__tests__/AgentRegistry.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { AgentRegistry } from "../AgentRegistry";
import type { AgentConfig } from "@/agents/types";
⋮----
import { configService } from "@/services";
import { nip19 } from "nostr-tools";
⋮----
// Mock file system
⋮----
// Mock config service
⋮----
// Mock built-in agents to avoid them being loaded during tests
⋮----
// Reset mocks
⋮----
// Ensure agent developer
⋮----
// Ensure agent reviewer
⋮----
// Should not throw, but set empty registry
⋮----
nsec: "", // Empty nsec
⋮----
// Clear write mock to check it's not called again
⋮----
// Check that writeJsonFile was called for the tester agent
⋮----
// Ensure a developer agent
⋮----
// Ensure agents
</file>

<file path="src/agents/__tests__/utils.normalization.test.ts">
import { findAgentByName } from "../utils";
import type { AgentInstance } from "../types";
⋮----
// Set up test agents
</file>

<file path="src/agents/built-in/planner.ts">
import type { BuiltInAgentDefinition } from "../builtInAgents";
</file>

<file path="src/agents/execution/control-flow-types.ts">
import type { Complete, CompletionSummary, ConversationResult } from "@/tools/core";
⋮----
// Type guards for tool outputs
⋮----
export function isComplete(output: unknown): output is Complete
⋮----
export function isCompletionSummary(completion: unknown): completion is CompletionSummary
⋮----
export function isConversationResult(result: unknown): result is ConversationResult
</file>

<file path="src/claude/executor.ts">
import { logger } from "@/utils/logger";
import { type SDKMessage, query } from "@anthropic-ai/claude-code";
import type { ContentBlock, TextBlock } from "@anthropic-ai/sdk/resources/messages/messages";
import { getLLMLogger } from "@/llm/callLogger";
import type { CompletionRequest, CompletionResponse } from "@/llm/types";
import { Message } from "multi-llm-ts";
⋮----
export interface ClaudeCodeExecutorOptions {
    prompt: string;
    projectPath: string;
    systemPrompt?: string;
    timeout?: number;
    abortSignal?: AbortSignal;
    resumeSessionId?: string;
    agentName?: string;
}
⋮----
export interface ClaudeCodeResult {
    success: boolean;
    sessionId?: string;
    totalCost: number;
    messageCount: number;
    duration: number;
    assistantMessages: string[];
    error?: string;
}
⋮----
/**
 * Low-level executor for Claude Code SDK
 * Single Responsibility: Execute Claude Code and stream raw SDK messages
 * Has NO knowledge of Nostr or tasks
 */
export class ClaudeCodeExecutor
⋮----
constructor(private options: ClaudeCodeExecutorOptions)
⋮----
// Link external abort signal if provided
⋮----
/**
     * Execute Claude Code and stream SDK messages
     * @yields Raw SDKMessage events from the Claude Code SDK
     * @returns Final execution result with metrics
     */
async *execute(): AsyncGenerator<SDKMessage, ClaudeCodeResult, unknown>
⋮----
// Prepare data for logging
⋮----
// Build request object for logging
⋮----
// Log the request details
⋮----
// Set timeout if specified
⋮----
// Clear timeout if aborted early
⋮----
// Log resume session ID if present
⋮----
// Stream messages from Claude Code SDK
⋮----
// Extract metrics from messages
⋮----
// Yield the message to the caller
⋮----
// Clear timeout on success
⋮----
// Log successful completion to JSONL
⋮----
// Claude Code doesn't provide token counts
⋮----
// Create a resolved config for logging
⋮----
apiKey: "claude-code-sdk", // Placeholder since it uses SDK
⋮----
// Log error to JSONL
⋮----
/**
     * Extract text content from an assistant message
     */
private extractTextContent(message: SDKMessage): string
⋮----
kill(): void
⋮----
isRunning(): boolean
</file>

<file path="src/commands/agent/list.ts">
import { AgentRegistry } from "@/agents/AgentRegistry";
import type { AgentInstance } from "@/agents/types";
import { configService } from "@/services/ConfigService";
import { logger } from "@/utils/logger";
import { Command } from "commander";
⋮----
interface ListOptions {
    project?: boolean;
    global?: boolean;
    all?: boolean;
}
⋮----
// Default to showing all agents
⋮----
// Validate options
⋮----
// Load and display global agents
⋮----
// Load and display project agents
⋮----
// Load global agents to check for overrides
⋮----
// Load project registry
⋮----
// Categorize agents
⋮----
// Show project-specific agents first
⋮----
// Show overridden agents
</file>

<file path="src/commands/debug/timeline.ts">
import { promises as fs } from "node:fs";
⋮----
import chalk from "chalk";
import type { CommandModule } from "yargs";
import { ConversationManager } from "@/conversations/ConversationManager";
import type { LLMCallLogEntry } from "@/llm/callLogger";
import type { ToolCallLogEntry } from "@/tools/toolLogger";
import { selectConversation } from "./conversationSelector";
import { formatDuration } from "@/utils/formatting";
import { logInfo, logWarning, logError } from "@/utils/logger";
⋮----
interface TimelineEvent {
    timestamp: number;
    type: "conversation_start" | "llm_call" | "tool_call" | "phase_transition" | "message" | "agent_handoff";
    agent?: string;
    description: string;
    details?: Record<string, unknown>;
    duration?: number;
}
⋮----
async handler(argv)
⋮----
// Initialize conversation manager
⋮----
// Get conversation ID either from argument or selector
⋮----
// Get conversation data
⋮----
// Collect all timeline events
⋮----
// Get the conversation start time from the first event
⋮----
// 1. Add conversation start
⋮----
// 2. Add phase transitions
⋮----
// 3. Load LLM calls
⋮----
// Only include entries for this conversation
⋮----
// Skip invalid lines
⋮----
// 4. Load tool calls
⋮----
// Only include entries for this conversation
⋮----
// Skip invalid lines
⋮----
// 5. Add messages from history
⋮----
// Sort events by timestamp
⋮----
// Display timeline
⋮----
// Format timestamp
⋮----
// Choose color based on event type
⋮----
// Main timeline entry
⋮----
// Agent info
⋮----
// Duration
⋮----
// Key details
⋮----
// Show reasoning separately if present
⋮----
// Time gap indicator
⋮----
// Summary statistics
⋮----
// Performance insights
⋮----
// Helper function to find log files
async function findLogFiles(logDir: string, _conversationId: string): Promise<string[]>
⋮----
// Helper function to format duration
⋮----
// Helper function to extract reasoning from LLM response
function extractReasoning(content?: string): string | undefined
⋮----
// Extract key decision if present
⋮----
// Otherwise return first line of thinking
</file>

<file path="src/commands/debug/utils.ts">
import { formatAnyError } from "@/utils/error-formatter";
import chalk from "chalk";
import { logInfo, logError, logDebug } from "@/utils/logger";
⋮----
/**
 * Debug output utilities for consistent formatting
 */
⋮----
export function debugLog(message: string, ...args: unknown[]): void
⋮----
export function debugError(message: string, error?: unknown): void
⋮----
export function debugInfo(message: string): void
⋮----
export function debugSection(title: string, content?: string): void
⋮----
export function debugPrompt(prompt: string): void
</file>

<file path="src/commands/mcp/__tests__/add.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { Command } from "commander";
import { addCommand } from "../add";
import type { TenexConfig } from "@/services/config/types";
⋮----
// Mock modules
⋮----
// Mock logger
⋮----
// Mock process.exit
⋮----
// Mock which command validation
⋮----
// Mock console methods
⋮----
// Reset mocks
⋮----
// Replace console methods
⋮----
// Default mock config
⋮----
// Setup default mocks
⋮----
// Create commander program with mcp subcommand
⋮----
program.exitOverride(); // Prevent process.exit during tests
⋮----
// Restore console methods
⋮----
process.cwd(), // The actual implementation uses process.cwd()
⋮----
// Reset mocks
⋮----
// Should not call which for special commands
</file>

<file path="src/commands/project/init.ts">
import { logger } from "@/utils/logger";
import { Command } from "commander";
import { ProjectManager } from "../../daemon/ProjectManager";
import { getNDK, initNDK, shutdownNDK } from "../../nostr/ndkClient";
import { handleCliError } from "../../utils/cli-error";
⋮----
// Initialize NDK and get singleton
⋮----
// Shutdown NDK
</file>

<file path="src/commands/queue/release.ts">
import { getProjectContext } from '@/services';
import { ensureProjectInitialized } from '@/utils/projectInitialization';
import { logger } from '@/utils/logger';
import chalk from 'chalk';
import inquirer from 'inquirer';
⋮----
interface ReleaseOptions {
  conversation?: string;
  reason?: string;
  confirm?: boolean;
}
⋮----
export async function releaseExecutionLock(options: ReleaseOptions =
⋮----
// Initialize project context first
⋮----
// Get current lock to determine which conversation to release
⋮----
// If no conversation specified, use the current lock
⋮----
// Verify the conversation matches the current lock
⋮----
// Prompt for reason if not provided
⋮----
// Confirm the release unless --confirm flag is provided
⋮----
// Perform the force release
⋮----
// Check if there's a next conversation in queue
⋮----
// Exit cleanly
</file>

<file path="src/commands/queue/remove.ts">
import { getProjectContext } from '@/services';
import { ensureProjectInitialized } from '@/utils/projectInitialization';
import { logger } from '@/utils/logger';
import chalk from 'chalk';
import inquirer from 'inquirer';
⋮----
interface RemoveOptions {
  conversation?: string;
  confirm?: boolean;
}
⋮----
export async function removeFromQueue(options: RemoveOptions =
⋮----
// Initialize project context first
⋮----
// Get queue status to show available conversations
⋮----
// If no conversation specified, prompt to select from queue
⋮----
// Verify the conversation is actually in the queue
⋮----
// Confirm the removal unless --confirm flag is provided
⋮----
// Remove from queue
⋮----
// Show updated queue status
</file>

<file path="src/commands/run/__tests__/StatusPublisher.test.ts">
import { describe, it, expect, mock, beforeEach, afterEach } from "bun:test";
import { StatusPublisher } from "../StatusPublisher";
import { STATUS_INTERVAL_MS, STATUS_KIND } from "../constants";
⋮----
// Mock dependencies
⋮----
// Clear all mock calls
⋮----
// Clean up any intervals
⋮----
// Verify NDKEvent was created and configured
⋮----
// Use fake timers for deterministic testing
⋮----
// Initial call
⋮----
// Verify interval was set up
⋮----
// Manually trigger the interval callback
⋮----
// Verify interval was cleared
⋮----
// Restore original timer functions
⋮----
// Use fake timers for deterministic testing
⋮----
// Initial call
⋮----
// Verify interval was cleared
⋮----
// Even if we tried to call it, nothing should happen
// since the interval was cleared
⋮----
// Restore original timer functions
⋮----
// Check that agent tags were added
⋮----
// Check that model tags were added
⋮----
// Make publish throw an error
⋮----
// Should not throw - startPublishing doesn't throw, it logs errors
⋮----
// Verify it tried to publish but handled the error
⋮----
// Should not throw - just logs warning
⋮----
// Should not throw - handles undefined config gracefully
</file>

<file path="src/commands/run/StatusPublisher.ts">
import { STATUS_INTERVAL_MS, STATUS_KIND } from "@/commands/run/constants";
import { getNDK } from "@/nostr/ndkClient";
import { configService, getProjectContext, isProjectContextInitialized } from "@/services";
import { formatAnyError } from "@/utils/error-formatter";
import { logWarning } from "@/utils/logger";
import { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
/**
 * StatusPublisher handles periodic publishing of status events to Nostr.
 * 
 * This class manages the lifecycle of status event publishing, including:
 * - Starting and stopping the periodic publishing interval
 * - Creating and publishing status events with agent and model information
 * - Handling errors gracefully to ensure the main process continues
 * 
 * Status events are published at regular intervals (STATUS_INTERVAL_MS) and include:
 * - Project reference tags
 * - Agent pubkeys and slugs
 * - Model configurations
 * 
 * @example
 * ```typescript
 * const publisher = new StatusPublisher();
 * await publisher.startPublishing('/path/to/project');
 * // ... later
 * publisher.stopPublishing();
 * ```
 */
export class StatusPublisher
⋮----
async startPublishing(projectPath: string): Promise<void>
⋮----
stopPublishing(): void
⋮----
private async publishStatusEvent(projectPath: string): Promise<void>
⋮----
// Tag the project event properly
⋮----
// Sign the event with the project's signer
⋮----
private async addAgentPubkeys(event: NDKEvent, _projectPath: string): Promise<void>
⋮----
// Add "global" as fourth element for global agents
⋮----
private async addModelTags(event: NDKEvent, projectPath: string): Promise<void>
⋮----
// Add model tags for each LLM configuration
⋮----
// Also check if there are agent-specific defaults
</file>

<file path="src/conversations/__tests__/ConversationManager.multiAgent.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { ConversationManager } from "../ConversationManager";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { AgentInstance } from "@/agents/types";
⋮----
// Mock the persistence module
⋮----
// Mock the tracing module
⋮----
// Mock the logging module
⋮----
// Mock NDK
⋮----
// Mock agents
⋮----
// User starts conversation
⋮----
// PM responds first
⋮----
// User p-tags developer
⋮----
// Developer sees full history
⋮----
// Developer should see full conversation history
// First user message
⋮----
// PM's response as system message (from another agent)
⋮----
// Current user message asking developer
⋮----
// Developer responds
⋮----
// User goes back to PM
⋮----
// PM should see everything that happened since their last message
⋮----
// PM should see full conversation history
// First user message
⋮----
// PM's own previous response as assistant
⋮----
// User's message to developer
⋮----
// Developer's response as system message
⋮----
// User p-tags multiple agents at once
⋮----
// Build messages for PM
⋮----
// Build messages for Developer
⋮----
// Both should NOT have history (they're being directly addressed)
⋮----
// Both should have the user message
⋮----
// User asks PM to plan
⋮----
// PM responds and hands off to developer
⋮----
// Developer gets context from PM
⋮----
pmResponse // PM's message is the triggering event
⋮----
// Developer should see full conversation history
// User's original request
⋮----
// PM's handoff message should be the triggering event (system message from another agent)
⋮----
// The PM's handoff message should be the primary message
⋮----
// This is the exact scenario from the bug report
⋮----
// 1. User p-tags project-manager
⋮----
// PM should NOT see the message in history
⋮----
// 2. PM responds
⋮----
// 3. User replies
⋮----
// PM should see full conversation history
⋮----
// Check full history is present
// First user message
⋮----
// PM's previous response should be an assistant message
⋮----
// Current user message
⋮----
// 4. User adds human-replica
⋮----
// Human Replica should see full history
⋮----
// HR should see complete conversation history
// First user message to PM
⋮----
// PM's response as system message (from another agent)
⋮----
// User's "yes, let's do it" message
⋮----
// Current message asking HR
</file>

<file path="src/conversations/__tests__/ConversationManager.nostrEntities.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { ConversationManager } from "../ConversationManager";
import { FileSystemAdapter } from "../persistence";
import { getNDK } from "@/nostr";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import type { AgentInstance } from "@/agents/types";
import { PHASES } from "@/conversations/phases";
import { getProjectContext } from "@/services";
⋮----
// Mock dependencies
⋮----
// Setup mock NDK
⋮----
// Setup mock project context
⋮----
// Setup mock persistence
⋮----
// Setup mock event
⋮----
// Create a conversation
⋮----
// Build messages for an agent
⋮----
// Verify the nostr entity was processed
⋮----
// Setup mock events
⋮----
// Create a conversation
⋮----
// Build messages for an agent
⋮----
// Verify both entities were processed
⋮----
// Setup mock to return null
⋮----
// Create a conversation
⋮----
// Build messages for an agent
⋮----
// Verify the entity remains unchanged when fetch fails
⋮----
// Create a conversation
⋮----
// Build messages for an agent
⋮----
// Verify the message is unchanged
</file>

<file path="src/conversations/__tests__/ConversationManager.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { ConversationManager } from "../ConversationManager";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { Phase, PhaseTransition } from "../types";
⋮----
// Mock the fs module
⋮----
// Mock the persistence module
⋮----
// Create a conversation
⋮----
// Perform phase transition
⋮----
// First transition: chat -> plan
⋮----
// Second transition: plan -> execute
⋮----
// Third transition: execute -> verification
⋮----
// Verify transition history
⋮----
// Try to transition to the same phase (handoff)
⋮----
// Verify handoff transition details
⋮----
// Verify save was called with conversation including transitions
</file>

<file path="src/conversations/executionQueue/LockManager.ts">
import { ExecutionLock, PersistedLock, ExecutionQueueConfig, DEFAULT_EXECUTION_QUEUE_CONFIG } from './types';
import { writeJsonFile, readJsonFile, ensureDirectory, handlePersistenceError, fileExists } from '../../utils/file-persistence';
⋮----
export class LockManager
⋮----
constructor(
    private projectPath: string,
    config: Partial<ExecutionQueueConfig> = {}
)
⋮----
async initialize(): Promise<void>
⋮----
// Ensure persistence directory exists
⋮----
// Try to load existing lock from disk
⋮----
async getCurrentLock(): Promise<ExecutionLock | null>
⋮----
// If current lock is expired, clear it
⋮----
// Try to load from persistent storage
⋮----
async acquireLock(conversationId: string, agentPubkey: string): Promise<boolean>
⋮----
return false; // Lock held by another conversation
⋮----
async releaseLock(conversationId: string): Promise<boolean>
⋮----
return false; // Not holding the lock
⋮----
async forceRelease(conversationId: string): Promise<boolean>
⋮----
return false; // Lock not held by this conversation
⋮----
async forceReleaseAny(): Promise<string | null>
⋮----
return null; // No lock to release
⋮----
isLockExpired(lock: ExecutionLock): boolean
⋮----
getLockAge(lock: ExecutionLock): number
⋮----
getRemainingTime(lock: ExecutionLock): number
⋮----
private async clearExpiredLock(): Promise<void>
⋮----
private async saveLockToDisk(lock: ExecutionLock): Promise<void>
⋮----
// Don't throw - allow operation to continue without persistence
⋮----
private async loadLockFromDisk(): Promise<ExecutionLock | null>
⋮----
// Verify this lock belongs to the current project
⋮----
// Lock file from different project, ignore it
⋮----
// Check if lock has expired
⋮----
await this.deleteLockFromDisk(); // Remove expired lock
⋮----
return null; // No lock file exists
⋮----
private async deleteLockFromDisk(): Promise<void>
⋮----
// Don't throw - allow operation to continue
⋮----
// Utility methods for monitoring and debugging
async getLockInfo(): Promise<
</file>

<file path="src/conversations/services/__tests__/ConversationCoordinator.e2e.test.ts">
import { describe, expect, it, beforeEach, afterEach, jest } from "@jest/globals";
import { ConversationCoordinator } from "../ConversationCoordinator";
import { ConversationStore } from "../ConversationStore";
import { ConversationPersistenceService, InMemoryPersistenceAdapter } from "../ConversationPersistenceService";
import { PhaseManager } from "../PhaseManager";
import { ConversationEventProcessor } from "../ConversationEventProcessor";
import { OrchestratorTurnTracker } from "../OrchestratorTurnTracker";
import { MockAgentResolver } from "../AgentResolver";
import { PHASES } from "../../phases";
import type { AgentInstance } from "@/agents/types";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import type { ExecutionQueueManager } from "../../executionQueue";
⋮----
// Mock getProjectContext to avoid initialization issues
⋮----
// Mock agents
⋮----
// Create services
⋮----
// Mock queue manager
⋮----
// Create coordinator
⋮----
// Create initial event
⋮----
// Create conversation
⋮----
// Verify it's stored
⋮----
// Transition to PLAN phase
⋮----
// Create conversation
⋮----
// Add agent response
⋮----
// Build messages for orchestrator
⋮----
// Should include user message and agent response
⋮----
// Create conversation
⋮----
// Start orchestrator turn
⋮----
// Add completion
⋮----
// Build routing context
⋮----
// Create conversation
⋮----
// Try to transition to EXECUTE
⋮----
// Transition back to CHAT
⋮----
// Mock queue being full
⋮----
// Create conversation
⋮----
// Try to transition to EXECUTE
⋮----
// Create conversation
⋮----
// Add metadata
⋮----
// Create new coordinator with same persistence
⋮----
// Should have loaded the conversation
⋮----
// Create multiple conversations
⋮----
// Search for "Feature"
⋮----
// Create conversation
⋮----
// Add some metadata that should be cleaned
⋮----
// Complete the conversation
⋮----
// Should be removed from store
⋮----
// Create conversation
⋮----
// Archive it
⋮----
// Should be removed from active store
⋮----
// But should be marked as archived in persistence
⋮----
// Create conversation
⋮----
// Transition through multiple phases
⋮----
// Verify transition history
⋮----
// These should throw
⋮----
// Force an invalid phase
</file>

<file path="src/conversations/services/__tests__/ConversationEventProcessor.test.ts">
import { describe, it, expect, beforeEach, mock } from "@jest/globals";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import { ConversationEventProcessor } from "../ConversationEventProcessor";
import type { Conversation } from "../../types";
import { PHASES } from "../../phases";
⋮----
// Mock the getAgentSlugFromEvent function
⋮----
// Map specific pubkeys to agent slugs for testing
⋮----
// History should still have only one event
⋮----
// Original event should be preserved
⋮----
// Process events including duplicates
⋮----
processor.processIncomingEvent(conversation, event1); // duplicate
processor.processIncomingEvent(conversation, event2); // duplicate
⋮----
processor.processIncomingEvent(conversation, event1); // duplicate again
⋮----
// Should only have 3 unique events
</file>

<file path="src/conversations/phases.ts">
export type Phase =
    | "CHAT"
    | "BRAINSTORM"
    | "PLAN"
    | "EXECUTE"
    | "VERIFICATION"
    | "CHORES"
    | "REFLECTION";
⋮----
export interface PhaseDefinition {
    description: string;
    goal: string;
    whenToUse: string[];
    doNot?: string[];
    constraints: string[];
}
⋮----
// DEPRECATED: Phase transitions are now flexible and controlled by PM
// All phases can transition to any other phase based on PM's judgment
// export const PHASE_TRANSITIONS = { ... }
⋮----
export function isValidPhase(phase: string): phase is Phase
⋮----
// All phases can transition to all other phases - PM decides what makes sense
export function getValidTransitions(currentPhase: Phase): readonly Phase[]
⋮----
// Return all phases as valid transitions (PM decides appropriateness)
⋮----
// Always returns true - PM controls phase transitions through switch_phase tool
export function canTransitionTo(currentPhase: Phase, targetPhase: Phase): boolean
⋮----
// Any phase can transition to any other phase
// The PM uses context and task complexity to decide appropriate transitions
</file>

<file path="src/event-handler/__tests__/reply.test.ts">
import { NDKEvent, NDKUser } from "@nostr-dev-kit/ndk";
import { mock, mockReset } from 'jest-mock-extended';
import { AgentExecutor } from "../../agents/execution/AgentExecutor";
import { Agent } from "../../agents/types";
import { Conversation } from "../../conversations";
import { ConversationManager } from "../../conversations/ConversationManager";
import { getProjectContext, setProjectContext } from "../../services";
import { ProjectContext } from "../../services/ProjectContext";
import { logger } from "../../utils/logger";
import { handleChatMessage } from "../reply";
⋮----
// Mock logger to suppress output during tests
⋮----
// Mock ProjectContext
⋮----
mockReset(logger.error); // Reset mock before each test
⋮----
// Setup mock ProjectContext
⋮----
// Mock getProjectContext to return our mock
⋮----
kind: 1112, // Using a different kind just to be clear it's not a standard chat
⋮----
// Setup mocks
// 1. No conversation found initially
⋮----
// 2. A new conversation is created
⋮----
// Act
⋮----
// Assert
// 1. It should NOT log a "No conversation found" error
⋮----
// 2. It should have tried to find a conversation
⋮----
// 3. It should create a new conversation with a synthetic root event
⋮----
// 4. It should add the original reply to the new conversation
⋮----
// 5. It should execute the agent
⋮----
// The logic to check if the message is directed to the system runs before handleReplyLogic
// Since it's not directed to the system, handleReplyLogic is not even called.
⋮----
// Create an event from the project manager agent
⋮----
// Update project context with PM agent
⋮----
// Also mock getAgent to return PM
⋮----
// Create an event from the PM agent (kind 1111)
⋮----
// Verify the event was skipped
</file>

<file path="src/llm/selection/ModelSelector.ts">
import type { LLMProvider } from "@/llm/types";
import search from "@inquirer/search";
import { getModelsForProvider } from "../models";
import type { ModelsList } from "multi-llm-ts";
⋮----
export interface ModelSelectionResult {
    model: string;
    supportsCaching: boolean;
}
⋮----
/**
 * Model selection utilities for different LLM providers
 */
export class ModelSelector
⋮----
async selectModelWithSearch(provider: string, models: string[]): Promise<string>
⋮----
async selectOpenRouterModelWithPricing(models: string[]): Promise<ModelSelectionResult>
⋮----
supportsCaching: false, // We don't have this info from multi-llm-ts
⋮----
async fetchAndSelectModel(
        provider: LLMProvider,
        existingApiKey?: string
): Promise<ModelSelectionResult | null>
⋮----
getAvailableModelCount(modelsList: ModelsList | null): number
⋮----
shouldSupportCaching(provider: LLMProvider, model: string, supportsCaching: boolean): boolean
⋮----
generateDefaultConfigName(provider: string, model: string): string
</file>

<file path="src/nostr/__tests__/NostrPublisher.test.ts">
import { describe, it, expect, beforeEach, jest } from "bun:test";
import { NostrPublisher } from "../NostrPublisher";
import type { NostrPublisherContext, ResponseOptions } from "../NostrPublisher";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import type { AgentInstance } from "@/agents/types";
import type { ConversationManager } from "@/conversations/ConversationManager";
⋮----
// Mock dependencies
⋮----
// Force an error by breaking the NDK mock
⋮----
// Expected to throw
</file>

<file path="src/nostr/__tests__/TaskPublisher.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock, spyOn } from "bun:test";
import type NDK from "@nostr-dev-kit/ndk";
import { NDKTask } from "@nostr-dev-kit/ndk";
import { TaskPublisher } from "../TaskPublisher";
import type { AgentInstance } from "@/agents/types";
⋮----
import { logger } from "@/utils/logger";
⋮----
// Create a factory for mock tasks
const createMockTask = (): any =>
⋮----
// Keep track of created tasks
⋮----
// Mock NDKTask at module level
⋮----
// Reset the current mock task before each test
⋮----
// Setup mocks
⋮----
// Mock getProjectContext
⋮----
// Spy on logger
⋮----
// Create TaskPublisher instance
⋮----
// Test by trying to publish progress (which requires currentTask)
⋮----
// Create a new TaskPublisher with a mock that will fail on sign
⋮----
// Create a new TaskPublisher with a mock that will fail on publish
⋮----
// First create a task
⋮----
// Note: completeTask method is not fully implemented in the source
// This test validates the error handling for now
⋮----
// First create a task
⋮----
// Create a task first
⋮----
// Mock reply to throw error on publish
⋮----
// Should not throw, but log the error
⋮----
// The implementation modifies the reply object that was returned
⋮----
// Modify the reply method to return an object with p tags
⋮----
// Get the reply object that was created and modified
⋮----
// p tags should be filtered out
⋮----
// Create first task
⋮----
// Store the reply mock count for task1
⋮----
// Create second task (should replace current task)
⋮----
// Progress should be published to the second task
⋮----
// task1.reply should not have been called again after task2 was created
⋮----
// Check if the logger was called with the expected pattern
</file>

<file path="src/nostr/utils.ts">
import { getProjectContext, isProjectContextInitialized } from "@/services";
import type { NDKEvent, NDKProject } from "@nostr-dev-kit/ndk";
import { EXECUTION_TAGS, LLM_TAGS } from "./tags";
import type { LLMMetadata } from "./types";
import type { Conversation } from "@/conversations/types";
import { getTotalExecutionTimeSeconds } from "@/conversations/executionTime";
⋮----
/**
 * Check if an event is from an agent (either project agent or individual agent)
 * @param event - The NDK event to check
 * @returns true if the event is from an agent, false if from a user
 */
export function isEventFromAgent(event: NDKEvent): boolean
⋮----
// Check if it's from the project itself
⋮----
// Check if it's from any of the registered agents
⋮----
/**
 * Check if an event is from a user (not from an agent)
 * @param event - The NDK event to check
 * @returns true if the event is from a user, false if from an agent
 */
export function isEventFromUser(event: NDKEvent): boolean
⋮----
/**
 * Get the agent slug if the event is from an agent
 * @param event - The NDK event to check
 * @returns The agent slug if found, undefined otherwise
 */
export function getAgentSlugFromEvent(event: NDKEvent): string | undefined
⋮----
// Project context not initialized
⋮----
/**
 * Add common project tags to an event
 * @param event - The NDK event to add tags to
 * @param project - The NDK project to tag
 */
export function addProjectTags(event: NDKEvent, project: NDKProject): void
⋮----
/**
 * Add conversation context tags to an event
 * @param event - The NDK event to add tags to
 * @param conversation - The conversation context
 * @param triggeringEvent - The event that triggered this response
 */
export function addConversationTags(
    event: NDKEvent,
    conversation: Conversation,
    triggeringEvent?: NDKEvent
): void
⋮----
// Add current phase tag
⋮----
// Add execution time tag
⋮----
// Add voice mode tag if the triggering event has it
⋮----
/**
 * Add LLM metadata tags to an event
 * @param event - The NDK event to add tags to
 * @param metadata - The LLM metadata to add
 */
export function addLLMMetadataTags(event: NDKEvent, metadata: LLMMetadata): void
⋮----
// event.tag(["llm-system-prompt", metadata.systemPrompt]);
⋮----
/**
 * Add agent identification tags to an event
 * @param event - The NDK event to add tags to
 * @param agentPubkey - The agent's public key
 * @param agentSlug - Optional agent slug
 */
export function addAgentTags(event: NDKEvent, agentPubkey: string, agentSlug?: string): void
</file>

<file path="src/prompts/fragments/__tests__/agent-execution.test.ts">
import { PromptBuilder } from "@/prompts/core/PromptBuilder";
import { fragmentRegistry } from "@/prompts/core/FragmentRegistry";
import type { AgentInstance } from "@/agents/types";
import type { Phase } from "@/conversations/phases";
import type { Conversation } from "@/conversations/types";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Import fragments to register them
⋮----
// Conversation history is handled as message array
⋮----
// Full prompt fragment doesn't exist, so we'll just verify components separately
⋮----
// Verify all components are present
</file>

<file path="src/prompts/fragments/__tests__/phase-definitions.test.ts">
import { describe, expect, it } from "bun:test";
import { phaseDefinitionsFragment } from "../10-phase-definitions";
⋮----
// Should contain all phase definitions
⋮----
// Should contain the enhanced descriptions for key phases
⋮----
// Should contain goals
</file>

<file path="src/prompts/fragments/10-phase-definitions.ts">
import { PHASE_DEFINITIONS, PHASES } from "@/conversations/phases";
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
/**
 * Phase definitions fragment - provides all agents with clear understanding of what each phase means
 * This fragment is accessible to all agents so they understand the phase structure and expectations
 */
⋮----
priority: 15, // Higher priority to ensure it appears early in the prompt
⋮----
// Register the fragment
</file>

<file path="src/prompts/fragments/20-phase-context.ts">
import type { Phase } from "@/conversations/phases";
import type { Conversation } from "@/conversations/types";
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
/**
 * Phase context fragment for specialists.
 * Provides context about the current phase and any transition information.
 */
interface PhaseContextArgs {
    phase: Phase;
    phaseMetadata?: Record<string, any>;
    conversation?: Conversation;
}
⋮----
// Get phase context from phase transitions if available
⋮----
// Add any phase metadata
⋮----
/**
 * Helper to extract phase context from phase transitions
 */
function getPhaseContext(targetPhase: Phase, conversation?: Conversation): string | null
⋮----
// Find the most recent transition to the target phase
⋮----
// Register the fragment
</file>

<file path="src/prompts/fragments/25-specialist-tools.ts">
import type { AgentInstance } from "@/agents/types";
import { fragmentRegistry } from "@/prompts/core/FragmentRegistry";
import type { PromptFragment } from "@/prompts/core/types";
import type { Tool } from "@/tools/types";
⋮----
/**
 * Tools fragment for specialist agents ONLY.
 * Combines agent tools and MCP tools into a single list.
 * No conditionals, no isOrchestrator checks.
 */
interface SpecialistToolsArgs {
    agent: AgentInstance;
    mcpTools?: Tool[];
}
⋮----
// Combine all tools
⋮----
// Add agent-specific tools
⋮----
// Add custom prompt fragment if available
⋮----
// Add MCP tools if available
⋮----
// Group tools by server
⋮----
// Add parameter information if available
⋮----
// Add concise tool usage table
⋮----
// Register the fragment
</file>

<file path="src/prompts/fragments/30-project-inventory.ts">
import type { Phase } from "@/conversations/phases";
import { PHASES } from "@/conversations/phases";
import { logger } from "@/utils/logger";
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
⋮----
// Project inventory context fragment
interface InventoryContextArgs {
    phase: Phase;
}
⋮----
// Helper function to count total files recursively
function countTotalFiles(dir: string): number
⋮----
// Helper function to get project files (excluding dot files/dirs)
function getProjectFiles():
⋮----
// Helper function to count files in a directory (non-recursive, only direct children)
function countDirectFiles(dir: string): number
⋮----
// Helper function to build tree structure recursively
function buildTree(dir: string, prefix = "", _isLast = true, showFiles = true): string[]
⋮----
// Filter and sort entries
⋮----
// Skip dot files/dirs and node_modules
⋮----
// Sort directories first, then files
⋮----
// Always show directories and recurse
⋮----
// Count only direct files in this directory
⋮----
// Always recurse into subdirectories
⋮----
// Skip dot files/dirs and node_modules
⋮----
// Sort directories first, then files
⋮----
// Count total files to decide whether to show individual files
⋮----
// Build the tree structure
⋮----
// If not showing files and there are files in the root directory, add a count
⋮----
// Helper function to load inventory and context synchronously
function loadProjectContextSync():
⋮----
// Get list of context files
⋮----
// Context directory may not exist
⋮----
// If content is provided directly, use it; otherwise load from file
⋮----
// Get project files to determine if this is a fresh project
⋮----
// Count total files to determine if we should strongly recommend inventory generation
⋮----
// Add context files listing if available
⋮----
// Register fragments
</file>

<file path="src/prompts/utils/phaseInstructionsBuilder.ts">
import type { Phase } from "@/conversations/phases";
import type { Conversation } from "@/conversations/types";
import { PromptBuilder } from "@/prompts/core/PromptBuilder";
⋮----
/**
 * Builds phase-specific instructions to be injected as a system message
 * when an agent transitions to a new phase.
 * 
 * This includes:
 * - Current phase context and any transition information
 * - Phase-specific constraints
 * - Phase-specific completion guidance
 */
export function buildPhaseInstructions(
    phase: Phase,
    conversation?: Conversation,
    isOrchestrator: boolean = false
): string
⋮----
// Orchestrators should not receive dynamic phase instructions
// as they output strict JSON and handle phases differently
⋮----
/**
 * Formats a phase transition message for an agent that is
 * re-entering the conversation in a different phase.
 */
export function formatPhaseTransitionMessage(
    lastSeenPhase: Phase,
    currentPhase: Phase,
    phaseInstructions: string
): string
</file>

<file path="src/prompts/index.ts">
// Export core functionality
⋮----
// Import all fragments to ensure they're registered when the module is imported
// Priority 01 - Identity
⋮----
// Priority 10 - Early context
import "./fragments/10-phase-definitions";     // Shared
import "./fragments/10-referenced-article";    // Conditional
⋮----
// Priority 15 - Available agents
⋮----
// Priority 20 - Phase and mode context
import "./fragments/20-phase-constraints";     // Shared
import "./fragments/20-phase-context";         // Shared
import "./fragments/20-voice-mode";            // Conditional
⋮----
// Priority 24 - Lessons
import "./fragments/24-retrieved-lessons";     // Shared
⋮----
// Priority 25 - Tools
import "./fragments/25-specialist-tools";      // All agents use tools
⋮----
// Priority 30 - Project context
import "./fragments/30-project-inventory";     // Shared
import "./fragments/30-project-md";            // Conditional (project-manager)
⋮----
// Priority 35 - Completion guidance
import "./fragments/35-specialist-completion-guidance"; // Specialist only
⋮----
// Priority 85 - Reasoning (specialist only - orchestrator outputs JSON only)
⋮----
// Priority 90+ - Special purpose
import "./fragments/90-inventory-generation";  // Internal LLM prompts
</file>

<file path="src/services/NDKAgentDiscovery.ts">
import type NDK from "@nostr-dev-kit/ndk";
import { NDKAgentDefinition } from "@/events/NDKAgentDefinition";
import { logger } from "@/utils/logger";
import type { NDKFilter } from "@nostr-dev-kit/ndk";
⋮----
/**
 * Discovered NDKAgentDefinition with metadata
 */
export interface DiscoveredAgent {
    /** NDKAgentDefinition event */
    event: NDKAgentDefinition;
    /** Event ID */
    id: string;
    /** Agent name/title */
    name: string;
    /** Agent role */
    role: string;
    /** Agent description */
    description?: string;
    /** Use criteria for routing */
    useCriteria?: string;
    /** Instructions for the agent */
    instructions?: string;
    /** Author pubkey */
    authorPubkey: string;
    /** Creation timestamp */
    createdAt?: number;
    /** Relevance score if filtered */
    relevanceScore?: number;
}
⋮----
/** NDKAgentDefinition event */
⋮----
/** Event ID */
⋮----
/** Agent name/title */
⋮----
/** Agent role */
⋮----
/** Agent description */
⋮----
/** Use criteria for routing */
⋮----
/** Instructions for the agent */
⋮----
/** Author pubkey */
⋮----
/** Creation timestamp */
⋮----
/** Relevance score if filtered */
⋮----
/**
 * Options for discovering NDKAgentDefinition events
 */
export interface AgentDiscoveryOptions {
    /** Text to search for in name/description/role */
    searchText?: string;
    /** Minimum creation timestamp */
    since?: number;
    /** Maximum creation timestamp */
    until?: number;
}
⋮----
/** Text to search for in name/description/role */
⋮----
/** Minimum creation timestamp */
⋮----
/** Maximum creation timestamp */
⋮----
/**
 * Service for discovering NDKAgentDefinition events from the Nostr network
 */
export class NDKAgentDiscovery
⋮----
constructor(private ndk: NDK)
⋮----
/**
     * Discover NDKAgentDefinition events from the network
     */
async discoverAgents(options: AgentDiscoveryOptions =
⋮----
// Build filter for kind:4199 (NDKAgentDefinition)
⋮----
// Fetch events from network
⋮----
// Convert to NDKAgentDefinition instances and extract metadata
⋮----
// Apply local filtering if specified
⋮----
// Sort by creation time (newest first)
⋮----
/**
     * Filter agents by text search
     */
private filterByText(agents: DiscoveredAgent[], searchText: string): DiscoveredAgent[]
</file>

<file path="src/test-utils/mock-llm/scenarios/concurrency-workflow.ts">
import type { MockLLMScenario, MockLLMResponse } from "../types";
import { PHASES } from "@/conversations/phases";
⋮----
// Routing decisions for orchestrator
⋮----
// Orchestrator Phase 1: Initial task understanding for User A
⋮----
// Orchestrator Phase 1: Initial task understanding for User B
⋮----
// Orchestrator Phase 2: Planning for User A
⋮----
// Orchestrator Phase 2: Planning for User B
⋮----
// Orchestrator Phase 3: Implementation handoff for User A
⋮----
// Orchestrator Phase 3: Implementation handoff for User B
⋮----
// Executor implementation for User A
⋮----
// Executor implementation for User B
⋮----
// Orchestrator Phase 4: Verification for User A
⋮----
// Orchestrator Phase 4: Verification for User B
⋮----
// Orchestrator Phase 5: Completion for User A
⋮----
// Orchestrator Phase 5: Completion for User B
⋮----
// Orchestrator Phase 1: Initial task understanding for User C
⋮----
// Orchestrator Phase 2: Planning for User C
⋮----
// Orchestrator Phase 3: Implementation handoff for User C
⋮----
// Executor implementation for User C
⋮----
// Orchestrator Phase 4: Verification for User C
⋮----
// Orchestrator Phase 5: Completion for User C
</file>

<file path="src/test-utils/mock-llm/example-e2e.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { createMockLLMService } from "./index";
import type { LLMService } from "@/llm/types";
⋮----
// Example of how to use the mock LLM service in E2E tests
⋮----
// Create mock with orchestrator workflow scenario
⋮----
debug: true // Enable debug logging
⋮----
// Mock the LLM router to return our mock service
⋮----
// This would be your actual E2E test code
// For example, starting the daemon and sending events
⋮----
// Simulate user message
⋮----
// The mock will automatically respond based on the scenario
⋮----
// Verify orchestrator response
⋮----
// Get request history for debugging
⋮----
// Add error scenario
⋮----
// Create custom scenario
⋮----
// Simulate multiple continues
</file>

<file path="src/test-utils/mock-setup.ts">
import { mock } from "bun:test";
⋮----
/**
 * Common mock setup for services module used across many tests
 */
export function setupServicesMock(projectPath = "/test/project"): void
⋮----
/**
 * Common mock setup for execution time tracking
 */
export function setupExecutionTimeMock(): void
⋮----
/**
 * Common mock setup for execution logger
 */
export function setupExecutionLoggerMock(): void
⋮----
/**
 * Common mock setup for tracing
 */
export function setupTracingMock(): void
⋮----
/**
 * Common mock setup for agent utils
 */
export function setupAgentUtilsMock(tools: any[] = []): void
⋮----
/**
 * Common mock setup for tool registry
 */
export function setupToolRegistryMock(): void
⋮----
/**
 * Setup all common mocks at once
 */
export function setupCommonTestMocks(projectPath = "/test/project"): void
</file>

<file path="src/tools/__tests__/registry.test.ts">
import { describe, it, expect } from "bun:test";
import { getTool, getTools, getAllTools, type ToolName } from "../registry";
import { readPathTool } from "../implementations/readPath";
import { completeTool } from "../implementations/complete";
import { shellTool } from "../implementations/shell";
⋮----
// @ts-expect-error Testing invalid tool name
⋮----
// @ts-expect-error Testing invalid tool name
⋮----
// @ts-expect-error Testing with invalid tool name
⋮----
// @ts-expect-error Testing with invalid tool names
</file>

<file path="src/tools/implementations/__tests__/analyze.test.ts">
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { analyze } from '../analyze';
⋮----
// Arrange
⋮----
// Act
⋮----
// Assert
⋮----
// Act
⋮----
// Assert
⋮----
// Arrange
⋮----
// Act
⋮----
// Assert
⋮----
// Arrange
⋮----
// Act
⋮----
// Assert
</file>

<file path="src/tools/implementations/__tests__/learn.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { lessonLearnTool } from "../learn";
import type { ExecutionContext } from "../../types";
import type { AgentInstance } from "@/agents/types";
import type { Conversation } from "@/conversations/types";
import { NDKAgentLesson } from "@/events/NDKAgentLesson";
import type NDK from "@nostr-dev-kit/ndk";
import type { NDKSigner } from "@nostr-dev-kit/ndk";
⋮----
// Mock dependencies
⋮----
import { logger } from "@/utils/logger";
import { getNDK } from "@/nostr";
import { getProjectContext } from "@/services/ProjectContext";
import { getTotalExecutionTimeSeconds } from "@/conversations/executionTime";
⋮----
// Reset all mocks
⋮----
// Setup mock agent
⋮----
// Setup mock conversation
⋮----
// Setup mock context
⋮----
// Setup NDK mock
⋮----
// Setup project context mock
⋮----
// Setup NDKAgentLesson mock
</file>

<file path="src/tools/implementations/analyze.ts">
import { loadLLMRouter } from "@/llm";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { generateRepomixOutput } from "@/utils/repomix";
import { Message } from "multi-llm-ts";
import { z } from "zod";
import { createToolDefinition } from "../types";
⋮----
interface AnalyzeOutput {
    analysis: string;
    repoSize: number;
}
⋮----
// Publish custom typing indicator
⋮----
// Prepare the prompt for the LLM
⋮----
// Call the LLM with the analyze-specific configuration
⋮----
// Stop typing indicator
⋮----
// Stop typing indicator on error
</file>

<file path="src/tools/implementations/generateInventory.ts">
import { exec } from "node:child_process";
import { promisify } from "node:util";
import { generateInventory, inventoryExists } from "@/utils/inventory";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { z } from "zod";
import type { Tool } from "../types";
import { createZodSchema } from "../types";
⋮----
type GenerateInventoryInput = z.infer<typeof generateInventorySchema>;
⋮----
interface GenerateInventoryOutput {
    message: string;
    inventoryExists: boolean;
    regenerated: boolean;
}
⋮----
// Check if inventory already exists
⋮----
// Check for recently modified files using git status
⋮----
files: focusFiles.slice(0, 10), // Log first 10 files
⋮----
// Continue without focus files
⋮----
// Prepare options if agent context is available
⋮----
// Generate the inventory
</file>

<file path="src/tools/toolLogger.ts">
import { join } from "node:path";
import type { ExecutionContext, ToolExecutionResult, ToolError } from "./types";
⋮----
export interface ToolCallLogEntry {
    timestamp: string;
    timestampMs: number;
    requestId: string;

    // Context
    agentName: string;
    phase: string;
    conversationId: string;

    // Tool information
    toolName: string;
    args: Record<string, unknown>;
    argsLength: number;

    // Result
    status: "success" | "error";
    output?: string;
    outputLength?: number;
    error?: string;
    metadata?: Record<string, unknown>;

    // Performance
    performance: {
        startTime: number;
        endTime: number;
        durationMs: number;
    };

    // Trace information
    trace: {
        callStack?: string[];
        parentRequestId?: string;
        batchId?: string;
        batchIndex?: number;
        batchSize?: number;
    };
}
⋮----
// Context
⋮----
// Tool information
⋮----
// Result
⋮----
// Performance
⋮----
// Trace information
⋮----
export class ToolCallLogger
⋮----
constructor(projectPath: string)
⋮----
private async ensureLogDirectory(): Promise<void>
⋮----
// Ignore if directory already exists
⋮----
private getLogFileName(): string
⋮----
const date = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
⋮----
private getLogFilePath(): string
⋮----
private generateRequestId(toolName: string, agentName: string): string
⋮----
async logToolCall(
        toolName: string,
        args: Record<string, unknown>,
        context: ExecutionContext,
        result: ToolExecutionResult,
        performance: { startTime: number; endTime: number },
        trace?: {
            callStack?: string[];
            parentRequestId?: string;
            batchId?: string;
            batchIndex?: number;
            batchSize?: number;
        }
): Promise<void>
⋮----
// Context
⋮----
// Tool information
⋮----
// Result
⋮----
// Performance
⋮----
// Trace information
⋮----
// Write to JSONL file
⋮----
// Don't let logging errors break the main flow
⋮----
private extractOutput(result: ToolExecutionResult): string | undefined
⋮----
// Check if it's a control flow result
⋮----
// Check if it's a termination result
⋮----
// Regular tool output
⋮----
private extractError(result: ToolExecutionResult): string | undefined
⋮----
private extractMetadata(result: ToolExecutionResult): Record<string, unknown> | undefined
⋮----
// Return metadata for special result types
⋮----
private formatError(error: ToolError): string
⋮----
// Singleton instance
⋮----
export function initializeToolLogger(projectPath: string): ToolCallLogger
⋮----
export function getToolLogger(): ToolCallLogger | null
</file>

<file path="src/tracing/__tests__/index.test.ts">
import { describe, it, expect } from "bun:test";
import {
    createTracingContext,
    createAgentExecutionContext,
    createToolExecutionContext,
    createPhaseExecutionContext,
    createTracingLogger,
    formatTracingContext
} from "../index";
</file>

<file path="src/utils/__tests__/relays.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { getRelayUrls } from "../relays";
⋮----
// Reset env before each test
⋮----
// Restore original env after each test
⋮----
// Empty string should return default relay
⋮----
// Should filter out empty strings from trailing comma
⋮----
// Should return default when only commas
</file>

<file path="src/cli.ts">
// CLI entry point for TENEX - Node.js compatible
import { main } from "./tenex.js";
import { handleCliError } from "./utils/cli-error.js";
</file>

<file path="src/constants.ts">
/**
 * Global constants used throughout the TENEX codebase
 */
⋮----
/**
 * Directory names
 */
⋮----
/**
 * File names
 */
⋮----
/**
 * Default values
 */
export const DEFAULT_TIMEOUT_MS = 120000; // 2 minutes
⋮----
/**
 * Environment variables
 */
</file>

<file path="tests/e2e/agent-error-recovery.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import {
    setupE2ETest,
    cleanupE2ETest,
    createConversation,
    executeConversationFlow,
    assertAgentSequence,
    assertPhaseTransitions,
    assertToolCalls,
    type E2ETestContext
} from "../test-harness";
import type { MockLLMResponse } from "@/test-utils/mock-llm/types";
import { conversationalLogger } from "@/test-utils/conversational-logger";
⋮----
// Define error recovery workflow
⋮----
// 1. Initial orchestrator routing
⋮----
// 2. Planner with tool error
⋮----
// 3. Planner recovers from error
⋮----
// 4. Orchestrator routes to executor
⋮----
// 5. Executor with shell error
⋮----
// 6. Executor recovers from shell error
⋮----
// 7. Orchestrator ends conversation
⋮----
// 8. Orchestrator completes
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Execute the complete workflow
⋮----
// Verify error recovery workflow
⋮----
"generateInventory",  // Failed tool
"complete",          // Planner recovery
"shell",            // Failed command
"shell",            // Successful command
"complete",         // Executor completion
"complete"          // Orchestrator completion
⋮----
// Verify error recovery happened
⋮----
// Define multiple failure scenarios
⋮----
// Initial routing
⋮----
// Planner fails twice
⋮----
// Orchestrator routes to project-manager
⋮----
// Project manager verifies
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Execute the complete workflow
⋮----
// Verify recovery from multiple failures
⋮----
// Verify multiple shell failures before success
⋮----
expect(shellCalls.length).toBe(2); // Two failed shell commands
⋮----
// Define timeout scenarios
⋮----
// Initial routing
⋮----
// Executor with simulated long-running operation
⋮----
// Orchestrator completes
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Execute the complete workflow with a reasonable timeout
⋮----
{ maxIterations: 5 }  // Lower iteration limit to prevent actual timeout
⋮----
// Verify workflow completed
</file>

<file path="tests/e2e/concurrency-multiple-conversations.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import {
    setupE2ETest,
    cleanupE2ETest,
    createConversation,
    executeConversationFlow,
    assertAgentSequence,
    assertPhaseTransitions,
    type E2ETestContext
} from "../test-harness";
import type { MockLLMResponse } from "@/test-utils/mock-llm/types";
import { conversationalLogger } from "@/test-utils/conversational-logger";
⋮----
// Define scenarios for conversation A (Authentication)
⋮----
// Initial routing for auth
⋮----
// Planner for auth
⋮----
// Route to executor
⋮----
// Executor for auth
⋮----
// Route to verification
⋮----
// Verification for auth
⋮----
// Define scenarios for conversation B (Payment)
⋮----
// Initial routing for payment
⋮----
// Planner for payment
⋮----
// Route to executor
⋮----
// Executor for payment
⋮----
// Route to verification
⋮----
// Verification for payment
⋮----
// Add all scenarios to mock
⋮----
// Create two conversations
⋮----
// Execute both conversations concurrently
⋮----
// Verify conversation A workflow
⋮----
// Verify conversation B workflow
⋮----
// Verify conversations didn't interfere with each other
⋮----
// Verify content isolation
⋮----
// Ensure no cross-contamination
⋮----
// Define a simple workflow scenario that can be reused
⋮----
// Create multiple conversations rapidly
⋮----
// Execute all conversations concurrently
⋮----
// Verify all conversations completed
⋮----
// Define complex interleaved scenarios
⋮----
// Initial routing for all conversations
⋮----
// Planner responses
⋮----
// Route to executor
⋮----
// Executor responses
⋮----
// Final routing
⋮----
// Orchestrator complete
⋮----
// Add scenarios to mock
⋮----
// Create three conversations
⋮----
// Execute conversations with intentional interleaving
⋮----
// Verify all conversations completed successfully
⋮----
// Verify each has its own execution context
</file>

<file path="tests/e2e/nostr-network-resilience.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import {
    setupE2ETest,
    cleanupE2ETest,
    createConversation,
    executeConversationFlow,
    assertAgentSequence,
    assertPhaseTransitions,
    type E2ETestContext
} from "../test-harness";
import type { MockLLMResponse } from "@/test-utils/mock-llm/types";
import { conversationalLogger } from "@/test-utils/conversational-logger";
⋮----
// Track network calls for verification
⋮----
// Mock state for controlling network behavior
⋮----
const MAX_FAILURES = 2; // For intermittent failures
⋮----
// Mock NDKEvent to simulate network conditions
⋮----
// Simulate timeout delay
⋮----
// Successful publish
⋮----
// Simulate network delay for realistic behavior
⋮----
// Set a fake ID to simulate successful publish
⋮----
// Set basic event properties
⋮----
// Mock NDK module
⋮----
constructor(ndk?: any, event?: any)
⋮----
tag(tag: string[]): void
⋮----
constructor(options?: any)
⋮----
async connect(): Promise<void>
⋮----
// Simulate connection delay
⋮----
// Helper functions to control failure modes
const setFailureMode = (mode: typeof failureMode) =>
⋮----
const resetFailureMode = () =>
⋮----
const clearNetworkCalls = () =>
⋮----
// Reset test state
⋮----
// Define workflow scenarios
⋮----
// Initial routing
⋮----
// Executor action
⋮----
// Orchestrator completion
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Set network to fail on publish
⋮----
// Execute workflow - should handle failures gracefully
⋮----
// Verify workflow completed despite network issues
⋮----
// Check that publish attempts were made
⋮----
// Define workflow scenarios
⋮----
// Initial routing
⋮----
// Planner
⋮----
// Route to executor
⋮----
// Executor
⋮----
// Complete
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Set intermittent failures (first 2 attempts fail, then succeed)
⋮----
// Execute workflow
⋮----
// Verify workflow completed with retries
⋮----
// Check that some publishes failed and some succeeded
⋮----
// Define simple workflow
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Set timeout failure mode
⋮----
// Execute workflow with timeout handling
⋮----
// Verify workflow attempted despite timeouts
⋮----
// Check that timeout errors occurred
⋮----
// Verify the test didn't hang indefinitely
expect(duration).toBeLessThan(30000); // Should complete within 30 seconds
⋮----
// Define stateful workflow
⋮----
// Initial routing
⋮----
// Planner creates state
⋮----
// Route after network disruption
⋮----
// Executor uses state
⋮----
// Final completion
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Start with normal network
⋮----
// Execute workflow with network disruption midway
// We'll simulate this by changing failure mode during execution
⋮----
// Verify state was maintained
⋮----
// Check that state references are consistent
</file>

<file path="tests/e2e/performance-timeout.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import {
    setupE2ETest,
    cleanupE2ETest,
    createConversation,
    executeConversationFlow,
    assertAgentSequence,
    type E2ETestContext
} from "../test-harness";
import type { MockLLMResponse } from "@/test-utils/mock-llm/types";
import { conversationalLogger } from "@/test-utils/conversational-logger";
⋮----
/**
 * E2E Tests for Performance and Timeout Handling
 * 
 * Tests system behavior under performance stress:
 * - Slow LLM responses
 * - Timeout handling
 * - Recovery after timeouts
 * - Large response handling
 */
⋮----
// Define scenarios with simulated delays
⋮----
// Initial slow routing
⋮----
streamDelay: 5000 // 5 second delay
⋮----
// Slow planner response
⋮----
streamDelay: 3000 // 3 second delay
⋮----
// Route to executor
⋮----
// Slow executor
⋮----
streamDelay: 4000 // 4 second delay
⋮----
// Final routing
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Execute workflow with slow responses
⋮----
// Verify execution took significant time due to delays
⋮----
// Verify workflow completed despite delays
⋮----
// Check that responses were received
⋮----
// Generate a large response string
⋮----
// Define scenarios with large responses
⋮----
// Initial routing
⋮----
// Executor with large response
⋮----
content: largeContent.substring(0, 10000) // Write a portion
⋮----
// Complete
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Track memory before execution
⋮----
// Execute workflow
⋮----
// Track memory after execution
⋮----
// Verify memory increase is reasonable (less than 50MB for large response)
⋮----
// Verify large response was handled
⋮----
// Define scenarios that would loop indefinitely
⋮----
// Orchestrator keeps routing to itself
⋮----
// Planner keeps continuing
⋮----
// Orchestrator routes back to planner
⋮----
// Add scenarios to mock
⋮----
// Create conversation
⋮----
// Execute with low iteration limit
⋮----
// Verify execution stopped at iteration limit
⋮----
// Verify we hit planner multiple times (looping)
⋮----
// Define scenarios for multiple conversations
⋮----
// Generic routing
⋮----
// Generic executor
⋮----
// Generic completion
⋮----
// Add scenarios to mock
⋮----
// Create multiple conversations
⋮----
// Execute all conversations concurrently
⋮----
// Verify all completed
⋮----
// Verify concurrent execution was faster than sequential would be
// With streamDelay of 1000ms per operation, sequential would take ~3000ms minimum
// Concurrent should be significantly faster
⋮----
// Simple fast-response scenario
⋮----
// Add scenarios to mock
⋮----
// Create many conversations to simulate high load
⋮----
// Execute all conversations at once (high load)
⋮----
// Verify all conversations completed
⋮----
// Verify none failed
⋮----
// Verify system handled load in reasonable time (less than 30 seconds)
</file>

<file path=".gitignore">
# Dependencies
node_modules/
.pnp
.pnp.js

# Build outputs
dist/
build/
out/
.next/
.nuxt/
.cache/

# Testing
coverage/
.nyc_output/
test-results/
playwright-report/
playwright/.cache/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Temporary files
tmp/
temp/
.tmp/

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
.tenex/
llms.json
agents.json
.wallet.json
*.bak
*.tmp

# Test artifacts
test-*.json
test-*.txt
__snapshots__/.repomix-output.txt
.repomix-output.txt
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "ES2020",
        "lib": ["ES2020"],
        "moduleResolution": "node",
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "downlevelIteration": true,
        "strict": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true,
        "noEmit": true,
        "rootDir": "./src",
        "outDir": "./dist",
        "baseUrl": ".",
        "paths": {
            "@/*": ["./src/*"]
        },
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "resolveJsonModule": true,
        "isolatedModules": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts", "src/test-utils/**/*"]
}
</file>

<file path="context/conversations.md">
# Conversation Management System

## Overview

The conversation management system is the core infrastructure that maintains context, state, and continuity across multi-agent interactions in TENEX. It ensures that every agent has the complete context needed to provide coherent responses while managing the complexity of asynchronous, multi-participant conversations.

## Core Concepts

### 1. Conversation

A conversation represents a complete interaction thread initiated by a user. It maintains:
- **Unique identifier**: The ID of the initiating event
- **Title**: Human-readable description of the conversation
- **Phase**: Current operational phase (chat, brainstorm, plan, execute, verification, chores, reflection)
- **History**: Ordered sequence of all events (messages) in the conversation
- **Agent States**: Per-agent tracking of conversation position and session information
- **Metadata**: Additional context like summaries, referenced articles, and execution timing

### 2. Agent State

Each agent participating in a conversation maintains its own state:
- **lastProcessedMessageIndex**: Position in the conversation history that the agent has processed
- **claudeSessionId**: Optional session identifier for maintaining API-level continuity with Claude

### 3. Event Types

Events in a conversation can be:
- **User messages**: Direct input from the human user
- **Agent responses**: Messages from AI agents
- **System events**: Phase transitions, handoffs, and other system-level notifications

## Message Building Process

When an agent needs to respond to a conversation, the system constructs a complete message context following these principles:

### Complete History Reconstruction

The system provides the FULL conversation history to maintain perfect context continuity. This is critical for agents to:
- Answer questions about earlier parts of the conversation
- Maintain consistent understanding of the task
- Reference previous decisions and context

The history includes:
1. **All previous messages** up to (but not including) the current triggering event
2. **Proper role attribution** for each message:
   - User messages → `user` role
   - Agent's own previous messages → `assistant` role  
   - Other agents' messages → `system` role with attribution
3. **Chronological ordering** to maintain conversation flow

### Message Role Assignment

The system uses standard LLM conversation roles:

- **user**: Messages from the human user
- **assistant**: The agent's own previous responses
- **system**: Messages from other agents (with attribution) and system notifications

This standard format ensures compatibility with LLM APIs and provides clear conversation structure.

### "Messages While You Were Away" Block

This special block is used ONLY when there are genuinely new messages from other participants that the agent hasn't seen yet (messages after the agent's `lastProcessedMessageIndex`). It serves to:
- Alert the agent to activity that occurred while it was inactive
- Provide handoff context when agents transition work
- Highlight important updates that need immediate attention
- Show messages from other agents that have been added since the agent last processed the conversation

The block is NOT used when:
- The agent's own messages are being provided (these are `assistant` messages)
- The agent is continuing a direct conversation with the user
- There are no new messages from others since the agent's last interaction

### NEW INTERACTION Marker

The "=== NEW INTERACTION ===" marker works in conjunction with the "MESSAGES WHILE YOU WERE AWAY" block to differentiate between:
- The backfilled context (messages while away)
- The new message that the agent needs to respond to

The marker is added ONLY when:
- A "MESSAGES WHILE YOU WERE AWAY" block has been added
- The agent needs a clear delineation between the backfilled messages and the current triggering event

The marker is NOT added when:
- There's no "MESSAGES WHILE YOU WERE AWAY" block
- The conversation flow is already clear (e.g., direct user message with no intervening messages)

This dual-marker system ensures agents can distinguish between context they're being caught up on versus the actual message they need to respond to.

## Agent Participation Patterns

### Direct P-tagging (First Message)

When a user starts a conversation by directly addressing an agent (e.g., "@project-manager"):
- The agent is immediately added to the conversation
- No "MESSAGES WHILE YOU WERE AWAY" block (nothing happened before)
- No "NEW INTERACTION" marker (agent is directly addressed)
- The agent's state starts at index 0

### P-tagging Mid-Conversation

When a user brings a new agent into an existing conversation:
- The agent receives the complete conversation history
- All previous messages are provided in proper role format
- The agent can see everything that happened before being invited
- No "MESSAGES WHILE YOU WERE AWAY" unless there are additional unprocessed messages

### Conversation Continuation

When an agent continues an ongoing conversation:
- Full conversation history is provided
- Agent's own messages appear as `assistant` role
- User messages appear as `user` role
- Other agents' messages appear as `system` role with attribution

### Multi-Agent Interactions

When multiple agents participate:
- Each agent maintains its own state and position in the conversation
- Agents see each other's messages as system messages with clear attribution
- The full conversation context is maintained for all participants
- Handoff summaries can be provided for context during phase transitions

## State Management

### Agent State Initialization

When an agent first joins a conversation:
1. Check if the agent is being directly addressed in the triggering event
2. If it's the first message and the agent is p-tagged, start at index 0
3. If joining mid-conversation, start at index 0 to see full history
4. Store the initial state in the conversation's agent states map

### State Updates

After each agent interaction:
1. Update `lastProcessedMessageIndex` to current history length
2. Preserve any session IDs from the triggering event
3. Save the updated state for future continuity

### Session Management

Claude session IDs are:
- Extracted from triggering events when present
- Stored in the agent's state
- Preserved across multiple interactions
- Updated when new session IDs are provided
- Used to maintain API-level conversation continuity

## Critical Requirements

### Context Completeness

**Every agent must receive the complete conversation history** to maintain coherent context. This is non-negotiable because:
- Agents may be asked about any part of the conversation
- Context loss leads to confusion and incorrect responses
- Full history enables proper reasoning and decision-making

### Message Ordering

Messages must be provided in strict chronological order to maintain conversation flow. The system:
- Preserves the exact sequence of events
- Maintains proper alternation between participants
- Ensures cause-and-effect relationships are clear

### Role Consistency

Message roles must follow standard LLM conventions:
- `user` for human input
- `assistant` for the agent's own messages
- `system` for other agents and system notifications

### Attribution Clarity

When multiple agents participate, clear attribution is essential:
- Other agents' messages include their name in brackets
- System messages are clearly marked
- Handoff context is explicitly provided

## Error Prevention

### Common Pitfalls to Avoid

1. **Never provide only recent messages** - Always include full history
2. **Never mix message roles** - Maintain clear role distinctions
3. **Never duplicate the triggering event** - It should appear only once as the primary message
4. **Never show "MESSAGES WHILE YOU WERE AWAY" for the agent's own messages**
5. **Never lose session IDs** - Preserve them across interactions

### Validation Requirements

The system must ensure:
- All messages have content and proper roles
- Agent states are properly initialized before use
- History is complete and properly ordered
- Session IDs are preserved when present
- Attribution is clear for all participants

## Phase Transitions and Handoffs

When agents hand off work or transition phases:
- The receiving agent gets full conversation context
- Handoff summaries provide transition context
- Phase metadata is updated appropriately
- All participants maintain their individual states

## Testing Considerations

Critical scenarios that must be tested:
1. **Single agent conversations** with multiple exchanges
2. **P-tagging agents** at conversation start vs mid-conversation
3. **Multi-agent interactions** with proper attribution
4. **Session ID management** across interactions
5. **Phase transitions** with context preservation
6. **Agent handoffs** with summary context
7. **NEW INTERACTION marker** appearing only when MESSAGES WHILE YOU WERE AWAY is present
8. **Complete history preservation** across all scenarios

## Implementation Notes

### Message Building Logic

The `buildAgentMessages` function follows this sequence:
1. **Build complete conversation history** - All messages up to but not including the triggering event
2. **Check for messages while away** - Messages from others after `lastProcessedMessageIndex`
3. **Add MESSAGES WHILE YOU WERE AWAY block** - Only if there are new messages from others
4. **Add NEW INTERACTION marker** - Only if a "while away" block was added
5. **Add the triggering event** - The actual message to respond to

Key implementation details:
- Messages from others after `lastProcessedMessageIndex` are included in "MESSAGES WHILE YOU WERE AWAY"
- The check no longer excludes messages already in `allPreviousMessages` 
- NEW INTERACTION marker is conditional on the presence of the "while away" block

Key functions involved in the conversation management:
- `buildAgentMessages`: Constructs the complete message context for an agent
- `addEvent`: Adds new events to conversation history
- `updatePhase`: Manages phase transitions
- `updateAgentState`: Updates agent-specific state information
- `getEventSender`/`getEventSenderForHistory`: Determines message attribution

The system maintains conversation state through:
- In-memory conversation map
- Persistent storage via FileSystemAdapter
- Agent state tracking per conversation
- Session ID management for API continuity

## Performance Considerations

While providing full history is essential for context:
- History is built efficiently in a single pass
- Messages are constructed in order without redundant processing
- Agent states prevent unnecessary reprocessing
- Persistence is handled asynchronously where possible

## Key Components

- **`ConversationManager.ts`**: The main class that manages the lifecycle of conversations. It provides methods for creating, retrieving, and updating conversations.

- **`persistence/`**: This directory contains the logic for persisting conversations to storage. It includes a `FileSystemAdapter` that saves conversations to the local filesystem.

- **`types.ts`**: Defines the data structures and types used throughout the conversations module, such as `Conversation`, `Message`, and `AgentContext`.

- **`phases.ts`**: Defines the different phases of a conversation, such as `CHAT`, `PLAN`, and `EXECUTE`.

- **`executionTime.ts`**: A utility for tracking the execution time of different parts of the conversation.
</file>

<file path="context/PROJECT.md">
# Project Name: TENEX

## 1. Core Concept

TENEX is a multi-agent development environment designed to build software through the collaboration of AI agents. It operates on the Nostr protocol, creating a decentralized and context-aware system where human developers guide high-level strategy while autonomous agents handle the low-level implementation tasks.

The fundamental shift is from traditional coding in a text editor to managing and providing context to a team of AI agents who write the code.

## 2. Key Features

*   **Multi-Agent Architecture:** The system is composed of specialized AI agents, each with a distinct role (e.g., Planner, Executor, Project Manager, human-replica).
*   **Invisible Orchestrator:** A central component that intelligently routes user requests and agent responses to the most appropriate agent, creating a seamless workflow.
*   **Phase-Based Workflow:** Every development task follows a structured, cyclical process:
    1.  **CHAT:** Requirements gathering and clarification.
    2.  **BRAINSTORM:** Idea exploration and refinement.
    3.  **PLAN:** Architectural design and technical specification.
    4.  **EXECUTE:** Code implementation and review.
    5.  **VERIFICATION:** Functional testing from an end-user perspective.
    6.  **CHORES:** Cleanup, documentation, and maintenance.
    7.  **REFLECTION:** Agents learn from the completed task to improve future performance.
*   **Conversation Restart:** When a conversation reaches its natural conclusion (the `END` phase), it is not permanently closed. If the user provides a new message, a new conversation is automatically started from the `CHAT` phase, preserving the full history and context. This ensures a seamless and continuous user experience.
*   **Continuous Learning:** Agents are designed to learn from every interaction, building a persistent knowledge base that improves their effectiveness over time.
*   **Nostr-Native:** Built on the Nostr protocol, ensuring communication is decentralized, secure, and censorship-resistant.
*   **LLM Agnostic:** Supports multiple Large Language Model providers, including OpenAI, Anthropic, and Google.
*   **Agent Presence & Identification (User-defined requirement):**
    *   **Online Status:** Agent online status must be determined by querying for `kind:24010` status events with a `since` filter of one minute ago. The `a` tag of the status event must be compared with the project's tag ID to ensure the status applies to the correct project.
    *   **Agent ID Format:** When returning agent information, the agent's `npub` must be used instead of their public key.
    *   **Agent Self-Knowledge:** Agents must be explicitly informed of their own `npub` as part of their core identity prompt.

## 3. Guiding Principles

*   **Context is King:** The primary role of the human user is to provide clear and comprehensive context. The agents' success is directly tied to the quality of this context.
*   **Human as Orchestrator:** The user acts as a high-level director, making strategic decisions and guiding the AI team, rather than writing code line-by-line.
*   **Automation of Toil:** The goal is to automate the repetitive and tedious aspects of software development, freeing up human developers to focus on creative and strategic challenges.

## 4. Technical Stack (Inferred from README)

*   **Runtime:** Node.js / Bun
*   **Protocol:** Nostr
*   **Version Control:** Git

## 5. Project Goals (Inferred from README)

*   To create a new paradigm for software development that is more efficient and powerful than traditional methods.
*   To leverage the power of multiple, specialized AI agents to tackle complex programming tasks.
*   To build a system that is robust, decentralized, and continuously improves itself.
</file>

<file path="src/commands/agent/add.ts">
import { AgentRegistry } from "@/agents/AgentRegistry";
import { DEFAULT_AGENT_LLM_CONFIG } from "@/llm/constants";
import { configService } from "@/services/ConfigService";
import { logger } from "@/utils/logger";
import { resolveConfigScope, formatConfigScope } from "@/utils/cli-config-scope";
import { isValidSlug } from "@/utils/validation";
import { confirm, input } from "@inquirer/prompts";
import { Command } from "commander";
⋮----
interface AddOptions {
    project?: boolean;
    global?: boolean;
}
⋮----
// Determine where to save
⋮----
// Interactive wizard
⋮----
// Determine the base path for the registry
⋮----
// Load existing registry
⋮----
// Check if agent already exists
⋮----
// If creating a project agent, check if it would shadow a global one
⋮----
// If we can't load global agents, continue anyway
⋮----
// Create agent config
⋮----
// Use AgentRegistry to ensure agent (this handles all file operations and Nostr publishing)
</file>

<file path="src/commands/inventory/index.ts">
import { generateInventory, updateInventory } from "@/utils/inventory";
import { logger } from "@/utils/logger";
import { ensureProjectInitialized } from "@/utils/projectInitialization";
import { handleCliError } from "@/utils/cli-error";
import { Command } from "commander";
import chalk from "chalk";
⋮----
// Initialize project context
⋮----
// Initialize project context
</file>

<file path="src/commands/project/run.ts">
import { ProjectDisplay } from "@/commands/run/ProjectDisplay";
import { StatusPublisher } from "@/commands/run/StatusPublisher";
import { SubscriptionManager } from "@/commands/run/SubscriptionManager";
import { EventHandler } from "@/event-handler";
import { loadLLMRouter } from "@/llm";
import { getNDK, shutdownNDK } from "@/nostr/ndkClient";
import { getProjectContext } from "@/services";
import { mcpService } from "@/services/mcp/MCPService";
import { logger } from "@/utils/logger";
import { handleCliError } from "@/utils/cli-error";
import { formatAnyError } from "@/utils/error-formatter";
import { setupGracefulShutdown } from "@/utils/process";
import { ensureProjectInitialized } from "@/utils/projectInitialization";
import type NDK from "@nostr-dev-kit/ndk";
import { Command } from "commander";
⋮----
// Initialize project context (includes NDK setup)
⋮----
// Display project information
⋮----
// Start the project listener
⋮----
// Don't double-log project configuration errors
// as they're already handled in ensureProjectInitialized
⋮----
async function runProjectListener(projectPath: string, ndk: NDK): Promise<void>
⋮----
// Load LLM router
⋮----
// Initialize MCP service
⋮----
// Initialize event handler
⋮----
// Initialize subscription manager
⋮----
// Start status publisher
⋮----
// Set up graceful shutdown
⋮----
// Stop subscriptions first
⋮----
// Stop status publisher
⋮----
// Clean up event handler subscriptions
⋮----
// Shutdown MCP service
⋮----
// Shutdown NDK singleton
⋮----
// Keep the process running
⋮----
// This promise never resolves, keeping the listener active
</file>

<file path="src/conversations/__tests__/ConversationManager.agentContext.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { ConversationManager } from "../ConversationManager";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { AgentInstance } from "@/agents/types";
import { Message } from "multi-llm-ts";
⋮----
// Mock the persistence module
⋮----
// Mock the tracing module
⋮----
// Mock the logging module
⋮----
// Mock NDK
⋮----
// Mock project context and utils
⋮----
// User creates conversation by p-tagging project-manager
⋮----
// Build messages for p-tagged agent
⋮----
// Should NOT have "MESSAGES WHILE YOU WERE AWAY" block
⋮----
// Should have the user message as primary message
⋮----
// Agent state should be at index 1 (after the triggering event)
⋮----
// Start conversation
⋮----
// Add orchestrator response
⋮----
// User p-tags developer
⋮----
// Developer should see the full conversation history
// First user message
⋮----
// Orchestrator's response as system (from another agent)
⋮----
// Current triggering message should be last
⋮----
// User starts conversation with PM
⋮----
// First interaction - build messages for PM
⋮----
// PM responds
⋮----
// User continues conversation
⋮----
// Build messages for PM continuation
⋮----
// Should NOT have a history block (no other participants spoke while away)
⋮----
// Should have the FULL conversation history
// First user message
⋮----
// PM's response as assistant
⋮----
// Current message should be the user's continuation
⋮----
// Create conversation
⋮----
// Orchestrator responds
⋮----
// User continues
⋮----
// Build messages for orchestrator
⋮----
// Should NOT have history block (only the orchestrator's own message)
⋮----
// Orchestrator's own previous response should be an assistant message
⋮----
// Should NOT have NEW INTERACTION marker (no messages while away)
⋮----
// Should NOT have NEW INTERACTION marker when directly addressed
⋮----
// Non-orchestrator agents should never get NEW INTERACTION
⋮----
// Start conversation
⋮----
// Orchestrator responds
⋮----
// User continues
⋮----
// Should NOT have NEW INTERACTION on continuation
⋮----
// User message with Claude session ID
⋮----
// Build messages and verify session ID is captured
⋮----
// Verify it's stored in agent state
⋮----
// User p-tags PM with one session
⋮----
// PM responds
⋮----
// User p-tags developer with different session
⋮----
// Each agent should have their own session ID
⋮----
// First interaction with session ID
⋮----
// PM responds
⋮----
// Second interaction without explicit session ID
⋮----
// Session ID should persist
⋮----
// First interaction with session ID
⋮----
// PM responds
⋮----
// New interaction with new session ID
⋮----
// Should have the new session ID
⋮----
// Event without session ID
⋮----
// Should be undefined
⋮----
// Create conversation
⋮----
// Manually update agent state with session ID
⋮----
// Verify it was updated
⋮----
// Build messages again and verify session persists
</file>

<file path="src/conversations/executionQueue/ExecutionQueueManager.ts">
import { EventEmitter } from 'events';
import { LockManager } from './LockManager';
import { QueueManager } from './QueueManager';
import { TimeoutManager } from './TimeoutManager';
import { ExecutionEventPublisher } from './ExecutionEventPublisher';
import { NostrEventService } from '../../nostr/NostrEventService';
import {
  ExecutionPermission,
  ExecutionQueueConfig,
  DEFAULT_EXECUTION_QUEUE_CONFIG,
  ForceReleaseRequest,
  ExecutionHistory,
  ExecutionLock,
  QueueStatus
} from './types';
⋮----
export interface ExecutionQueueManagerEvents {
  'lock-acquired': (conversationId: string, agentPubkey: string) => void;
  'lock-released': (conversationId: string, reason: string) => void;
  'queue-joined': (conversationId: string, position: number) => void;
  'queue-left': (conversationId: string) => void;
  'timeout-warning': (conversationId: string, remainingMs: number) => void;
  'timeout': (conversationId: string) => void;
}
⋮----
export class ExecutionQueueManager extends EventEmitter
⋮----
constructor(
    projectPath: string,
    private projectPubkey?: string,
    projectIdentifier?: string,
    nostrService?: NostrEventService,
    config: Partial<ExecutionQueueConfig> = {}
)
⋮----
// Initialize components
⋮----
// Set up event publisher if Nostr service is available
⋮----
// Set up timeout event handlers
⋮----
private setupTimeoutHandlers(): void
⋮----
async initialize(): Promise<void>
⋮----
// Check for any stale locks on startup
⋮----
private async checkStaleLock(): Promise<void>
⋮----
// Release the stale lock
⋮----
async requestExecution(conversationId: string, agentPubkey: string): Promise<ExecutionPermission>
⋮----
// Check current lock status
⋮----
// Lock is available, acquire immediately
⋮----
// Already holds the lock
⋮----
// Add to queue and wait
⋮----
// Emit queue joined event
⋮----
// Publish status update
⋮----
// Publish queue event
⋮----
private async acquireLock(conversationId: string, agentPubkey: string): Promise<ExecutionPermission>
⋮----
// Start timeout timer
⋮----
// Record execution start
⋮----
// Emit lock acquired event
⋮----
// Publish status update
⋮----
// Publish lock acquired event
⋮----
async releaseExecution(conversationId: string, reason: string = 'completed'): Promise<void>
⋮----
// Not holding the lock, nothing to release
⋮----
// Clear timeout
⋮----
// Record execution history
⋮----
// Release the lock
⋮----
// Emit lock released event
⋮----
// Publish lock released event
⋮----
// Process next in queue
⋮----
// Publish updated status
⋮----
private async processNextInQueue(): Promise<void>
⋮----
return; // Queue is empty
⋮----
// Emit queue left event for the conversation being promoted
⋮----
// Grant execution permission
⋮----
// The conversation manager will be notified via events
// and can transition the conversation to EXECUTE phase
⋮----
// If acquisition failed, try the next one
⋮----
async forceRelease(conversationId: string, reason: string): Promise<void>
⋮----
// Not locked by this conversation
⋮----
// Create force release request
⋮----
// Publish force release event
⋮----
// Release the lock
⋮----
async forceReleaseAny(reason: string): Promise<string | null>
⋮----
private async handleTimeout(conversationId: string): Promise<void>
⋮----
// Force release due to timeout
⋮----
// Emit timeout event
⋮----
async removeFromQueue(conversationId: string): Promise<boolean>
⋮----
// Publish queue left event
⋮----
async getCurrentLock(): Promise<ExecutionLock | null>
⋮----
async getQueueStatus(): Promise<QueueStatus>
⋮----
async getQueuePosition(conversationId: string): Promise<number>
⋮----
async isExecuting(conversationId: string): Promise<boolean>
⋮----
async isQueued(conversationId: string): Promise<boolean>
⋮----
private async publishStatusUpdate(): Promise<void>
⋮----
private formatWaitTime(seconds: number): string
⋮----
// Utility methods for monitoring and debugging
async getFullStatus(): Promise<
⋮----
async clearAll(): Promise<void>
⋮----
// Clear all timeouts
⋮----
// Force release any lock
⋮----
// Clear the queue
⋮----
// Publish updated status
⋮----
// Override EventEmitter methods for type safety
on<K extends keyof ExecutionQueueManagerEvents>(
    event: K,
    listener: ExecutionQueueManagerEvents[K]
): this
⋮----
emit<K extends keyof ExecutionQueueManagerEvents>(
    event: K,
    ...args: Parameters<ExecutionQueueManagerEvents[K]>
): boolean
⋮----
off<K extends keyof ExecutionQueueManagerEvents>(
    event: K,
    listener: ExecutionQueueManagerEvents[K]
): this
</file>

<file path="src/conversations/executionQueue/QueueManager.ts">
import { QueueEntry, QueueStatus, ExecutionQueueConfig, DEFAULT_EXECUTION_QUEUE_CONFIG, ExecutionHistory } from './types';
import { writeJsonFile, readJsonFile, ensureDirectory, handlePersistenceError, fileExists } from '../../utils/file-persistence';
⋮----
export class QueueManager
⋮----
constructor(
    projectPath: string,
    config: Partial<ExecutionQueueConfig> = {}
)
⋮----
async initialize(): Promise<void>
⋮----
// Ensure persistence directory exists
⋮----
// Load queue and history from disk
⋮----
async enqueue(conversationId: string, agentPubkey: string): Promise<number>
⋮----
// Check if already in queue
⋮----
return existingIndex + 1; // Return 1-based position
⋮----
// Check queue size limit
⋮----
async dequeue(): Promise<QueueEntry | null>
⋮----
async removeFromQueue(conversationId: string): Promise<boolean>
⋮----
async requeue(entry: QueueEntry): Promise<number>
⋮----
// Increment retry count
⋮----
// Add back to front of queue (priority for retries)
⋮----
return 1; // Always position 1 for requeued items
⋮----
getQueueStatus(): QueueStatus
⋮----
queue: [...this.queue] // Return copy
⋮----
getQueuePosition(conversationId: string): number
⋮----
isInQueue(conversationId: string): boolean
⋮----
async addToHistory(history: ExecutionHistory): Promise<void>
⋮----
// Trim history if it exceeds max size
⋮----
getRecentExecutionHistory(count: number = 50): ExecutionHistory[]
⋮----
getAverageExecutionTime(): number
⋮----
return 10 * 60; // Default 10 minutes in seconds
⋮----
return 10 * 60; // Default if no valid executions
⋮----
return totalTime / validExecutions.length / 1000; // Convert to seconds
⋮----
private calculateEstimatedWait(): number
⋮----
// Base estimation on historical execution times
⋮----
// Estimate for queued conversations (assuming current execution is halfway done)
⋮----
private async saveQueueToDisk(): Promise<void>
⋮----
// Don't throw - allow operation to continue without persistence
⋮----
private async loadQueueFromDisk(): Promise<void>
⋮----
// Validate queue entries
⋮----
this.queue = []; // No queue file exists
⋮----
private async saveHistoryToDisk(): Promise<void>
⋮----
// Don't throw - allow operation to continue without persistence
⋮----
private async loadHistoryFromDisk(): Promise<void>
⋮----
// Validate history entries
⋮----
// Trim to max size
⋮----
this.executionHistory = []; // No history file exists
⋮----
// Utility methods for monitoring and debugging
getQueueInfo():
⋮----
clearQueue(): void
⋮----
clearHistory(): void
</file>

<file path="src/conversations/services/ConversationEventProcessor.ts">
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import { NDKArticle } from "@nostr-dev-kit/ndk";
import type { Conversation, ConversationMetadata } from "../types";
import { PHASES } from "../phases";
import { isEventFromUser, getAgentSlugFromEvent } from "@/nostr/utils";
import { getNDK } from "@/nostr";
import { logger } from "@/utils/logger";
import { ensureExecutionTimeInitialized } from "../executionTime";
⋮----
/**
 * Processes events and creates/updates conversations.
 * Single Responsibility: Handle event processing and metadata extraction.
 */
export class ConversationEventProcessor
⋮----
/**
     * Create a new conversation from an initial event
     */
async createConversationFromEvent(event: NDKEvent): Promise<Conversation>
⋮----
/**
     * Process an incoming event and add it to a conversation
     */
processIncomingEvent(conversation: Conversation, event: NDKEvent): void
⋮----
// Check if event already exists in history to prevent duplicates
⋮----
// Add to history
⋮----
// Update metadata if it's a user message
⋮----
/**
     * Update conversation metadata
     */
updateMetadata(conversation: Conversation, metadata: Partial<ConversationMetadata>): void
⋮----
/**
     * Extract referenced NDKArticle from event tags
     */
private async extractReferencedArticle(event: NDKEvent): Promise<ConversationMetadata["referencedArticle"] | undefined>
⋮----
// Parse the article reference (format: 30023:pubkey:dtag)
⋮----
/**
     * Clean up conversation metadata that's no longer needed
     */
cleanupMetadata(conversation: Conversation): void
⋮----
// Clear readFiles tracking
⋮----
// Clear queue status if present
⋮----
/**
     * Extract completion from an event (if it's a complete() tool call)
     */
extractCompletionFromEvent(event: NDKEvent):
⋮----
// Check if event has ["tool", "complete"] tag
⋮----
// Get agent slug from the event's pubkey
</file>

<file path="src/conversations/services/PhaseManager.ts">
import type { Phase } from "../phases";
import { PHASES, getValidTransitions } from "../phases";
import type { Conversation, PhaseTransition } from "../types";
import type { ExecutionQueueManager } from "../executionQueue";
import { logger } from "@/utils/logger";
⋮----
export interface PhaseTransitionContext {
    agentPubkey: string;
    agentName: string;
    message: string;
    reason?: string;
    summary?: string;
}
⋮----
export interface PhaseTransitionResult {
    success: boolean;
    transition?: PhaseTransition;
    queued?: boolean;
    queuePosition?: number;
    queueMessage?: string;
    estimatedWait?: number;
}
⋮----
/**
 * Manages conversation phase transitions and validation.
 * Single Responsibility: Handle all phase-related logic and rules.
 */
export class PhaseManager
⋮----
constructor(private executionQueueManager?: ExecutionQueueManager)
⋮----
/**
     * Check if a phase transition is valid
     */
canTransition(from: Phase, to: Phase): boolean
⋮----
// Allow same-phase transitions (handoffs between agents)
⋮----
// Check if the transition is in the allowed list
⋮----
/**
     * Attempt a phase transition
     */
async transition(
        conversation: Conversation,
        to: Phase,
        context: PhaseTransitionContext
): Promise<PhaseTransitionResult>
⋮----
// Validate transition
⋮----
// Same phase handoff is always allowed
⋮----
// Handle EXECUTE phase entry with queue management
⋮----
// Handle EXECUTE phase exit
⋮----
// Create transition record
⋮----
/**
     * Get the rules for a specific phase
     */
getPhaseRules(phase: Phase):
⋮----
// All phases can transition to all other phases
⋮----
/**
     * Setup queue event listeners
     */
setupQueueListeners(
        onLockAcquired: (conversationId: string, agentPubkey: string) => Promise<void>,
        onTimeout: (conversationId: string) => Promise<void>,
        onTimeoutWarning: (conversationId: string, remainingMs: number) => Promise<void>
): void
⋮----
private formatQueueMessage(position: number, waitTimeSeconds: number): string
⋮----
private formatWaitTime(seconds: number): string
</file>

<file path="src/event-handler/task.ts">
import type { NDKTask } from "@nostr-dev-kit/ndk";
import chalk from "chalk";
import type { AgentExecutor } from "../agents/execution/AgentExecutor";
import type { ConversationManager } from "../conversations";
import { getProjectContext } from "../services";
import { formatAnyError } from "../utils/error-formatter";
import { logger } from "../utils/logger";
import { AgentInstance } from "@/agents";
import { createNostrPublisher } from "../nostr/factory";
⋮----
interface EventHandlerContext {
    conversationManager: ConversationManager;
    agentExecutor: AgentExecutor;
}
⋮----
export const handleTask = async (event: NDKTask, context: EventHandlerContext): Promise<void> =>
⋮----
// Extract p-tags to identify mentioned agents
⋮----
// Create conversation from NDKTask
⋮----
// Log the claude-session tag if present
⋮----
// Get project context
⋮----
// Get Project Manager as default coordinator
⋮----
// If there are p-tags, check if any match system agents
⋮----
// Default to PM for task coordination
⋮----
// Execute with the appropriate agent
</file>

<file path="src/events/NDKAgentLesson.ts">
import { NDKEvent, type NDKRawEvent } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
⋮----
export class NDKAgentLesson extends NDKEvent
⋮----
constructor(ndk?: NDK, event?: NDKEvent | NDKRawEvent)
⋮----
static from(event: NDKEvent): NDKAgentLesson
⋮----
get title(): string | undefined
⋮----
/**
   * Title/description of what this lesson is about.
   */
set title(value: string | undefined)
⋮----
// Alias for title
get description(): string | undefined
⋮----
set description(value: string | undefined)
⋮----
/**
   * The lesson content - what the agent learned.
   * This is stored in the event content.
   */
get lesson(): string
⋮----
set lesson(value: string)
⋮----
/**
   * Set the agent that this lesson belongs to.
   * @param agentEvent The NDKAgentDefinition event to reference
   */
set agentDefinitionId(agentDefinitionId: string)
⋮----
/**
   * Get the agent event ID this lesson belongs to.
   */
get agentDefinitionId(): string | undefined
⋮----
/**
   * Metacognition reasoning - why this lesson is worth learning
   */
get metacognition(): string | undefined
⋮----
set metacognition(value: string | undefined)
⋮----
/**
   * Detailed version of the lesson with richer explanation
   */
get detailed(): string | undefined
⋮----
set detailed(value: string | undefined)
⋮----
/**
   * Category for filing this lesson
   */
get category(): string | undefined
⋮----
set category(value: string | undefined)
⋮----
/**
   * Hashtags for easier sorting and discovery
   */
get hashtags(): string[]
⋮----
set hashtags(values: string[])
</file>

<file path="src/llm/testing/LLMTester.ts">
import type { ResolvedLLMConfig, LLMProvider } from "@/llm/types";
import type { TenexLLMs } from "@/services/config/types";
import { logger } from "@/utils/logger";
import { igniteEngine, Message } from "multi-llm-ts";
import { getModelsForProvider } from "../models";
⋮----
/**
 * LLM Configuration Testing Utility
 */
export class LLMTester
⋮----
/**
     * Test an LLM configuration by sending a test message
     */
async testLLMConfig(config: ResolvedLLMConfig): Promise<boolean>
⋮----
// Find the specific model - handle both string and ChatModel types
⋮----
/**
     * Test an existing configuration by name
     */
async testExistingConfiguration(
        configName: string,
        configurations: TenexLLMs['configurations'],
        credentials: TenexLLMs['credentials']
): Promise<boolean>
⋮----
// Build the resolved config with credentials
⋮----
// Add credentials if available
⋮----
/**
     * Validate configuration before testing
     */
validateConfigForTesting(config: ResolvedLLMConfig):
⋮----
/**
     * Get test message for specific provider (could be customized per provider)
     */
getTestMessage(_provider: LLMProvider): Message
⋮----
// For now, use the same test message for all providers
// This could be customized per provider in the future
⋮----
/**
     * Validate test response
     */
isTestSuccessful(response: string): boolean
</file>

<file path="src/llm/ui/LLMConfigUI.ts">
import type {
    ApiKeyResult,
    ConfigurationPrompts,
    LLMConfigWithName,
    LLMProvider,
} from "@/llm/types";
import type { TenexLLMs } from "@/services/config/types";
import { logger } from "@/utils/logger";
import chalk from "chalk";
import inquirer from "inquirer";
import { LLM_DEFAULTS } from "../constants";
⋮----
export class LLMConfigUI
⋮----
constructor(private isGlobal: boolean)
⋮----
displayCurrentConfigurations(configs: LLMConfigWithName[], llmsConfig: TenexLLMs): void
⋮----
async promptMainMenuAction(configs: LLMConfigWithName[], llmsConfig: TenexLLMs): Promise<string>
⋮----
async promptOnboardingAction(
        configs: LLMConfigWithName[], 
        llmsConfig: TenexLLMs, 
        hasAddedConfig: boolean
): Promise<string>
⋮----
async promptProviderSelection(): Promise<LLMProvider>
⋮----
async promptApiKey(existingKeys: string[], provider: LLMProvider): Promise<ApiKeyResult>
⋮----
async promptConfigurationSettings(
        defaultConfigName: string,
        existingConfigs: Record<string, any>,
        supportsCaching: boolean,
        provider: LLMProvider,
        model: string
): Promise<ConfigurationPrompts>
⋮----
// Add caching prompt conditionally
⋮----
async promptRetryOnTestFailure(): Promise<boolean>
⋮----
async promptConfigurationToEdit(configs: LLMConfigWithName[]): Promise<string>
⋮----
async promptFieldToEdit(): Promise<string>
⋮----
async promptNewApiKey(): Promise<string>
⋮----
async promptEnableCaching(currentValue: boolean): Promise<boolean>
⋮----
async promptNewConfigName(currentName: string, existingConfigs: Record<string, any>): Promise<string>
⋮----
async promptConfigurationToRemove(configs: LLMConfigWithName[]): Promise<string>
⋮----
async promptConfirmRemoval(configName: string): Promise<boolean>
⋮----
async promptDefaultConfiguration(
        configs: LLMConfigWithName[],
        currentDefault: string,
        typeLabel: string
): Promise<string>
⋮----
async promptConfigurationToTest(configs: LLMConfigWithName[]): Promise<string>
</file>

<file path="src/prompts/fragments/35-specialist-completion-guidance.ts">
import type { PromptFragment } from "../core/types";
import type { Phase } from "@/conversations/phases";
import { fragmentRegistry } from "../core/FragmentRegistry";
⋮----
/**
 * Completion guidance for SPECIALISTS ONLY.
 * Orchestrator doesn't use complete() tool.
 * No conditionals, no isOrchestrator checks.
 */
interface SpecialistCompletionGuidanceArgs {
    phase: Phase;
}
⋮----
// CHAT and BRAINSTORM phases don't require termination
⋮----
CHAT: "", // Handled above
BRAINSTORM: "", // Handled above
⋮----
// Register the fragment
</file>

<file path="src/services/config/types.ts">
import { z } from "zod";
⋮----
/**
 * Unified configuration types for TENEX
 * All configuration files use the same schemas for both global and project contexts
 */
⋮----
// =====================================================================================
// MAIN CONFIG SCHEMA (config.json)
// =====================================================================================
⋮----
export interface TenexConfig {
    // Global fields
    whitelistedPubkeys?: string[];

    // Project fields (optional for global config)
    description?: string;
    repoUrl?: string;
    projectNaddr?: string;
    paths?: {
        inventory?: string;
    };
}
⋮----
// Global fields
⋮----
// Project fields (optional for global config)
⋮----
// =====================================================================================
// AGENTS SCHEMA (agents.json)
// =====================================================================================
⋮----
export interface TenexAgents {
    [agentSlug: string]: {
        nsec: string;
        file: string;
        eventId?: string;
        orchestratorAgent?: boolean;
    };
}
⋮----
// =====================================================================================
// LLM SCHEMA (llms.json)
// =====================================================================================
⋮----
import type { LLMModelConfig, ProviderAuth } from "@/llm/types";
⋮----
export interface TenexLLMs {
    configurations: {
        [namedConfig: string]: LLMModelConfig;
    };
    defaults?: {
        agents?: string;
        [agentSlug: string]: string | undefined;
    };
    credentials: {
        [namedCredential: string]: ProviderAuth;
    };
}
⋮----
import { LLM_PROVIDERS } from "@/llm/types";
⋮----
// =====================================================================================
// MCP SCHEMA (mcp.json)
// =====================================================================================
⋮----
export interface MCPServerConfig {
    command: string;
    args: string[];
    env?: Record<string, string>;
    description?: string;
    allowedPaths?: string[];
    eventId?: string; // Nostr event ID this server was installed from
}
⋮----
eventId?: string; // Nostr event ID this server was installed from
⋮----
export interface TenexMCP {
    servers: Record<string, MCPServerConfig>;
    enabled: boolean;
}
⋮----
// =====================================================================================
// LOADED CONFIGURATION STATE
// =====================================================================================
⋮----
export interface LoadedConfig {
    config: TenexConfig;
    agents: TenexAgents;
    llms: TenexLLMs;
    mcp: TenexMCP;
}
⋮----
// =====================================================================================
// HELPER TYPES
// =====================================================================================
⋮----
export type ConfigFile = "config.json" | "agents.json" | "llms.json" | "mcp.json";
⋮----
export interface ConfigPaths {
    global: string;
    project?: string;
}
</file>

<file path="src/services/mcp/mcpInstaller.ts">
import { configService } from "@/services/ConfigService";
import { logger } from "@/utils/logger";
import type { NDKMCPTool } from "@/events/NDKMCPTool";
import type { MCPServerConfig } from "@/services/config/types";
⋮----
/**
 * Installs an MCP server from an NDKMCPTool event into a project's configuration
 * @param projectPath The root project path (not the .tenex directory)
 */
export async function installMCPServerFromEvent(
    projectPath: string,
    mcpTool: NDKMCPTool
): Promise<void>
⋮----
// Parse command and args
⋮----
// Build server config with event ID
⋮----
eventId: mcpTool.id, // Track the event ID
⋮----
// Load existing MCP config from the project's .tenex directory
⋮----
// Check if this event ID is already installed (only if we have an event ID)
⋮----
// Check if server with same name already exists
⋮----
// If it exists without an event ID and we're adding one with an event ID, update it
⋮----
// Add new server
⋮----
// Save config (saveProjectMCP expects the project root path)
⋮----
/**
 * Checks if an MCP tool with a given event ID is already installed
 */
export async function isMCPToolInstalled(
    projectPath: string,
    eventId: string
): Promise<boolean>
⋮----
// Load from the project's .tenex directory
⋮----
// Check if any server has this event ID
⋮----
/**
 * Gets all installed MCP tool event IDs (only those that have event IDs)
 */
export async function getInstalledMCPEventIds(projectPath: string): Promise<Set<string>>
⋮----
// Load from the project's .tenex directory
⋮----
// Only add if eventId exists (some MCP tools are manually installed without event IDs)
⋮----
/**
 * Removes an MCP server by its event ID
 */
export async function removeMCPServerByEventId(
    projectPath: string,
    eventId: string
): Promise<void>
⋮----
// Load from the project's .tenex directory
⋮----
// Find and remove servers with this event ID
⋮----
// Save updated config
</file>

<file path="src/services/ProjectContext.ts">
import type { AgentInstance } from "@/agents/types";
import type { NDKAgentLesson } from "@/events/NDKAgentLesson";
import type { ConversationManager } from "@/conversations/ConversationManager";
import { logger } from "@/utils/logger";
import type { Hexpubkey, NDKProject } from "@nostr-dev-kit/ndk";
import type { NDKPrivateKeySigner } from "@nostr-dev-kit/ndk";
⋮----
/**
 * ProjectContext provides system-wide access to loaded project and agents
 * Initialized during "tenex project run" by ProjectManager
 */
export class ProjectContext
⋮----
/**
     * Event that represents this project, note that this is SIGNED
     * by the USER, so this.project.pubkey is NOT the project's pubkey but the
     * USER OWNER'S pubkey.
     *
     * - projectCtx.pubkey = The project agent's pubkey (the bot/system)
     * - projectCtx.project.pubkey = The user's pubkey (who created the project)
     */
⋮----
/**
     * Signer the project uses (hardwired to project manager's signer)
     */
⋮----
/**
     * Pubkey of the project (PM's pubkey)
     */
⋮----
/**
     * The project manager agent for this project
     */
⋮----
/**
     * Lessons learned by agents in this project
     * Key: agent pubkey, Value: array of lessons (limited to most recent 50 per agent)
     */
⋮----
/**
     * Conversation manager for the project (optional, initialized when needed)
     */
⋮----
constructor(project: NDKProject, agents: Map<string, AgentInstance>)
⋮----
// Debug logging
⋮----
// Find the project manager agent
⋮----
// Hardwire to project manager's signer and pubkey
⋮----
// =====================================================================================
// AGENT ACCESS HELPERS
// =====================================================================================
⋮----
getAgent(slug: string): AgentInstance | undefined
⋮----
getAgentByPubkey(pubkey: Hexpubkey): AgentInstance | undefined
⋮----
// Find the agent dynamically
⋮----
getProjectAgent(): AgentInstance
⋮----
// Returns the project manager agent
⋮----
getAgentSlugs(): string[]
⋮----
hasAgent(slug: string): boolean
⋮----
// =====================================================================================
// LESSON MANAGEMENT
// =====================================================================================
⋮----
/**
     * Add a lesson for an agent, maintaining the 50-lesson limit per agent
     */
addLesson(agentPubkey: string, lesson: NDKAgentLesson): void
⋮----
// Add the new lesson at the beginning (most recent first)
⋮----
// Keep only the most recent 50 lessons
⋮----
/**
     * Get lessons for a specific agent
     */
getLessonsForAgent(agentPubkey: string): NDKAgentLesson[]
⋮----
/**
     * Get all lessons across all agents
     */
getAllLessons(): NDKAgentLesson[]
⋮----
/**
     * Safely update project data without creating a new instance.
     * This ensures all parts of the system work with consistent state.
     */
updateProjectData(newProject: NDKProject, newAgents: Map<string, AgentInstance>): void
⋮----
// Update project manager reference if it exists in new agents
⋮----
// Module-level variable for global access
⋮----
/**
 * Initialize the project context. Should be called once during project startup.
 */
export function setProjectContext(project: NDKProject, agents: Map<string, AgentInstance>): void
⋮----
/**
 * Get the initialized project context
 * @throws Error if not initialized
 */
export function getProjectContext(): ProjectContext
⋮----
/**
 * Check if project context is initialized
 */
export function isProjectContextInitialized(): boolean
</file>

<file path="src/test-utils/mock-llm/types.ts">
import type { ToolCall } from "@/llm/types";
⋮----
export interface MockLLMResponse {
    /** The messages that should trigger this response */
    trigger: {
        /** Match system prompt content */
        systemPrompt?: string | RegExp;
        /** Match user message content */
        userMessage?: string | RegExp;
        /** Match specific tool calls in the conversation */
        previousToolCalls?: string[];
        /** Match agent name */
        agentName?: string | RegExp;
        /** Match conversation phase */
        phase?: string;
        /** Match if message contains text */
        messageContains?: string | RegExp;
        /** Which iteration for this agent (1st, 2nd, etc) */
        iterationCount?: number;
        /** Who called continue last */
        previousAgent?: string;
        /** Respond differently after specific agent */
        afterAgent?: string;
        /** Match when continue tool specifies a phase */
        continueToPhase?: string;
    };
    /** The response to return when triggered */
    response: {
        /** Text content of the response */
        content?: string;
        /** Tool calls to make */
        toolCalls?: ToolCall[];
        /** Simulate streaming delay in ms */
        streamDelay?: number;
        /** Simulate an error */
        error?: Error;
    };
    /** Priority for matching (higher = checked first) */
    priority?: number;
}
⋮----
/** The messages that should trigger this response */
⋮----
/** Match system prompt content */
⋮----
/** Match user message content */
⋮----
/** Match specific tool calls in the conversation */
⋮----
/** Match agent name */
⋮----
/** Match conversation phase */
⋮----
/** Match if message contains text */
⋮----
/** Which iteration for this agent (1st, 2nd, etc) */
⋮----
/** Who called continue last */
⋮----
/** Respond differently after specific agent */
⋮----
/** Match when continue tool specifies a phase */
⋮----
/** The response to return when triggered */
⋮----
/** Text content of the response */
⋮----
/** Tool calls to make */
⋮----
/** Simulate streaming delay in ms */
⋮----
/** Simulate an error */
⋮----
/** Priority for matching (higher = checked first) */
⋮----
export interface MockLLMScenario {
    name: string;
    description: string;
    responses: MockLLMResponse[];
}
⋮----
export interface MockLLMConfig {
    /** Default response if no triggers match */
    defaultResponse?: MockLLMResponse['response'];
    /** Log all requests for debugging */
    debug?: boolean;
    /** Scenarios to load */
    scenarios?: MockLLMScenario[];
}
⋮----
/** Default response if no triggers match */
⋮----
/** Log all requests for debugging */
⋮----
/** Scenarios to load */
</file>

<file path="src/test-utils/e2e-conversational-setup.ts">
import { conversationalLogger } from "./conversational-logger";
⋮----
/**
 * Global setup for E2E tests to enable conversational logging when DEBUG=true
 * This can be imported and used to automatically enable conversational output
 * without modifying individual test files.
 */
export function setupConversationalLogging(): void
⋮----
// Log a banner for the test session
⋮----
/**
 * Helper to wrap test execution with conversational logging
 */
export function withConversationalLogging<T>(testName: string, testFn: () => Promise<T>): Promise<T>
⋮----
/**
 * Auto-enable conversational logging if DEBUG is set
 * Can be imported at the top of test files to automatically enable
 */
</file>

<file path="src/tools/implementations/agents-hire.ts">
import type { Tool, ExecutionContext, Result, ToolError, Validated } from "@/tools/types";
import { createZodSchema, success, failure } from "@/tools/types";
import { AgentRegistry } from "@/agents/AgentRegistry";
import { fetchAgentDefinition } from "@/utils/agentFetcher";
import { getNDK } from "@/nostr";
import { getProjectContext } from "@/services/ProjectContext";
import { logger } from "@/utils/logger";
import { z } from "zod";
⋮----
// Define the input schema
⋮----
type AgentsHireInput = z.infer<typeof agentsHireSchema>;
⋮----
// Define the output type
interface AgentsHireOutput {
    success: boolean;
    message?: string;
    error?: string;
    agent?: {
        slug: string;
        name: string;
        role?: string;
        pubkey: string;
        eventId?: string;
    };
}
⋮----
/**
 * Tool: agents_hire
 * Hire (add) an NDKAgentDefinition from the Nostr network to the project
 */
⋮----
// Fetch the NDKAgentDefinition from the network
⋮----
// Generate slug from name if not provided
⋮----
// Get project context and registry
⋮----
// Check if agent already exists
⋮----
// Create agent configuration from NDKAgentDefinition definition
⋮----
eventId: eventId, // Link to the original NDKAgentDefinition event
⋮----
// Add the agent to the project
</file>

<file path="src/tools/implementations/lessonGet.ts">
import { NDKAgentLesson } from "@/events/NDKAgentLesson";
import { getNDK } from "@/nostr";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { z } from "zod";
import type { Tool } from "../types";
import { createZodSchema } from "../types";
import type { NDKFilter } from "@nostr-dev-kit/ndk";
⋮----
interface LessonGetInput {
    title: string;
}
⋮----
interface LessonGetOutput {
    title: string;
    lesson: string;
    detailed?: string;
    category?: string;
    hashtags?: string[];
    hasDetailed: boolean;
}
⋮----
// Build filter to find lessons by title for this agent
⋮----
// Add agent filter if we have the agent's event ID
⋮----
// Fetch matching lessons
⋮----
// Get the most recent lesson if multiple matches
</file>

<file path="src/tools/implementations/shell.ts">
import type { Tool } from "../types";
import { success, failure, createZodSchema } from "../types";
import { z } from "zod";
import { exec } from "child_process";
import { promisify } from "util";
import { ExecutionConfig } from "@/agents/execution/constants";
import { PROJECT_MANAGER_AGENT } from "@/agents/constants";
import { logger } from "@/utils/logger";
⋮----
/**
 * Shell tool - allows agents to execute shell commands
 * Restricted to project-manager agent for safety
 */
⋮----
// Safety check - only project-manager can use this tool
⋮----
// Ensure safe environment
</file>

<file path="src/utils/agentFetcher.ts">
import type NDK from "@nostr-dev-kit/ndk";
import { logger } from "./logger";
⋮----
/**
 * Fetches an agent definition from a Nostr event
 * @param eventId - The ID of the event containing the agent definition
 * @param ndk - The NDK instance to use for fetching
 * @returns The agent definition or null if not found
 */
export async function fetchAgentDefinition(
    eventId: string,
    ndk: NDK
): Promise<
</file>

<file path="src/utils/cli-error.ts">
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "./logger";
⋮----
/**
 * Centralized CLI error handler that ensures consistent error logging and exit behavior
 * @param error - The error object or message
 * @param context - Optional context for better error reporting
 * @param exitCode - The process exit code (default: 1)
 */
export function handleCliError(
    error: unknown,
    context?: string,
    exitCode = 1
): never
⋮----
// Log error with context
⋮----
// Log stack trace in debug mode
⋮----
// Exit with specified code
⋮----
/**
 * Handle CLI warnings without exiting
 * @param message - The warning message
 * @param context - Optional context for the warning
 */
export function handleCliWarning(message: string, context?: string): void
</file>

<file path="src/utils/inventory.ts">
import { formatAnyError } from "@/utils/error-formatter";
⋮----
import { loadLLMRouter } from "@/llm";
import { TaskPublisher, getNDK } from "@/nostr";
import { PromptBuilder } from "@/prompts/core/PromptBuilder";
import { configService, getProjectContext, isProjectContextInitialized } from "@/services";
import { logger } from "@/utils/logger";
import type { NDKTask } from "@nostr-dev-kit/ndk";
import { Message } from "multi-llm-ts";
import { generateRepomixOutput } from "./repomix.js";
import "@/prompts"; // This ensures all fragments are registered
import type { AgentInstance } from "@/agents/types";
⋮----
interface ComplexModule {
    name: string;
    path: string;
    reason: string;
    suggestedFilename: string;
}
⋮----
interface ComplexModulesResponse {
    complexModules: ComplexModule[];
}
⋮----
interface InventoryResult {
    content: string;
    complexModules: ComplexModule[];
}
⋮----
interface InventoryGenerationOptions {
    conversationRootEventId?: string;
    agent?: AgentInstance;
    focusFiles?: Array<{ path: string; status: string }>;
}
⋮----
/**
 * Generate comprehensive inventory using repomix + LLM
 */
export async function generateInventory(
    projectPath: string,
    options?: InventoryGenerationOptions
): Promise<void>
⋮----
// Ensure context directory exists
⋮----
// Create NDK task if context is available
⋮----
// Initial status update
⋮----
// Step 1: Generate repomix content once for efficiency
⋮----
// Step 2: Generate main inventory with complex module identification
⋮----
// Step 3: Save main inventory
⋮----
// Progress tracking handled by TaskPublisher
⋮----
// Step 4: Generate individual module guides for complex modules (max MAX_COMPLEX_MODULES)
⋮----
if (!module) continue; // Skip if module is undefined
⋮----
// TypeScript now knows module is defined
⋮----
// Progress tracking handled by TaskPublisher
⋮----
// Final completion update
⋮----
// Task completion handled by TaskPublisher
⋮----
/**
 * Generate main inventory and identify complex modules
 */
async function generateMainInventory(
    projectPath: string,
    repomixContent: string,
    focusFiles?: Array<{ path: string; status: string }>
): Promise<InventoryResult>
⋮----
// Use PromptBuilder to construct the prompt from fragments
⋮----
// Debug: Log the router configuration
⋮----
// Extract complex modules from JSON at the end
⋮----
// Strip the complexModules JSON block from the content before saving
⋮----
/**
 * Generate detailed guide for a specific complex module
 */
async function generateModuleGuide(
    projectPath: string,
    module: ComplexModule,
    repomixContent: string
): Promise<void>
⋮----
// Use PromptBuilder to construct the prompt from fragments
⋮----
// Save module guide
⋮----
/**
 * Strip the complexModules JSON block from the inventory content
 */
function stripComplexModulesJson(content: string): string
⋮----
// Remove the entire complex modules JSON section
⋮----
// Also handle case where JSON block might appear without the instruction text
⋮----
/**
 * Type guard to validate complex modules response structure
 */
function isComplexModulesResponse(data: unknown): data is ComplexModulesResponse
⋮----
/**
 * Parse JSON from content and validate it
 */
function parseComplexModulesJson(jsonString: string): ComplexModule[] | null
⋮----
/**
 * Extract complex modules from LLM response with fallback mechanism
 */
async function extractComplexModules(
    content: string,
    projectPath?: string
): Promise<ComplexModule[]>
⋮----
// Look for JSON block at the end
⋮----
/**
 * Fallback mechanism for JSON extraction using a cleanup LLM call
 */
async function fallbackExtractComplexModules(
    content: string,
    projectPath?: string
): Promise<ComplexModule[]>
⋮----
// Use PromptBuilder to construct the prompt from fragments
⋮----
/**
 * Update inventory for specific files (placeholder for future implementation)
 */
export async function updateInventory(projectPath: string, files: string[]): Promise<void>
⋮----
// For now, just regenerate the full inventory
// Future optimization: implement partial updates
⋮----
/**
 * Check if inventory exists
 */
export async function inventoryExists(projectPath: string): Promise<boolean>
⋮----
/**
 * Load inventory content for system prompts
 */
export async function loadInventoryContent(projectPath: string): Promise<string | null>
⋮----
/**
 * Get the inventory file path
 */
async function getInventoryPath(projectPath: string): Promise<string>
⋮----
/**
 * Load project configuration
 */
async function loadProjectConfig(
    projectPath: string
): Promise<
⋮----
// Get config from ProjectContext if available
⋮----
// Fallback: try to load config directly
</file>

<file path="src/utils/lessonFormatter.ts">
import type { NDKAgentLesson } from "@/events/NDKAgentLesson";
import { logger } from "@/utils/logger";
⋮----
/**
 * Format agent lessons into a concise string without using LLM
 * This is a simple concatenation with minimal formatting
 */
export function formatLessonsForAgent(lessons: NDKAgentLesson[]): string
⋮----
// Sort by creation time (newest first)
⋮----
// Take up to 50 lessons (should already be limited by ProjectContext)
⋮----
// Format each lesson concisely
⋮----
// Build metadata line
⋮----
// Create a concise format for each lesson
⋮----
// Add header for context
</file>

<file path="src/utils/logger.ts">
import chalk from "chalk";
⋮----
/**
 * TENEX Logging System
 *
 * Environment Variables:
 * - LOG_LEVEL: Sets default verbosity (silent|normal|verbose|debug)
 * - TENEX_LOG: Enable specific modules with optional verbosity
 *   Format: module1:level,module2:level
 *   Example: TENEX_LOG=agent:debug,llm:verbose,tools
 *   If no level specified, defaults to debug
 *
 * Available modules:
 * - agent: Agent execution and behavior
 * - conversation: Conversation management
 * - llm: LLM interactions
 * - nostr: Nostr protocol operations
 * - tools: Tool execution
 * - general: General/miscellaneous logging
 *
 * Tracing (execution flow debugging) is only enabled for modules
 * with verbose or debug verbosity levels.
 */
⋮----
export type VerbosityLevel = "silent" | "normal" | "verbose" | "debug";
⋮----
export type LogModule = "agent" | "conversation" | "llm" | "nostr" | "tools" | "general";
⋮----
export interface ModuleVerbosityConfig {
    default: VerbosityLevel;
    modules?: {
        [moduleName: string]: VerbosityLevel;
    };
}
⋮----
export interface LoggerConfig {
    useEmoji?: boolean;
    useLabels?: boolean;
    debugEnabled?: boolean;
    moduleVerbosity?: ModuleVerbosityConfig;
}
⋮----
export function parseModuleVerbosity(): ModuleVerbosityConfig
⋮----
// Only try to parse environment variables in Node.js environment
⋮----
// Set default level from environment
⋮----
// Parse TENEX_LOG environment variable
// Format: TENEX_LOG=module1:level,module2:level
// Example: TENEX_LOG=agent:debug,llm:verbose,tools:debug
// If no level specified, defaults to debug
// Example: TENEX_LOG=agent,llm,tools (all set to debug)
⋮----
export function configureLogger(config: Partial<LoggerConfig>): void
⋮----
// Agent color assignment for consistent coloring
⋮----
function getAgentColor(agentName: string): typeof chalk.red
⋮----
function shouldLog(
    level: string,
    module?: LogModule,
    verbosityRequired: VerbosityLevel = "normal"
): boolean
⋮----
// Always show errors and warnings
⋮----
// Debug logs respect the debug flag
⋮----
// Get module-specific verbosity
⋮----
function formatModulePrefix(module?: LogModule): string
⋮----
type LogLevel = "error" | "info" | "success" | "warning" | "debug";
⋮----
interface LogConfig {
    emoji: string;
    label: string;
    color: typeof chalk.red;
    consoleFn: typeof console.log;
}
⋮----
function formatLogMessage(
    level: LogLevel,
    message: string,
    module?: LogModule
): string
⋮----
export function logError(message: string, error?: unknown, module?: LogModule): void
⋮----
export function logInfo(
    message: string,
    module?: LogModule,
    verbosity: VerbosityLevel = "normal",
    ...args: unknown[]
): void
⋮----
export function logSuccess(
    message: string,
    module?: LogModule,
    verbosity: VerbosityLevel = "normal"
): void
⋮----
export function logWarning(
    message: string,
    module?: LogModule,
    verbosity: VerbosityLevel = "normal",
    ...args: unknown[]
): void
⋮----
export function logDebug(
    message: string,
    module?: LogModule,
    verbosity: VerbosityLevel = "debug",
    ...args: unknown[]
): void
⋮----
// Agent Logger class for contextual logging
export class AgentLogger
⋮----
constructor(agentName: string, projectTitle?: string)
⋮----
setModule(module: LogModule): void
⋮----
private formatMessage(
        emoji: string,
        message: string,
        colorFn: typeof chalk.red,
        verbosity: VerbosityLevel
): string
⋮----
info(message: string, verbosity: VerbosityLevel = "normal", ...args: unknown[]): void
⋮----
success(message: string, verbosity: VerbosityLevel = "normal", ...args: unknown[]): void
⋮----
warning(message: string, verbosity: VerbosityLevel = "normal", ...args: unknown[]): void
⋮----
error(message: string, error?: unknown): void
⋮----
// Errors always show
⋮----
debug(message: string, verbosity: VerbosityLevel = "debug", ...args: unknown[]): void
⋮----
// Factory function for creating agent loggers
export function createAgentLogger(agentName: string, projectTitle?: string): AgentLogger
⋮----
// Scoped logger for easier module-specific logging
export class ScopedLogger
⋮----
constructor(private module: LogModule)
⋮----
success(message: string, verbosity: VerbosityLevel = "normal"): void
⋮----
// Conversation flow logging functions
function truncateText(text: string, maxLength = 100): string
⋮----
function formatConversationHeader(conversationId?: string, title?: string): string
⋮----
// Human-readable conversation flow logging
export function logConversationStart(
    userMessage: string,
    conversationId?: string,
    title?: string,
    eventId?: string
): void
⋮----
export function logLLMInteraction(
    type: string,
    config: {
        model?: string;
        systemPrompt?: string;
        userPrompt?: string;
        response?: string;
        reasoning?: string;
    },
    conversationId?: string,
    title?: string
): void
⋮----
const maxLength = 500; // Configurable via env var in future
⋮----
export function logPhaseTransition(
    from: string,
    to: string,
    reason?: string,
    conversationId?: string,
    title?: string
): void
⋮----
export function logUserMessage(
    message: string,
    conversationId?: string,
    title?: string,
    eventId?: string
): void
⋮----
export function logAgentResponse(
    agentName: string,
    message: string,
    conversationId?: string,
    title?: string,
    eventId?: string
): void
⋮----
export function logConversationError(
    error: string,
    context?: Record<string, unknown>,
    conversationId?: string,
    title?: string
): void
⋮----
// Main logger interface
⋮----
// Conversation flow logging
</file>

<file path="src/utils/projectInitialization.ts">
import { ProjectManager } from "@/daemon/ProjectManager";
import { getNDK, initNDK } from "@/nostr/ndkClient";
import { isProjectContextInitialized } from "@/services";
import { logger } from "@/utils/logger";
import { handleCliError } from "@/utils/cli-error";
⋮----
/**
 * Initialize project context if not already initialized
 * This includes NDK setup and ProjectManager initialization
 *
 * Used by commands that need full project context:
 * - tenex project run
 * - tenex debug chat
 * - tenex debug system-prompt
 * - tenex inventory generate
 */
export async function ensureProjectInitialized(projectPath: string): Promise<void>
⋮----
// Step 1: Initialize NDK connection
⋮----
// Step 2: Initialize ProjectContext using ProjectManager
⋮----
// Check if this is a missing project configuration error
</file>

<file path="src/utils/relays.ts">
/**
 * Default Nostr relay URLs for TENEX
 */
⋮----
/**
 * Validate WebSocket URL format
 * @param url - URL to validate
 * @returns true if URL is valid WebSocket URL
 */
function isValidWebSocketUrl(url: string): boolean
⋮----
/**
 * Get relay URLs for NDK connection
 * @returns Array of validated WebSocket relay URLs
 */
export function getRelayUrls(): string[]
⋮----
// If after filtering we have no valid URLs, return defaults
</file>

<file path="tests/e2e/test-harness.ts">
import { mock, expect } from "bun:test";
import path from "node:path";
import { 
    createTempDir, 
    cleanupTempDir, 
    createMockLLMService,
    createMockNDKEvent,
    type MockLLMService
} from "@/test-utils";
import { TestPersistenceAdapter } from "@/test-utils/test-persistence-adapter";
import { ConversationManager } from "@/conversations/ConversationManager";
import { AgentRegistry } from "@/agents/AgentRegistry";
import type { ToolCall } from "@/llm/types";
import { Message } from "multi-llm-ts";
import { ConfigService } from "@/services/ConfigService";
import { EVENT_KINDS } from "@/llm/types";
⋮----
export interface E2ETestContext {
    projectPath: string;
    tempDir: string;
    mockLLM: MockLLMService;
    conversationManager: ConversationManager;
    agentRegistry: AgentRegistry;
    configService: typeof ConfigService;
    services: {
        configService: typeof ConfigService;
        projectContext: any;
    };
    projectConfig: any;
}
⋮----
// Execution trace for tracking conversation flow
export interface ExecutionTrace {
    conversationId: string;
    executions: AgentExecutionRecord[];
    phaseTransitions: PhaseTransitionRecord[];
    toolCalls: ToolCallRecord[];
    routingDecisions: RoutingDecisionRecord[];
}
⋮----
export interface AgentExecutionRecord {
    agent: string;
    phase: string;
    timestamp: Date;
    message?: string;
    toolCalls?: any[];
}
⋮----
export interface PhaseTransitionRecord {
    from: string;
    to: string;
    agent: string;
    reason: string;
    timestamp: Date;
}
⋮----
export interface ToolCallRecord {
    agent: string;
    tool: string;
    arguments: any;
    timestamp: Date;
}
⋮----
export interface RoutingDecisionRecord {
    fromAgent: string;
    toAgents: string[];
    phase: string;
    reason: string;
    timestamp: Date;
}
⋮----
/**
 * Setup E2E test environment
 */
export async function setupE2ETest(scenarios: string[] = [], defaultResponse?: any): Promise<E2ETestContext>
⋮----
// Create temp directory
⋮----
// Mock file system
⋮----
// Initialize mock LLM
⋮----
// Mock LLM router
⋮----
constructor()
getService()
validateModel()
⋮----
// Mock Nostr publisher
⋮----
async publishResponse()
async publishError()
async publishTypingIndicator()
async stopTypingIndicator()
⋮----
// Mock AgentPublisher to prevent publishing during tests
⋮----
async publishProfile()
async publishEvents()
async publishAgentCreation()
⋮----
// Mock ClaudeBackend to prevent launching actual Claude Code process
⋮----
async execute(messages: any[], tools: any[], context: any, publisher: any)
⋮----
// Use the mock LLM instead of launching Claude Code
⋮----
// Simulate Claude Code execution
// 1. Publish the response content
⋮----
// 2. Handle tool calls if present
⋮----
// For complete tool, call the completion handler
⋮----
// Add other tools as needed
⋮----
// Mock logging
⋮----
logToolCall()
logToolResult()
logStream()
logComplete()
logError()
logEvent()
routingDecision()
agentThinking()
⋮----
// Mock tracing
⋮----
getRequest()
getConversation()
getAgent()
addConversation()
addAgent()
removeAgent()
⋮----
// Create test agent
⋮----
// Mock project context to avoid complex initialization
⋮----
getLessonsForAgent: () => []  // Add missing method
⋮----
// Initialize services with test persistence adapter
⋮----
// Ensure built-in agents are loaded
⋮----
// Get orchestrator for testing
⋮----
// Store mockLLM in global context for ClaudeBackend mock
// Removed unnecessary global storage - mockLLM is already accessible via context
⋮----
/**
 * Cleanup E2E test environment
 */
export async function cleanupE2ETest(context: E2ETestContext | undefined): Promise<void>
⋮----
/**
 * Create a mock publisher for testing
 */
function createMockPublisher()
⋮----
/**
 * Create a conversation from a user message
 */
export async function createConversation(
    context: E2ETestContext,
    title: string,
    content: string,
    tags: string[][] = []
): Promise<string>
⋮----
/**
 * Helper to get conversation state
 */
export async function getConversationState(
    context: E2ETestContext,
    conversationId: string
)
⋮----
/**
 * Wait for a specific phase
 */
export async function waitForPhase(
    context: E2ETestContext,
    conversationId: string,
    expectedPhase: string,
    timeout = 5000
): Promise<void>
⋮----
/**
 * Extract tool calls from mock LLM history
 */
export function getToolCallsFromHistory(mockLLM: MockLLMService): string[]
⋮----
/**
 * Custom assertions for E2E tests
 */
⋮----
toHavePhaseTransition(
        transitions: any[],
        from: string,
        to: string
): void
⋮----
toHaveToolCallSequence(
        mockLLM: MockLLMService,
        expectedSequence: string[]
): void
⋮----
// Check if expected sequence appears in order (not necessarily consecutive)
⋮----
return; // Found complete sequence
⋮----
/**
 * Execute a complete conversation flow, automatically following orchestrator routing
 */
export async function executeConversationFlow(
    context: E2ETestContext,
    conversationId: string,
    initialMessage: string,
    options?: {
        maxIterations?: number;
onAgentExecution?: (agent: string, phase: string)
⋮----
// Track conversation state
⋮----
// Get current conversation state
⋮----
// Always execute orchestrator for routing
⋮----
// Record orchestrator execution
⋮----
// Extract routing decision from orchestrator response
⋮----
// No routing decision means conversation is complete
⋮----
// Record routing decision
⋮----
// Update conversation phase if specified in routing decision
⋮----
// Execute each target agent
⋮----
// Conversation complete
⋮----
// Notify callback
⋮----
// Execute target agent
⋮----
"" // No message, agent gets context from conversation
⋮----
// Record agent execution
⋮----
// Record tool calls
⋮----
// Handle different tool call structures
⋮----
// Standard OpenAI-style structure
⋮----
// Simplified structure from our mock
⋮----
// Check for continue tool - means we need to go back to orchestrator
⋮----
// Update mock LLM context for next iteration
⋮----
// Set the last agent executed for routing context
⋮----
// Update mock LLM context for next iteration
⋮----
// End conversation in specific scenarios:
// 1. If orchestrator called complete (explicit end)
// 2. If project-manager completed verification phase (workflow complete)
// 3. If project-manager completed plan phase (plan review complete)
⋮----
// Check for phase transitions
⋮----
interface AgentExecutionResult {
    message: string;
    toolCalls: ToolCall[];
}
⋮----
/**
 * Execute agent and return result (internal helper)
 */
async function executeAgentWithResult(
    context: E2ETestContext,
    agentName: string,
    conversationId: string,
    userMessage: string
): Promise<AgentExecutionResult>
⋮----
// Try both the provided name and lowercase version
⋮----
// Use appropriate backend based on agent
⋮----
// For orchestrator, we need to get the routing decision without executing agents
// Build a simple orchestrator message
⋮----
// Add user message if provided
⋮----
// Use the mock LLM directly to get routing decision
⋮----
// Stream the response
⋮----
// Execute non-orchestrator agents directly with mock LLM
// Build simple agent messages
⋮----
// Get response from mock LLM
⋮----
// Stream the response
⋮----
// Process tool calls
⋮----
// Result is already logged by the conversational logger in MockLLMService
⋮----
interface RoutingDecision {
    agents: string[];
    phase?: string;
    reason: string;
}
⋮----
/**
 * Extract routing decision from orchestrator response
 */
function extractRoutingDecision(orchestratorResult: AgentExecutionResult): RoutingDecision | null
⋮----
// Orchestrator with routing backend returns JSON
⋮----
// Try to parse as JSON
⋮----
// Not a routing decision
⋮----
// Assertion helpers for traces
export function assertAgentSequence(trace: ExecutionTrace, ...expectedAgents: string[])
⋮----
export function assertPhaseTransitions(trace: ExecutionTrace, ...expectedPhases: string[])
⋮----
export function assertToolCalls(trace: ExecutionTrace, agent: string, ...expectedTools: string[])
⋮----
export function assertFeedbackPropagated(trace: ExecutionTrace, fromAgent: string, toAgent: string, keyword: string): boolean
⋮----
// Find message from fromAgent
⋮----
// Find subsequent execution of toAgent
</file>

<file path="src/agents/execution/__tests__/AgentExecutor.test.ts">
import { describe, it, expect, beforeEach, afterEach, mock } from "bun:test";
import { AgentExecutor } from "../AgentExecutor";
import { createMockLLMService, MockFactory } from "@/test-utils";
import type { ExecutionContext } from "../types";
import type { AgentInstance } from "@/agents/types";
import { Message } from "multi-llm-ts";
import type { ConversationManager } from "@/conversations/ConversationManager";
import { NDK } from "@nostr-dev-kit/ndk";
⋮----
// Mock required modules
⋮----
constructor()
async publishTypingIndicator()
async publishResponse()
cleanup()
⋮----
// Create mock LLM service
⋮----
// Create mock NDK
⋮----
// Create mock conversation manager
⋮----
// Create mock agent
⋮----
// Create mock publisher
⋮----
// Create mock execution context
⋮----
// Error handled in mock
⋮----
// Mock the backend modules
⋮----
async execute(messages: Message[], tools: any[], context: ExecutionContext)
⋮----
// Update agent to use reason-act backend
⋮----
// Mock the backend modules
⋮----
// Update agent to use routing backend
⋮----
// Mock required modules
⋮----
constructor(private llm: any, private conversationManager: any)
⋮----
// Mock backend to throw error
⋮----
async execute()
⋮----
expect(true).toBe(false); // Should not reach here
⋮----
// AgentExecutor no longer calls onError - it just rethrows
⋮----
// Update agent with unknown backend
⋮----
// Mock ReasonActLoop for unknown backend (defaults to reason-act-loop)
⋮----
// Should use default backend successfully
⋮----
// Mock tool registry
⋮----
// Mock backend that checks tools
</file>

<file path="src/agents/AgentPublisher.ts">
import type { AgentConfig } from "@/agents/types";
import { EVENT_KINDS } from "@/llm";
import { logger } from "@/utils/logger";
import type NDK from "@nostr-dev-kit/ndk";
import { NDKEvent, type NDKPrivateKeySigner, type NDKProject } from "@nostr-dev-kit/ndk";
⋮----
/**
 * Service for publishing agent-related Nostr events
 */
export class AgentPublisher
⋮----
constructor(private ndk: NDK)
⋮----
/**
     * Publishes a kind:0 profile event for an agent
     */
async publishAgentProfile(
        signer: NDKPrivateKeySigner,
        agentName: string,
        agentRole: string,
        projectTitle: string,
        projectEvent: NDKProject,
        agentDefinitionEventId?: string
): Promise<void>
⋮----
// Generate random dicebear avatar
const avatarStyle = "bottts"; // Using bottts style for agents
const seed = signer.pubkey; // Use pubkey as seed for consistent avatar
⋮----
// Properly tag the project event (creates an "a" tag for kind:31933)
⋮----
// Add e-tag for the agent definition event if it exists
⋮----
/**
     * Publishes an agent request event
     */
async publishAgentRequest(
        signer: NDKPrivateKeySigner,
        agentConfig: Omit<AgentConfig, "nsec">,
        projectEvent: NDKProject,
        ndkAgentEventId?: string
): Promise<NDKEvent>
⋮----
// Properly tag the project event
⋮----
// Only add e-tag if this agent was created from an NDKAgentDefinition event
⋮----
// Add agent metadata tags
⋮----
// Add the other tags
⋮----
/**
     * Publishes all agent-related events when creating a new agent
     */
async publishAgentCreation(
        signer: NDKPrivateKeySigner,
        agentConfig: Omit<AgentConfig, "nsec">,
        projectTitle: string,
        projectEvent: NDKProject,
        ndkAgentEventId?: string
): Promise<void>
⋮----
// Publish profile event
⋮----
// Publish request event
</file>

<file path="src/agents/types.ts">
import type { Tool } from "@/tools/types";
import type { NDKPrivateKeySigner } from "@nostr-dev-kit/ndk";
⋮----
/**
 * Simplified agent representation for UI display and selection
 */
export interface AgentSummary {
    /** Display name of the agent */
    name: string;
    /** Primary role/function of the agent */
    role: string;
    /** Nostr public key for agent identity */
    pubkey: string;
}
⋮----
/** Display name of the agent */
⋮----
/** Primary role/function of the agent */
⋮----
/** Nostr public key for agent identity */
⋮----
/**
 * Complete agent configuration and identity
 */
export interface AgentInstance {
    /** Display name of the agent */
    name: string;
    /** Nostr public key for agent identity */
    pubkey: string;
    /** Cryptographic signer for Nostr events */
    signer: NDKPrivateKeySigner;
    /** Primary role/function of the agent */
    role: string;
    /** Agent description from NDKAgentDefinition event */
    description?: string;
    /** System instructions that guide agent behavior */
    instructions?: string;
    /** Criteria for when this agent should be selected by orchestrator */
    useCriteria?: string;
    /** LLM configuration identifier */
    llmConfig: string;
    /** Tool instances available to this agent */
    tools: Tool[];
    /** Whether this agent has access to MCP tools (defaults to true except for orchestrator) */
    mcp?: boolean;
    /** NDKAgentDefinition event ID for persisted configuration */
    eventId?: string;
    /** Agent slug/key from agents.json configuration */
    slug: string;
    /** Whether this is a built-in agent (executor, planner, project-manager) */
    isBuiltIn?: boolean;
    /** Whether this agent is from the global configuration */
    isGlobal?: boolean;
}
⋮----
/** Display name of the agent */
⋮----
/** Nostr public key for agent identity */
⋮----
/** Cryptographic signer for Nostr events */
⋮----
/** Primary role/function of the agent */
⋮----
/** Agent description from NDKAgentDefinition event */
⋮----
/** System instructions that guide agent behavior */
⋮----
/** Criteria for when this agent should be selected by orchestrator */
⋮----
/** LLM configuration identifier */
⋮----
/** Tool instances available to this agent */
⋮----
/** Whether this agent has access to MCP tools (defaults to true except for orchestrator) */
⋮----
/** NDKAgentDefinition event ID for persisted configuration */
⋮----
/** Agent slug/key from agents.json configuration */
⋮----
/** Whether this is a built-in agent (executor, planner, project-manager) */
⋮----
/** Whether this agent is from the global configuration */
⋮----
/**
 * Arguments passed to tool functions during execution
 */
export interface ToolCallArguments {
    /** Shell command to execute (for shell tools) */
    command?: string;
    /** File system path (for file tools) */
    path?: string;
    /** Operation mode (for claude_code tool) */
    mode?: string;
    /** User prompt or query (for claude_code tool) */
    prompt?: string;

    /** Allow additional tool-specific arguments */
    [key: string]: string | number | boolean | undefined;
}
⋮----
/** Shell command to execute (for shell tools) */
⋮----
/** File system path (for file tools) */
⋮----
/** Operation mode (for claude_code tool) */
⋮----
/** User prompt or query (for claude_code tool) */
⋮----
/** Allow additional tool-specific arguments */
⋮----
/**
 * Represents a tool invocation request
 */
export interface ToolCall {
    /** Name/identifier of the tool to call */
    tool: string;
    /** Arguments to pass to the tool */
    args: ToolCallArguments;
    /** Optional unique identifier for tracking */
    id?: string;
}
⋮----
/** Name/identifier of the tool to call */
⋮----
/** Arguments to pass to the tool */
⋮----
/** Optional unique identifier for tracking */
⋮----
/**
 * Configuration load options
 */
export interface ConfigurationLoadOptions {
    skipGlobal?: boolean;
}
⋮----
/**
 * Agent data stored in JSON files (.tenex/agents/*.json)
 */
export interface StoredAgentData {
    name: string;
    role: string;
    description?: string;
    instructions?: string;
    useCriteria?: string;
    llmConfig?: string;
    tools?: string[]; // Tool names in storage - converted to Tool instances at runtime
    mcp?: boolean; // Whether this agent has access to MCP tools
}
⋮----
tools?: string[]; // Tool names in storage - converted to Tool instances at runtime
mcp?: boolean; // Whether this agent has access to MCP tools
⋮----
/**
 * Agent configuration including sensitive data from registry
 */
export interface AgentConfig extends StoredAgentData {
    nsec: string; // Private key from agents.json registry
    eventId?: string; // NDKAgentDefinition event ID if created from Nostr event
    pubkey?: string; // Public key derived from nsec
}
⋮----
nsec: string; // Private key from agents.json registry
eventId?: string; // NDKAgentDefinition event ID if created from Nostr event
pubkey?: string; // Public key derived from nsec
⋮----
/**
 * Agent config for creation with optional nsec
 */
export interface AgentConfigOptionalNsec extends StoredAgentData {
    nsec?: string; // Optional during creation
    eventId?: string;
    pubkey?: string;
}
⋮----
nsec?: string; // Optional during creation
⋮----
/**
 * Agent configuration for orchestration system
 */
export interface AgentConfiguration {
    name: string;
    nsec: string;
    eventId?: string;
    role?: string;
}
⋮----
/**
 * Project agents configuration
 */
export interface ProjectAgentsConfig {
    agents: Record<string, AgentConfiguration>;
}
</file>

<file path="src/claude/orchestrator.ts">
import { startExecutionTime, stopExecutionTime } from "@/conversations/executionTime";
import type { Conversation } from "@/conversations/types";
import type { ConversationManager } from "@/conversations/ConversationManager";
import type { TaskPublisher } from "@/nostr/TaskPublisher";
import { logger } from "@/utils/logger";
import { formatAnyError } from "@/utils/error-formatter";
import type { ContentBlock, TextBlock } from "@anthropic-ai/sdk/resources/messages/messages";
import type { NDKTask, NDKEvent, NDKSubscription } from "@nostr-dev-kit/ndk";
import { ClaudeCodeExecutor } from "./executor";
import { getNDK } from "@/nostr/ndkClient";
import { DelayedMessageBuffer } from "./DelayedMessageBuffer";
⋮----
export interface ClaudeTaskOptions {
    prompt: string;
    systemPrompt?: string;
    projectPath: string;
    title: string;
    branch?: string;
    conversationRootEventId?: string;
    conversation?: Conversation;
    conversationManager?: ConversationManager;
    abortSignal?: AbortSignal;
    resumeSessionId?: string;
    agentName?: string;
}
⋮----
export interface ClaudeTaskResult {
    task: NDKTask;
    sessionId?: string;
    totalCost: number;
    messageCount: number;
    duration: number;
    success: boolean;
    error?: string;
    finalResponse?: string;
}
⋮----
/**
 * Orchestrates Claude Code execution with Nostr task tracking
 * Single Responsibility: Coordinate Claude SDK execution with task lifecycle and Nostr publishing
 */
export class ClaudeTaskOrchestrator
⋮----
constructor(private taskPublisher: TaskPublisher)
⋮----
async execute(options: ClaudeTaskOptions): Promise<ClaudeTaskResult>
⋮----
// Create task with conversation mapping
⋮----
// Log if we're resuming a session
⋮----
// Create message buffer for delayed publishing
⋮----
delayMs: 500, // Configurable delay
⋮----
// Publish as progress when timeout expires
⋮----
// Create executor
⋮----
// Set up abort event subscription
⋮----
// Subscribe to ephemeral abort events targeting this task
⋮----
kinds: [24133], // Ephemeral event for task abort
"#e": [task.id], // Events e-tagging this task
⋮----
// Abort the executor
⋮----
// Flush any pending message before interrupting
⋮----
// Update task status to interrupted
⋮----
// Start execution timing
⋮----
// Track the last assistant message for final response
⋮----
// Execute and stream messages
⋮----
// The value is the final ClaudeCodeResult
⋮----
// Stop timing
⋮----
// Consume buffered message if available
⋮----
// Complete task with the final message
⋮----
// Capture session ID when it becomes available
⋮----
// Process SDK message and buffer progress updates
⋮----
// Buffer the message instead of publishing immediately
⋮----
// Stop timing on error
⋮----
// Clean up message buffer
⋮----
// Check if this was an abort
⋮----
// Mark task as failed or interrupted
⋮----
// Clean up resources
⋮----
// Clean up abort subscription
</file>

<file path="src/commands/mcp/add.ts">
import { which } from "@/lib/shell";
import { configService } from "@/services/ConfigService";
import type { MCPServerConfig } from "@/services/config/types";
import { logger } from "@/utils/logger";
import { handleCliError } from "@/utils/cli-error";
import { determineConfigScope } from "@/utils/cli-config-scope";
import { isValidSlug } from "@/utils/validation";
import { Command } from "commander";
⋮----
interface AddOptions {
    project?: boolean;
    global?: boolean;
}
⋮----
interface AddOptionsWithPaths extends AddOptions {
    paths?: string;
    env?: string[];
}
⋮----
// Parse command and args from the array
⋮----
const command = commandArgs[0] as string; // Safe because we checked length above
⋮----
// Validate name
⋮----
// Validate command exists (skip for npx, npm, etc.)
⋮----
// Parse allowed paths if provided
⋮----
// Parse environment variables if provided
⋮----
// Create server config
⋮----
// Determine where to save
⋮----
// Load existing MCP config
⋮----
// Check if server name already exists
⋮----
// Add new server
⋮----
// Save config
⋮----
// Exit successfully
</file>

<file path="src/commands/queue/history.ts">
import { getProjectContext } from '@/services';
import { ensureProjectInitialized } from '@/utils/projectInitialization';
import { logger } from '@/utils/logger';
import chalk from 'chalk';
import { format } from 'date-fns';
⋮----
interface HistoryOptions {
  limit?: number;
  format?: 'table' | 'json' | 'csv';
}
⋮----
export async function showExecutionHistory(_options: HistoryOptions =
⋮----
// Initialize project context first
⋮----
// Access the queue manager's internal state for history
// Note: This requires adding a getExecutionHistory method to ExecutionQueueManager
⋮----
// For now, we'll show a message that history is not yet available
// This would need to be implemented in the ExecutionQueueManager
⋮----
// Show current status as a placeholder
</file>

<file path="src/commands/run/ProjectDisplay.ts">
import { logger } from "@/utils/logger";
⋮----
import type { AgentInstance } from "@/agents/types";
import { getProjectContext } from "@/services";
import chalk from "chalk";
⋮----
export class ProjectDisplay
⋮----
async displayProjectInfo(projectPath: string): Promise<void>
⋮----
// Note: Documentation display moved to after subscription EOSE
⋮----
private displayBasicInfo(projectPath: string): void
⋮----
private async displayAgentConfigurations(): Promise<void>
⋮----
// Debug logging
⋮----
private displayAgentBySlug(slug: string, agent: AgentInstance): void
⋮----
// Display agent information
</file>

<file path="src/conversations/__tests__/ConversationManager.integration.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { ConversationManager } from "../ConversationManager";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { AgentInstance } from "@/agents/types";
⋮----
// Mock the persistence module
⋮----
// Mock the tracing module
⋮----
// Mock the logging module
⋮----
// Mock NDK
⋮----
// Mock agents - using realistic agent setup
⋮----
// This test verifies the entire flow of the reported bug:
// 1. User p-tags PM with a question
// 2. PM responds with an offer to help
// 3. User says "yes, let's do it"
// 4. PM should still have context
⋮----
// Step 1: User p-tags PM
⋮----
// Build messages for PM (first time)
⋮----
// Verify PM gets the message correctly (no history block)
⋮----
// PM should get the user's message directly
⋮----
// Step 2: PM responds
⋮----
// Step 3: User replies with "yes, let's do it"
⋮----
// Build messages for PM (continuation)
⋮----
// PM should have full conversation history
// First user message
⋮----
// PM's own previous response should be an assistant message
⋮----
// Current user message
⋮----
// The current message should be the last user message
⋮----
// Verify agent state tracking
⋮----
expect(pmState?.lastProcessedMessageIndex).toBe(3); // Should be at the end
⋮----
// User sends message without p-tag (goes to orchestrator)
⋮----
// Build messages for orchestrator
⋮----
// Orchestrator should NOT get NEW INTERACTION marker (no messages while away)
⋮----
// No history block (first message)
⋮----
// User message with Claude session
⋮----
// Build messages and check session ID is captured
⋮----
// Verify it's stored in agent state
</file>

<file path="src/conversations/executionQueue/ExecutionEventPublisher.ts">
import { ExecutionLock, QueueEntry, ForceReleaseRequest } from './types';
import { NostrEventService } from '../../nostr/NostrEventService';
import { EVENT_KINDS } from '../../llm/types';
import { createNDKEvent } from '../../nostr/event-builder';
import { handlePersistenceError } from '../../utils/file-persistence';
⋮----
export class ExecutionEventPublisher
⋮----
constructor(
⋮----
async publishStatusUpdate(
    currentLock: ExecutionLock | null,
    queue: QueueEntry[],
    estimatedWait: number
): Promise<void>
⋮----
'', // No JSON - keeping empty as per specification
⋮----
// Build tags
⋮----
// Project reference tag
⋮----
// Add execution-queue tags in order (preserving queue order)
// First: the active/executing conversation (if any)
⋮----
// Then: all waiting conversations in queue order
⋮----
// Add supplementary metadata tags (not part of core queue representation)
⋮----
// Sign and publish
⋮----
// Don't throw - status updates are non-critical
⋮----
async publishForceReleaseEvent(request: ForceReleaseRequest): Promise<void>
⋮----
EVENT_KINDS.FORCE_RELEASE, // 24019
request.reason, // Simple human-readable reason, no JSON
⋮----
// Build tags
⋮----
// Project reference tag
⋮----
// Force release details as individual tags
⋮----
// Sign and publish
⋮----
// Don't throw - event publishing is non-critical
⋮----
async publishQueueEvent(
    type: 'lock_acquired' | 'lock_released' | 'queue_joined' | 'queue_left',
    conversationId: string,
    agentPubkey?: string,
    details?: Record<string, any>
): Promise<void>
⋮----
'', // No JSON - empty as per specification
⋮----
// Build tags
⋮----
// Project reference tag
⋮----
// Queue event type with conversation ID
⋮----
// Add any additional details as individual tags (no JSON)
⋮----
// Sign and publish
⋮----
// Don't throw - event publishing is non-critical
⋮----
async publishTimeoutWarning(
    conversationId: string,
    remainingMs: number
): Promise<void>
⋮----
'', // No content - data in tags only
⋮----
// Build tags
⋮----
// Project reference tag
⋮----
// Timeout warning as structured tags
⋮----
// Sign and publish
⋮----
// Don't throw - warnings are non-critical
</file>

<file path="src/conversations/persistence/schemas.ts">
import { z } from "zod";
import { ALL_PHASES } from "@/conversations/phases";
⋮----
// Enhanced handoff fields
⋮----
// Simplified agent state schema
⋮----
lastSeenPhase: z.string().optional(), // Phase as string
⋮----
agentStates: z.record(z.string(), AgentStateSchema).optional(), // Map serialized as object
⋮----
export type SerializedConversation = z.infer<typeof SerializedConversationSchema>;
export type MetadataFile = z.infer<typeof MetadataFileSchema>;
</file>

<file path="src/conversations/AgentConversationContext.ts">
import { Message } from "multi-llm-ts";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import { Phase } from "./phases";
import { PhaseTransition } from "./types";
import { MessageBuilder } from "./MessageBuilder";
import { isEventFromUser, getAgentSlugFromEvent } from "@/nostr/utils";
import { getProjectContext } from "@/services";
import { logger } from "@/utils/logger";
⋮----
/**
 * Manages the complete message stream for a specific agent in a conversation.
 * Single Responsibility: Build and maintain the message array for an agent<>conversation pair.
 */
export class AgentConversationContext
⋮----
private processedEventIds: Set<string> = new Set();  // Track processed events
⋮----
constructor(
        private conversationId: string,
        private agentSlug: string,
        messageBuilder?: MessageBuilder
)
⋮----
/**
     * Process and add an NDKEvent to the message stream
     */
async addEvent(event: NDKEvent): Promise<void>
⋮----
// Check if we've already processed this event
⋮----
// Mark this event as processed
⋮----
/**
     * Handle phase transition if needed
     */
handlePhaseTransition(newPhase: Phase, phaseInstructions?: string): boolean
⋮----
// Only add phase instructions if we're actually transitioning
// or if this is the first time seeing a phase
⋮----
return false; // No transition needed
⋮----
return true; // Transition occurred
⋮----
/**
     * Add the triggering event (the main event being responded to)
     */
async addTriggeringEvent(event: NDKEvent): Promise<void>
⋮----
// Check if we've already processed this triggering event
⋮----
// Process the content
⋮----
// Update session ID if present
⋮----
// Mark this event as processed
⋮----
/**
     * Process multiple events at once (for catching up)
     */
async addEvents(events: NDKEvent[], skipEventId?: string): Promise<void>
⋮----
/**
     * Add a handoff message
     */
addHandoff(handoff: PhaseTransition): void
⋮----
/**
     * Add "messages while you were away" block
     */
async addMissedMessages(events: NDKEvent[], handoffSummary?: string): Promise<void>
⋮----
/**
     * Handle delegation responses
     */
addDelegationResponses(responses: Map<string, NDKEvent>, originalRequest: string): void
⋮----
/**
     * Add a raw message (for special cases)
     */
addMessage(message: Message): void
⋮----
/**
     * Add multiple raw messages
     */
addMessages(messages: Message[]): void
⋮----
/**
     * Get all messages for this agent
     */
getMessages(): Message[]
⋮----
/**
     * Get the last N messages
     */
getRecentMessages(count: number): Message[]
⋮----
/**
     * Remove the last message (useful for error recovery)
     */
popMessage(): Message | undefined
⋮----
/**
     * Get/set the Claude session ID
     */
getClaudeSessionId(): string | undefined
⋮----
setClaudeSessionId(sessionId: string): void
⋮----
/**
     * Get/set the last processed index
     */
getLastProcessedIndex(): number
⋮----
setLastProcessedIndex(index: number): void
⋮----
/**
     * Get the current phase
     */
getCurrentPhase(): Phase | undefined
⋮----
/**
     * Set the current phase (without adding a message)
     */
setCurrentPhase(phase: Phase): void
⋮----
/**
     * Serialize for persistence
     */
toJSON(): object
⋮----
/**
     * Restore from persistence
     */
static fromJSON(data: any, messageBuilder?: MessageBuilder): AgentConversationContext
⋮----
// Restore messages
⋮----
// Restore processed event IDs
⋮----
/**
     * Helper to determine event sender
     */
private getEventSender(event: NDKEvent): string | null
⋮----
// Mark the agent's own previous messages clearly
⋮----
/**
     * Helper to get agent name by pubkey
     */
private getAgentNameByPubkey(pubkey: string): string
</file>

<file path="src/llm/LLMConfigEditor.ts">
import type { ResolvedLLMConfig, LLMProvider } from "@/llm/types";
import { configService } from "@/services";
import type { TenexLLMs } from "@/services/config/types";
import { LLM_DEFAULTS } from "./constants";
import { ModelSelector } from "./selection/ModelSelector";
import { LLMTester } from "./testing/LLMTester";
import { LLMConfigUI, type LLMConfigWithName } from "./ui/LLMConfigUI";
⋮----
/**
 * LLM Configuration Editor - Orchestrates configuration management
 * Now focused purely on business logic, delegating to specialized utilities
 */
export class LLMConfigEditor
⋮----
constructor(private configPath: string, private isGlobal = true)
⋮----
async showMainMenu(): Promise<void>
⋮----
async runOnboardingFlow(): Promise<void>
⋮----
// Configuration Management - Delegates to ConfigService
private async loadConfig(): Promise<TenexLLMs>
⋮----
// Return empty config on error
⋮----
private async saveConfig(config: TenexLLMs): Promise<void>
⋮----
private getConfigList(llmsConfig: TenexLLMs): LLMConfigWithName[]
⋮----
// Get credentials if they exist
⋮----
private getExistingApiKeys(llmsConfig: TenexLLMs, provider: LLMProvider): string[]
⋮----
// Menu Action Handler
private async handleMenuAction(action: string, llmsConfig: TenexLLMs): Promise<void>
⋮----
// Core Configuration Operations
private async addConfiguration(llmsConfig: TenexLLMs): Promise<void>
⋮----
// 1. Select provider
⋮----
// 2. Fetch and select model
⋮----
// Show success message (we can get count from the successful selection)
this.ui.displayMessages.modelsFound(0, provider); // Count will be shown by fetchAndSelectModel internally
⋮----
// 3. Get API key
⋮----
// 4. Configure settings
⋮----
// 5. Build and test configuration
⋮----
// 6. Save configuration
⋮----
private async editConfiguration(llmsConfig: TenexLLMs): Promise<void>
⋮----
// Create LLMConfigWithName from the base config
⋮----
private async editModel(config: LLMConfigWithName, llmsConfig: TenexLLMs): Promise<void>
⋮----
// Update the original config in llmsConfig
⋮----
private async editApiKey(config: LLMConfigWithName, llmsConfig: TenexLLMs): Promise<void>
⋮----
// Always update credentials
⋮----
private async editCaching(config: LLMConfigWithName, llmsConfig: TenexLLMs): Promise<void>
⋮----
// Update the original config in llmsConfig
⋮----
private async editConfigName(_config: LLMConfigWithName, oldName: string, llmsConfig: TenexLLMs): Promise<void>
⋮----
// Copy the original config to the new name
⋮----
// Update defaults if needed
⋮----
private async removeConfiguration(llmsConfig: TenexLLMs): Promise<void>
⋮----
// Update defaults if needed
⋮----
private async setDefaultConfiguration(llmsConfig: TenexLLMs, defaultType: string): Promise<void>
⋮----
private getTypeLabelForDefault(defaultType: string): string
⋮----
private async testExistingConfiguration(llmsConfig: TenexLLMs): Promise<void>
</file>

<file path="src/nostr/TaskPublisher.ts">
import type { AgentInstance } from "@/agents/types";
import { getProjectContext } from "@/services";
import { logger } from "@/utils/logger";
import type NDK from "@nostr-dev-kit/ndk";
import { NDKTask } from "@nostr-dev-kit/ndk";
import type { ConversationManager } from "@/conversations/ConversationManager";
⋮----
export interface TaskCreationOptions {
    title: string;
    prompt: string;
    branch?: string;
    conversationRootEventId?: string;
    conversationManager?: ConversationManager;
    claudeSessionId?: string;
}
⋮----
export interface TaskCompletionOptions {
    sessionId?: string;
    totalCost?: number;
    messageCount?: number;
    duration?: number;
    error?: string;
    finalMessage?: string;
}
⋮----
/**
 * Publishes NDKTask events to Nostr
 * Single Responsibility: Manage the lifecycle of NDKTask events (create and complete)
 */
export class TaskPublisher
⋮----
constructor(
⋮----
async createTask(options: TaskCreationOptions): Promise<NDKTask>
⋮----
// Tag the project
⋮----
// Add branch tag if provided
⋮----
// Link to conversation if provided
⋮----
// Sign with the agent's signer
⋮----
// we want to allow any message that prefaces the creation of this task to be published
// setTimeout(task.publish, 500);
⋮----
// Store the task instance for future operations
⋮----
// Register task mapping if conversation manager is provided
⋮----
/**
     * Completes the current task by publishing a completion event
     * @param success - Whether the task completed successfully
     * @param options - Additional metadata about the task completion
     */
async completeTask(success: boolean, options: TaskCompletionOptions): Promise<void>
⋮----
// Create a completion event as a reply to the task
⋮----
// Build completion message
⋮----
// Use finalMessage if provided, otherwise use generic completion message
⋮----
// Append metadata as a footer
⋮----
// Fallback to generic message
⋮----
// Add status tag
⋮----
// Remove all p tags (we don't want to notify all participants)
⋮----
// Add session ID if available
⋮----
// Add error tag if task failed
⋮----
// Add project tag
⋮----
// Sign with the agent's signer
⋮----
// Don't throw - task completion is best effort
⋮----
// Clear the current task after completion
⋮----
async publishTaskProgress(content: string, sessionId?: string): Promise<void>
⋮----
// Create a proper reply using the task event
⋮----
// remove all p tags
⋮----
// Add session ID if available
⋮----
// Add project tag
⋮----
// Sign with the agent's signer
</file>

<file path="src/prompts/fragments/__tests__/integration.test.ts">
import { PromptBuilder } from "../../core/PromptBuilder";
⋮----
import type { AgentInstance } from "@/agents/types";
import type { Phase } from "@/conversations/phases";
import { describe, expect, it } from "bun:test";
⋮----
// Should have available agents
⋮----
// Should have orchestrator routing instructions
⋮----
// Should have routing rules
⋮----
// Should have identity section with pubkey
⋮----
// Should have instructions and project context
⋮----
name: "Test Project", // This would be set by AgentRegistry
⋮----
// Should have identity section with project name
⋮----
// Should have instructions and project context
</file>

<file path="src/prompts/fragments/__tests__/tool-registry.test.ts">
import { describe, test, expect } from "bun:test";
import { getTool } from "@/tools/registry";
⋮----
// Test that the tool registry has proper structure
⋮----
// The shape for a ZodObject has type "object" and properties
⋮----
// Test validation
</file>

<file path="src/services/ConfigService.ts">
import { ensureDirectory, fileExists, readJsonFile, writeJsonFile } from "@/lib/fs";
import type {
    ConfigFile,
    LoadedConfig,
    TenexAgents,
    TenexConfig,
    TenexLLMs,
    TenexMCP,
} from "@/services/config/types";
import {
    TenexAgentsSchema,
    TenexConfigSchema,
    TenexLLMsSchema,
    TenexMCPSchema,
} from "@/services/config/types";
import { logger } from "@/utils/logger";
import { formatAnyError } from "@/utils/error-formatter";
import { TENEX_DIR, CONFIG_FILE, MCP_CONFIG_FILE, AGENTS_FILE, LLMS_FILE } from "@/constants";
import type { z } from "zod";
⋮----
/**
 * Centralized configuration service for TENEX
 * Handles loading and saving of all configuration files
 * Pure file operations with validation - no business logic
 */
export class ConfigService
⋮----
private readonly CACHE_TTL_MS = 5000; // 5 seconds
private readonly cacheTTL = this.CACHE_TTL_MS; // Keep for backwards compatibility
⋮----
private constructor()
⋮----
static getInstance(): ConfigService
⋮----
// =====================================================================================
// PATH UTILITIES
// =====================================================================================
⋮----
getGlobalPath(): string
⋮----
getProjectPath(projectPath: string): string
⋮----
private getConfigFilePath(basePath: string, configFile: ConfigFile): string
⋮----
// =====================================================================================
// COMPLETE CONFIGURATION LOADING
// =====================================================================================
⋮----
async loadConfig(projectPath?: string): Promise<LoadedConfig>
⋮----
// Load global config
⋮----
// Load project config if provided
⋮----
// Merge configs (project overrides global)
⋮----
// Merge arrays properly
⋮----
// Load agents (merge global and project)
⋮----
// Load LLMs (merge global and project)
⋮----
// Load MCP (merge global and project)
⋮----
// =====================================================================================
// INDIVIDUAL FILE LOADING
// =====================================================================================
⋮----
async loadTenexConfig(basePath: string): Promise<TenexConfig>
⋮----
async loadTenexAgents(basePath: string): Promise<TenexAgents>
⋮----
async loadTenexLLMs(basePath: string): Promise<TenexLLMs>
⋮----
async loadTenexMCP(basePath: string): Promise<TenexMCP>
⋮----
// Ensure servers is always defined
⋮----
// =====================================================================================
// INDIVIDUAL FILE SAVING
// =====================================================================================
⋮----
async saveTenexConfig(basePath: string, config: TenexConfig): Promise<void>
⋮----
async saveTenexAgents(basePath: string, agents: TenexAgents): Promise<void>
⋮----
async saveTenexLLMs(basePath: string, llms: TenexLLMs): Promise<void>
⋮----
async saveTenexMCP(basePath: string, mcp: TenexMCP): Promise<void>
⋮----
// =====================================================================================
// BUSINESS LOGIC METHODS
// =====================================================================================
⋮----
/**
     * Get whitelisted pubkeys with CLI override support
     * If CLI option is provided, it ONLY uses those pubkeys (doesn't merge with config)
     * Otherwise, returns pubkeys from the configuration
     */
getWhitelistedPubkeys(cliOption?: string, config?: TenexConfig): string[]
⋮----
// If CLI option is provided, ONLY use those pubkeys (don't merge with config)
⋮----
// Otherwise, use config pubkeys
⋮----
// =====================================================================================
// CONVENIENCE METHODS
// =====================================================================================
⋮----
async saveGlobalConfig(config: TenexConfig): Promise<void>
⋮----
async saveProjectConfig(projectPath: string, config: TenexConfig): Promise<void>
⋮----
async saveGlobalAgents(agents: TenexAgents): Promise<void>
⋮----
async loadProjectAgents(projectPath: string): Promise<TenexAgents>
⋮----
async saveProjectAgents(projectPath: string, agents: TenexAgents): Promise<void>
⋮----
async saveGlobalLLMs(llms: TenexLLMs): Promise<void>
⋮----
async saveProjectLLMs(projectPath: string, llms: TenexLLMs): Promise<void>
⋮----
async saveGlobalMCP(mcp: TenexMCP): Promise<void>
⋮----
async saveProjectMCP(projectPath: string, mcp: TenexMCP): Promise<void>
⋮----
// =====================================================================================
// FILE EXISTENCE CHECKS
// =====================================================================================
⋮----
async configExists(basePath: string, configFile: ConfigFile): Promise<boolean>
⋮----
async globalConfigExists(configFile: ConfigFile): Promise<boolean>
⋮----
async projectConfigExists(projectPath: string, configFile: ConfigFile): Promise<boolean>
⋮----
// =====================================================================================
// PRIVATE IMPLEMENTATION
// =====================================================================================
⋮----
private async loadConfigFile<T>(
        filePath: string,
        schema: z.ZodSchema<T>,
        defaultValue: T
): Promise<T>
⋮----
// Check cache first
⋮----
private async saveConfigFile<T>(
        filePath: string,
        data: T,
        schema: z.ZodSchema<T>
): Promise<void>
⋮----
// Ensure directory exists
⋮----
// Validate before saving
⋮----
// Save to file
⋮----
// Update cache
⋮----
private getFromCache<T>(filePath: string): T | null
⋮----
private addToCache<T>(filePath: string, data: T): void
⋮----
clearCache(filePath?: string): void
⋮----
// Export singleton instance
</file>

<file path="src/test-utils/conversational-logger.ts">
/**
 * Conversational logger that formats test output as a natural dialog
 * showing phase transitions and agent interactions
 */
export class ConversationalLogger
⋮----
static getInstance(): ConversationalLogger
⋮----
private formatTime(): string
⋮----
private formatAgentName(agentName: string): string
⋮----
// Capitalize and format agent names nicely
⋮----
.replace(/([a-z])([A-Z])/g, '$1 $2') // Add space before capitals
.replace(/^\w/, c => c.toUpperCase()) // Capitalize first letter
.replace(/-/g, ' '); // Replace hyphens with spaces
⋮----
private getAgentSlug(agentName: string): string
⋮----
// Convert to lowercase slug format
⋮----
private formatLogLine(agentName: string | null, emoji: string, timeStamp: string, message: string): string
⋮----
logAgentThinking(agentName: string, context: {
        phase?: string;
        userMessage?: string;
        iteration?: number;
        agentIteration?: number;
}): void
⋮----
// Check if phase changed
⋮----
logAgentResponse(agentName: string, response: {
        content?: string;
        toolCalls?: any[];
        phase?: string;
        reason?: string;
}): void
⋮----
// Format routing decisions nicely
⋮----
// Not a JSON routing response, handle normally
⋮----
logToolExecution(agentName: string, toolName: string, toolCall: any): void
⋮----
logPhaseTransition(fromPhase: string, toPhase: string): void
⋮----
logError(agentName: string, error: string): void
⋮----
logTestStart(testName: string): void
⋮----
logTestEnd(success: boolean, testName?: string): void
⋮----
logMatchedResponse(mockResponse: any): void
⋮----
// Log tool calls if present
⋮----
reset(): void
⋮----
// Export singleton instance
</file>

<file path="src/test-utils/README.md">
# Test Utilities

This directory contains reusable test utilities for the TENEX backend.

## Mock Setup Helpers

The `mock-setup.ts` file provides common mock setup functions to reduce duplication across test files:

### Usage Example

```typescript
import { setupCommonTestMocks } from "@/test-utils";

describe("MyComponent", () => {
    beforeEach(() => {
        // Setup all common mocks at once
        setupCommonTestMocks("/test/project");
        
        // Or setup individual mocks as needed
        setupServicesMock("/test/project");
        setupExecutionLoggerMock();
        setupTracingMock();
    });
});
```

### Available Functions

- `setupServicesMock(projectPath)` - Mocks the @/services module
- `setupExecutionTimeMock()` - Mocks execution time tracking
- `setupExecutionLoggerMock()` - Mocks the execution logger
- `setupTracingMock()` - Mocks tracing context
- `setupAgentUtilsMock(tools)` - Mocks agent utilities
- `setupToolRegistryMock()` - Mocks the tool registry
- `setupCommonTestMocks(projectPath)` - Sets up all mocks at once

## Mock Factories

The `mock-factories.ts` file provides factory functions for creating mock objects:

- `createMockNDKEvent()` - Creates a mock Nostr event
- `createMockAgent()` - Creates a mock agent
- `createMockConversation()` - Creates a mock conversation
- `createMockExecutionContext()` - Creates a mock execution context
- `createMockToolCall()` - Creates a mock tool call
- `createMockPhaseTransition()` - Creates a mock phase transition
- `createMockFileSystem()` - Creates a mock file system structure
- `MockBuilder` - A builder class for complex mock objects

## Mock LLM Service

The `mock-llm/` directory provides a comprehensive mock LLM service for deterministic testing:

- `MockLLMService` - A mock implementation of the LLM service
- Predefined scenarios for common workflows
- Support for custom response patterns
- Deterministic behavior for E2E testing

## Test Assertions

Custom assertion helpers are available via the `assertions` object:

- `toThrowAsync()` - Assert async functions throw errors
- `toContainObjectMatching()` - Assert arrays contain matching objects

## Other Utilities

- `createTempDir()` - Create temporary directories for testing
- `cleanupTempDir()` - Clean up temporary directories
- `resetAllMocks()` - Reset all mocks and singletons
- `waitFor()` - Wait for conditions to be met
- `mockFileSystem()` - Mock file system operations
- `ConsoleCapture` - Capture console output during tests
</file>

<file path="src/tools/implementations/delegate.ts">
import { z } from "zod";
import { createToolDefinition, success, failure } from "../types";
import { getProjectContext } from "@/services/ProjectContext";
import { logger } from "@/utils/logger";
import { nip19 } from "nostr-tools";
import { NDKTask } from "@nostr-dev-kit/ndk";
⋮----
/**
 * Resolve a recipient string to a pubkey
 * @param recipient - Agent slug or npub/hex pubkey
 * @returns Pubkey hex string or null if not found
 */
function resolveRecipientToPubkey(recipient: string): string | null
⋮----
// Check if it's an npub
⋮----
// Check if it's a hex pubkey (64 characters)
⋮----
// Try to resolve as agent slug
⋮----
// Check project agents
⋮----
// Check built-in agents (already loaded in project context)
// No need for separate check as they're included in projectContext.agents
⋮----
/**
 * Delegate tool - enables agents to communicate with each other by publishing NDKTask events
 * 
 * This tool allows an agent to delegate a task or question to one or more agents by:
 * 1. Resolving each recipient (agent slug or pubkey) to a pubkey
 * 2. Publishing an NDKTask event for each recipient with p-tag assignment
 * 3. Setting up delegation state so the agent waits for all task completions
 * 
 * Recipients can be:
 * - A single recipient or array of recipients
 * - Agent slugs (e.g., "architect", "planner") - resolved from project agents
 * - Npubs (e.g., "npub1...") - decoded to hex pubkeys
 * - Hex pubkeys (64 characters) - used directly
 * 
 * If any recipient cannot be resolved, the tool fails with an error.
 * 
 * When delegating to multiple recipients, the agent will wait for all task completions
 * before continuing. The agent should NOT call complete() after delegating.
 * 
 * Each delegation creates a formal NDKTask (Nostr kind 1934) event that:
 * - Is assigned to a specific agent via p-tag
 * - Links to the conversation root via e-tag
 * - Tracks status (pending/complete)
 * - Enables parallel execution of sub-tasks
 */
⋮----
// Resolve all recipients to pubkeys
⋮----
// If any recipients failed to resolve, return error
⋮----
// If no valid recipients, return error
⋮----
// Create NDKTask events for each recipient
⋮----
// Create a new NDKTask for this specific recipient
⋮----
["p", recipientPubkey],  // Assign to this agent
["e", context.conversationId, "", "root"],  // Link to conversation (conversation ID is the root event ID)
⋮----
// Sign and publish the task
⋮----
// Track this task
⋮----
// Update agent's state to track pending delegation with task IDs
⋮----
// The agent will be reactivated when all tasks complete.
// This is handled in the event handler when task completion events arrive.
</file>

<file path="src/tools/core.ts">
/**
 * First-principles type system for TENEX tools
 *
 * Core philosophy:
 * - Type safety through algebraic data types
 * - Direct async/await for simplicity
 * - Explicit error handling with Result types
 */
⋮----
// ============================================================================
// Core Result Type
// ============================================================================
⋮----
// Import metadata type from executor
import type { ToolExecutionMetadata } from "./executor";
⋮----
// Result type for fallible operations with optional metadata
export type Result<E, A> =
    | { readonly ok: true; readonly value: A; readonly metadata?: ToolExecutionMetadata }
    | { readonly ok: false; readonly error: E };
⋮----
// ============================================================================
// Simple Tool Interface
// ============================================================================
⋮----
// Import unified ExecutionContext
import type { ExecutionContext } from "@/agents/execution/types";
⋮----
// ============================================================================
// Tool Type Definition
// ============================================================================
⋮----
/**
 * Simple, unified tool interface
 */
export interface Tool<Input = unknown, Output = unknown> {
    readonly name: string;
    readonly description: string;
    readonly parameters: ParameterSchema<Input>;
    readonly promptFragment?: string;
    readonly execute: (
        input: Validated<Input>,
        context: ExecutionContext
    ) => Promise<Result<ToolError, Output>>;
}
⋮----
// ============================================================================
// Control Flow and Termination Types
// ============================================================================
⋮----
/**
 * Termination type that ends execution
 */
export type Termination = Complete;
⋮----
import type { NostrEvent } from "@nostr-dev-kit/ndk";
⋮----
export interface Complete {
    readonly type: "complete";
    readonly completion: CompletionSummary;
    readonly serializedEvent?: NostrEvent; // The serialized NDKEvent for deferred publishing
}
⋮----
readonly serializedEvent?: NostrEvent; // The serialized NDKEvent for deferred publishing
⋮----
export interface CompletionSummary {
    readonly response: string;
    readonly summary: string;
    readonly nextAgent: string;
}
⋮----
export interface ConversationResult {
    readonly response: string;
    readonly summary: string;
    readonly success: boolean;
    readonly artifacts?: ReadonlyArray<string>;
}
⋮----
// ============================================================================
// Parameter Schema and Validation
// ============================================================================
⋮----
export interface ParameterSchema<T> {
    readonly shape: SchemaShape;
    readonly validate: (input: unknown) => Result<ValidationError, Validated<T>>;
}
⋮----
export type SchemaShape =
    | { type: "string"; description: string; enum?: ReadonlyArray<string>; required?: boolean }
    | { type: "number"; description: string; min?: number; max?: number; required?: boolean }
    | { type: "boolean"; description: string; required?: boolean }
    | { type: "array"; description: string; items: SchemaShape; required?: boolean }
    | {
          type: "object";
          description: string;
          properties: Readonly<Record<string, SchemaShape>>;
          required?: ReadonlyArray<string>;
      };
⋮----
// Branded type for validated input
export interface Validated<T> {
    readonly _brand: "validated";
    readonly value: T;
}
⋮----
// ============================================================================
// Error Types
// ============================================================================
⋮----
export type ToolError = ValidationError | ExecutionError | SystemError;
⋮----
export interface ValidationError {
    readonly kind: "validation";
    readonly field: string;
    readonly message: string;
}
⋮----
export interface ExecutionError {
    readonly kind: "execution";
    readonly tool: string;
    readonly message: string;
    readonly cause?: unknown;
}
⋮----
export interface SystemError {
    readonly kind: "system";
    readonly message: string;
    readonly stack?: string;
}
⋮----
// ============================================================================
// Helper Types
// ============================================================================
⋮----
// Non-empty array type
export interface NonEmptyArray<T> extends ReadonlyArray<T> {
    readonly 0: T;
}
⋮----
// Helper type guards
export const isNonEmptyArray = <T>(array: ReadonlyArray<T>): array is NonEmptyArray<T>
⋮----
// ============================================================================
// Result Constructors
// ============================================================================
⋮----
export const success = <A>(value: A, metadata?: ToolExecutionMetadata): Result<never, A> => (
⋮----
export const failure = <E>(error: E): Result<E, never> => (
</file>

<file path="src/utils/__tests__/error-handler.test.ts">
import { describe, expect, it, beforeEach, mock } from "bun:test";
import { handleError, withErrorHandling } from "../error-handler";
import { logger } from "../logger";
</file>

<file path="src/utils/error-handler.ts">
import { logger } from "./logger";
import { formatAnyError } from "./error-formatter";
⋮----
/**
 * Standard error handling utility for consistent error management
 * across the codebase
 */
export function handleError(
    error: unknown,
    context: string,
    options?: {
        logLevel?: "error" | "warn" | "debug";
        rethrow?: boolean;
        exitCode?: number;
    }
): string
⋮----
/**
 * Async wrapper for error handling
 */
export async function withErrorHandling<T>(
    fn: () => Promise<T>,
    context: string,
    options?: {
        fallback?: T;
        logLevel?: "error" | "warn" | "debug";
        rethrow?: boolean;
    }
): Promise<T | undefined>
</file>

<file path="src/agents/__tests__/tool-assignment.test.ts">
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { getDefaultToolsForAgent } from "../constants";
import { getBuiltInAgents } from "../builtInAgents";
⋮----
// Both agents get default tools from constants.ts
⋮----
expect(executorTools).not.toContain("delegate"); // No delegate tool for non-PM agents
⋮----
// Planner gets the same default tools
⋮----
expect(plannerTools).not.toContain("delegate"); // No delegate tool for non-PM agents
⋮----
// Note: AgentRegistry.ts will remove all tools from these agents
// since they use claude backend, but getDefaultToolsForAgent
// returns the default set for non-orchestrator built-in agents
⋮----
expect(tools).not.toContain("delegate"); // No delegate tool for custom agents
⋮----
expect(tools).toContain("delegate"); // Only PM agent has delegate tool
⋮----
// This test verifies that when creating an agent,
// the isBuiltIn status is determined BEFORE calling getDefaultToolsForAgent
⋮----
// Verify orchestrator is in built-in agents
⋮----
// The fix in AgentRegistry.ts line 212 ensures isBuiltIn is determined before tool assignment
</file>

<file path="src/agents/execution/TerminationHandler.ts">
import type { TracingLogger } from "@/tracing";
import type { ExecutionContext } from "./types";
import { StreamStateManager } from "./StreamStateManager";
import { PHASES } from "@/conversations/phases";
import { logger } from "@/utils/logger";
⋮----
/**
 * Handles termination logic for agent execution.
 * Checks if agents properly terminated and logs when they don't.
 */
export class TerminationHandler
⋮----
constructor(private stateManager: StreamStateManager)
⋮----
/**
     * Check if agent terminated properly and log if not
     */
checkTermination(
        context: ExecutionContext,
        tracingLogger: TracingLogger
): void
⋮----
// Check if this agent requires termination
⋮----
// If terminated properly or termination not required, we're done
⋮----
// Log that agent didn't terminate properly
</file>

<file path="src/agents/utils.ts">
import type { AgentInstance } from "./types";
⋮----
/**
 * Normalize an agent name to kebab-case
 * Handles common variations like "Project Manager" → "project-manager"
 * @param name The name to normalize
 * @returns The normalized name
 */
const normalizeAgentName = (name: string): string =>
⋮----
.replace(/\s+/g, '-')        // Replace spaces with hyphens
.replace(/_+/g, '-')         // Replace underscores with hyphens
.replace(/[^\w-]/g, '')      // Remove non-word characters except hyphens
.replace(/-+/g, '-')         // Replace multiple hyphens with single hyphen
.replace(/^-|-$/g, '');      // Remove leading/trailing hyphens
⋮----
/**
 * Find an agent by name with case-insensitive and kebab-case normalization fallback
 * @param agents Map of agent slug to AgentInstance
 * @param agentName Name to search for
 * @returns The found agent or undefined
 */
export const findAgentByName = (agents: Map<string, AgentInstance>, agentName: string): AgentInstance | undefined =>
⋮----
// Try exact match first
⋮----
// If not found, try case-insensitive search
⋮----
// If still not found, try normalized kebab-case search
</file>

<file path="src/event-handler/index.ts">
import { formatAnyError } from "@/utils/error-formatter";
import { type NDKEvent, NDKKind, NDKTask } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
import chalk from "chalk";
import { AgentExecutor } from "../agents/execution/AgentExecutor";
import { ConversationManager } from "../conversations/ConversationManager";
import type { LLMService } from "../llm/types";
import { EVENT_KINDS } from "../llm/types";
import { getProjectContext } from "../services";
import { logger } from "../utils/logger";
import { handleNewConversation } from "./newConversation";
import { handleProjectEvent } from "./project";
import { handleChatMessage } from "./reply";
import { handleTask } from "./task";
⋮----
export class EventHandler
⋮----
constructor(
⋮----
async initialize(): Promise<void>
⋮----
// Initialize components directly
⋮----
// Initialize components
⋮----
async handleEvent(event: NDKEvent): Promise<void>
⋮----
// Ignore kind 24010 (project status), 24111 (typing indicator), and 24112 (typing stop) events
⋮----
private async handleLLMConfigChange(event: NDKEvent): Promise<void>
⋮----
// Extract the agent pubkey and new model from the event tags
⋮----
// Get the agent from the project context
⋮----
// Update the agent's LLM configuration persistently
⋮----
// Also update in memory for immediate effect
⋮----
// Fallback: at least update in memory for this session
⋮----
private handleDefaultEvent(event: NDKEvent): void
⋮----
async cleanup(): Promise<void>
⋮----
// Save all conversations before shutting down
</file>

<file path="src/event-handler/project.ts">
import type { NDKEvent, NDKProject } from "@nostr-dev-kit/ndk";
import { AgentRegistry } from "../agents/AgentRegistry";
import type { AgentInstance } from "../agents/types";
import { getNDK } from "../nostr";
import { getProjectContext, isProjectContextInitialized } from "../services/ProjectContext";
import { fetchAgentDefinition } from "../utils/agentFetcher";
import { logger } from "../utils/logger";
import { toKebabCase } from "../utils/string";
import { NDKMCPTool } from "../events/NDKMCPTool";
import { 
    installMCPServerFromEvent, 
    getInstalledMCPEventIds, 
    removeMCPServerByEventId 
} from "../services/mcp/mcpInstaller";
import { mcpService } from "../services/mcp/MCPService";
⋮----
/**
 * Handles project update events by syncing agent and MCP tool definitions.
 * When a project event is received, this function:
 * 1. Checks if the event is for the currently loaded project
 * 2. Identifies new agents and MCP tools that have been added to the project
 * 3. Fetches definitions from Nostr for new agents and MCP tools
 * 4. Saves definitions to disk and registers them
 * 5. Updates the ProjectContext with the new configuration
 */
export async function handleProjectEvent(event: NDKEvent, projectPath: string): Promise<void>
⋮----
// Extract agent event IDs from the project
⋮----
// Extract MCP tool event IDs from the project
⋮----
// Only process if project context is initialized (daemon is running)
⋮----
// Check if this is the same project that's currently loaded
⋮----
// Load agent registry
⋮----
// Track which agents need to be added or updated
⋮----
// Find new agents that need to be fetched
⋮----
// Find agents that need to be removed (exist locally but not in the project)
⋮----
// We'll process if there are any changes to agents OR MCP tools
⋮----
// Handle agent removals first
⋮----
// Fetch and save new agent definitions
⋮----
// Save agent definition file
⋮----
// Generate a slug for the agent
⋮----
// Ensure the agent is registered
⋮----
// Process MCP tool changes
⋮----
// Get currently installed MCP event IDs (only those with event IDs)
⋮----
// Find new MCP tools that need to be fetched
⋮----
// Find MCP tools that need to be removed (exist locally but not in the project)
⋮----
// Handle MCP tool removals first
⋮----
// Fetch and install new MCP tools
⋮----
// Reload MCP service if there were any MCP tool changes
⋮----
// Reload the agent registry to get all agents including new ones
⋮----
// Update the project context with new agents
⋮----
// Create NDKProject from the event
⋮----
// Update the existing project context atomically
</file>

<file path="src/llm/router.ts">
import { configService } from "@/services";
import { logger } from "@/utils/logger";
import { igniteEngine, loadModels } from "multi-llm-ts";
import { ToolPlugin } from "./ToolPlugin";
import { getLLMLogger, initializeLLMLogger } from "./callLogger";
import type {
    CompletionRequest,
    CompletionResponse,
    ResolvedLLMConfig,
    LLMService,
    StreamEvent,
} from "./types";
⋮----
export interface LLMRouterConfig {
    configs: Record<string, ResolvedLLMConfig>;
    defaults: {
        agents?: string;
        analyze?: string;
        orchestrator?: string;
        [key: string]: string | undefined;
    };
}
⋮----
/**
 * Simple LLM router that manages multiple LLM instances
 */
export class LLMRouter implements LLMService
⋮----
constructor(private config: LLMRouterConfig)
⋮----
/**
     * Resolve which configuration to use based on context
     */
private resolveConfigKey(context?:
⋮----
// Check if configName is a defaults reference (e.g., "defaults.analyze")
⋮----
// If the default key doesn't exist or point to a valid config, continue to other logic
⋮----
// Check if configName is a default key (e.g., "agents", "analyze", "orchestrator")
⋮----
// Direct config name takes precedence
⋮----
// Fallback to first available config
⋮----
/**
     * Get available configuration keys
     */
getConfigKeys(): string[]
⋮----
/**
     * Complete a request using the appropriate LLM
     */
async complete(request: CompletionRequest): Promise<CompletionResponse>
⋮----
// Extract context from request options
⋮----
// Get the configuration key
⋮----
// Trace system prompt if present
⋮----
// Trace all messages
⋮----
// Use the multi-llm-ts v4 API
⋮----
// Register tools as plugins if provided
⋮----
// Find the specific model - handle both string and ChatModel types
⋮----
// Execute completion with API
⋮----
// Add model information to the response
// The response from multi-llm-ts doesn't include the model, so we add it
⋮----
// Trace response content
⋮----
// Trace tool calls if present
⋮----
// Log to comprehensive JSONL logger
⋮----
// Log to comprehensive JSONL logger
⋮----
async *stream(request: CompletionRequest): AsyncIterable<StreamEvent>
⋮----
// Register tools as plugins if provided
⋮----
// Find the specific model
⋮----
// Use generate() for streaming
⋮----
// Log chunk metadata
⋮----
// Debug logging for chunk types
⋮----
// Normalize empty string to empty object for tools with no arguments
⋮----
// Build the final response with model information
⋮----
// Log summary of streaming session
⋮----
// Log to comprehensive JSONL logger
⋮----
// No usage chunk received - create a response anyway for logging
⋮----
// Create a response without usage data
⋮----
// Log even without usage data
⋮----
// Log to comprehensive JSONL logger
⋮----
/**
 * Load LLM router from configuration file
 */
export async function loadLLMRouter(projectPath: string): Promise<LLMRouter>
⋮----
// Initialize comprehensive LLM logger
⋮----
// Use configService to load merged global and project-specific configuration
⋮----
// Transform TenexLLMs structure to LLMRouterConfig with resolved configs
⋮----
// For each configuration, merge in the credentials to create resolved configs
⋮----
/**
 * Create an agent-aware LLM service that automatically routes based on agent
 */
export function createAgentAwareLLMService(router: LLMRouter, agentName: string): LLMService
⋮----
// Inject agent name into options
⋮----
// Inject agent name into options
</file>

<file path="src/llm/ToolPlugin.ts">
import { formatAnyError } from "@/utils/error-formatter";
import { getToolLogger } from "@/tools/toolLogger";
import type {
    Tool,
    ExecutionContext,
    ToolExecutor,
    ToolError,
    ToolExecutionResult,
} from "@/tools/types";
import { createToolExecutor } from "@/tools/types";
import { logger } from "@/utils/logger";
import {
    Plugin,
    type PluginExecutionContext,
    type PluginParameter as MultiLLMPluginParameter,
} from "multi-llm-ts";
import { serializeToolResult } from "./ToolResult";
⋮----
/**
 * Adapter that converts TENEX Tool to multi-llm-ts Plugin
 * Handles all tool types with unified interface
 */
export class ToolPlugin extends Plugin
⋮----
constructor(
        private readonly tool: Tool,
        private readonly tenexContext: ExecutionContext
)
⋮----
serializeInTools(): boolean
⋮----
isEnabled(): boolean
⋮----
getName(): string
⋮----
getDescription(): string
⋮----
getRunningDescription(tool: string, args: Record<string, unknown>): string
⋮----
// For the continue tool specifically, provide a concise description
⋮----
// For other tools, provide a generic running description
⋮----
getParameters(): MultiLLMPluginParameter[]
⋮----
// Extract parameter info from schema shape
⋮----
// Add enum values if present
⋮----
private mapSchemaTypeToPluginType(
        schemaType: string
): "string" | "number" | "boolean" | "array" | "object"
⋮----
async execute(
        _context: PluginExecutionContext,
        parameters: Record<string, unknown>
): Promise<unknown>
⋮----
// Normalize parameters to handle edge cases from LLMs
⋮----
// Some LLMs send empty strings "" for tools with no required parameters
// Convert these to empty objects for proper validation
⋮----
// Also handle null/undefined edge cases
⋮----
// Execute the tool using the type-safe executor
⋮----
// Serialize the typed result for transport through LLM layer
⋮----
// Create a human-readable output message
⋮----
// Check if it's a control flow result
⋮----
// Check if it's a termination result
⋮----
// Regular tool output
⋮----
// Extract error message if present
⋮----
// Return both serialized result and human-readable output
⋮----
// Include the full typed result for ReasonActLoop
⋮----
// Log the successful tool execution
⋮----
result, // Pass the original typed result
⋮----
// Create an error result for logging
⋮----
// Log the failed tool execution
⋮----
private formatError(error: ToolError): string
⋮----
// If the field is empty and message is just "Required", make it clearer
</file>

<file path="src/llm/types.ts">
export interface ModelSelectionResult {
    model: string;
    supportsCaching: boolean;
}
⋮----
export interface ConfigurationPrompts {
    configName: string;
    enableCaching?: boolean;
    setAsDefault: boolean;
}
⋮----
export interface ApiKeyResult {
    apiKey: string;
    isNew: boolean;
}
⋮----
/**
 * Clean LLM types with single responsibility
 * No agent or orchestration concerns
 */
⋮----
import { NDKAgentDefinition } from "@/events";
import { NDKKind, NDKProject, NDKTask } from "@nostr-dev-kit/ndk";
import type {
    LlmCompletionOpts,
    Message as LlmMessage,
    LlmResponse,
    LlmTool,
    LlmToolCall,
} from "multi-llm-ts";
⋮----
// Re-export multi-llm-ts types directly
export type Message = LlmMessage;
// Extend LlmResponse to include model information
export type CompletionResponse = LlmResponse & { model?: string };
export type ToolDefinition = LlmTool;
export type ToolCall = LlmToolCall;
⋮----
// Extended completion options with routing context
export interface CompletionOptions extends LlmCompletionOpts {
    configName?: string;
    agentName?: string;
}
⋮----
// Import and re-export tool types
import type { Tool, ExecutionContext } from "@/tools/types";
⋮----
// Simplified completion request that uses multi-llm-ts types
export interface CompletionRequest {
    messages: Message[];
    options?: CompletionOptions;
    tools?: Tool[];
    toolContext?: ExecutionContext;
}
⋮----
// Streaming types
export type StreamEvent =
    | { type: "content"; content: string }
    | { type: "tool_start"; tool: string; args: Record<string, unknown> }
    | { type: "tool_complete"; tool: string; result: unknown }
    | { type: "error"; error: string }
    | { type: "done"; response: CompletionResponse };
⋮----
/**
 * Pure LLM service interface - single responsibility
 */
export interface LLMService {
    complete(request: CompletionRequest): Promise<CompletionResponse>;
    stream(request: CompletionRequest): AsyncIterable<StreamEvent>;
}
⋮----
complete(request: CompletionRequest): Promise<CompletionResponse>;
stream(request: CompletionRequest): AsyncIterable<StreamEvent>;
⋮----
/**
 * LLM Model Configuration - matches what's stored on disk in TenexLLMs.configurations
 * Does NOT include credentials (apiKey, baseUrl) which are stored separately
 */
export interface LLMModelConfig {
    provider: LLMProvider;
    model: string;
    enableCaching?: boolean;
    temperature?: number;
    maxTokens?: number;
}
⋮----
/**
 * Resolved LLM Configuration - includes credentials for runtime use
 * This is what the LLM service actually needs to make API calls
 */
export interface ResolvedLLMConfig extends LLMModelConfig {
    apiKey?: string;
    baseUrl?: string;
    headers?: Record<string, string>;
}
⋮----
/**
 * Named LLM configuration for UI display and management
 */
export interface LLMConfigWithName extends ResolvedLLMConfig {
    name: string;
}
⋮----
/**
 * LLM Provider types
 */
⋮----
export type LLMProvider = (typeof LLM_PROVIDERS)[number];
⋮----
/**
 * Event kinds used in the TENEX system
 */
⋮----
/**
 * Provider authentication
 */
export interface ProviderAuth {
    apiKey?: string;
    baseUrl?: string;
    headers?: Record<string, string>;
}
</file>

<file path="src/logging/ExecutionLogger.ts">
import type { LogModule } from "@/utils/logger";
import { logInfo } from "@/utils/logger";
import type { TracingContext } from "@/tracing";
import { formatDuration } from "@/utils/formatting";
import chalk from "chalk";
import type { Phase } from "@/conversations/phases";
⋮----
/**
 * Simplified event system using discriminated unions
 * All events share common base properties and extend with specific fields
 */
export type LogEvent = {
    timestamp: Date;
    conversationId: string;
    agent: string;
} & (
    | { type: "tool_call"; tool: string; args?: Record<string, unknown>; }
    | { type: "tool_result"; tool: string; status: "success" | "error"; result?: unknown; error?: string; duration: number; }
    | { type: "phase_transition"; from: Phase; to: Phase; reason: string; }
    | { type: "routing"; targetAgents: string[]; targetPhase?: Phase; reason: string; }
    | { type: "conversation_start"; userMessage: string; eventId?: string; }
    | { type: "conversation_complete"; finalPhase: Phase; success: boolean; duration: number; }
    | { type: "execution_start"; narrative: string; }
    | { type: "execution_complete"; narrative: string; success: boolean; }
);
⋮----
/**
 * Unified execution logger for structured event logging
 */
export class ExecutionLogger
⋮----
constructor(
        private context: TracingContext,
        private module: LogModule = "agent"
)
⋮----
/**
     * Update context (e.g., when agent changes)
     */
updateContext(context: TracingContext): void
⋮----
/**
     * Log an event with structured formatting
     */
logEvent(event: LogEvent): void
⋮----
// Add timestamp if not present
⋮----
// Tool Events
private logToolCall(event: LogEvent &
⋮----
private logToolResult(event: LogEvent &
⋮----
// Phase Transition
private logPhaseTransition(event: LogEvent &
⋮----
// Routing
private logRouting(event: LogEvent &
⋮----
// Conversation Events
private logConversationStart(event: LogEvent &
⋮----
private logConversationComplete(event: LogEvent &
⋮----
// Execution Flow Events
private logExecutionStart(event: LogEvent &
⋮----
private logExecutionComplete(event: LogEvent &
⋮----
// Helper methods
private truncate(text: string, maxLength: number): string
⋮----
private shortId(id: string): string
⋮----
private formatParams(params: Record<string, unknown>): string
⋮----
private formatValue(value: unknown): string
⋮----
// Quick logging methods for backward compatibility
toolStart(agent: string, tool: string, parameters?: Record<string, unknown>): void
⋮----
toolComplete(
        agent: string, 
        tool: string, 
        status: "success" | "error", 
        duration: number,
        options?: { result?: string; error?: string }
): void
⋮----
routingDecision(
        agent: string,
        targetAgents: string[],
        reason: string,
        options?: { targetPhase?: Phase; }
): void
⋮----
/**
 * Create an execution logger instance
 */
export function createExecutionLogger(context: TracingContext, module?: LogModule): ExecutionLogger
</file>

<file path="src/nostr/NostrPublisher.ts">
import type { AgentInstance } from "@/agents/types";
import { getTotalExecutionTimeSeconds } from "@/conversations/executionTime";
import type { Conversation } from "@/conversations/types";
import type { ConversationManager } from "@/conversations/ConversationManager";
import { EVENT_KINDS } from "@/llm/types";
import { getNDK } from "@/nostr";
import { EXECUTION_TAGS } from "@/nostr/tags";
import type { LLMMetadata } from "@/nostr/types";
import { getProjectContext } from "@/services";
import type { Complete } from "@/tools/types";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import { TypingIndicatorManager } from "./TypingIndicatorManager";
⋮----
// Context passed to publisher on creation
export interface NostrPublisherContext {
    conversationId: string;
    agent: AgentInstance;
    triggeringEvent: NDKEvent;
    conversationManager: ConversationManager;
}
⋮----
// Options for publishing responses
export interface ResponseOptions {
    content: string;
    llmMetadata?: LLMMetadata;
    completeMetadata?: Complete;
    additionalTags?: string[][];
    destinationPubkeys?: string[];
}
⋮----
// TENEX logging types
interface TenexLogData {
    event: string;
    agent: string;
    details: Record<string, unknown>;
    timestamp?: number;
}
⋮----
// Metadata for finalizing stream
interface FinalizeMetadata {
    llmMetadata?: LLMMetadata;
    completeMetadata?: Complete;
}
⋮----
export class NostrPublisher
⋮----
constructor(public readonly context: NostrPublisherContext)
⋮----
/**
     * Clean up any resources (e.g., pending timers).
     */
async cleanup(): Promise<void>
⋮----
// Force stop typing indicator if still active
⋮----
private getConversation(): Conversation
⋮----
/**
     * Publishes an agent's response to Nostr and updates the conversation state.
     *
     * IMPORTANT: This method follows a save-then-publish pattern for transactional integrity:
     * 1. First updates the conversation state in memory
     * 2. Then saves the conversation to persistent storage
     * 3. Only after successful save does it publish to Nostr
     *
     * This ensures that we never have events on the network that aren't reflected
     * in our local state, preventing state inconsistencies.
     */
async publishResponse(options: ResponseOptions): Promise<NDKEvent>
⋮----
// Just use the content provided by the caller
⋮----
// Add metadata tags
⋮----
// Debug logging for metadata
⋮----
// Add p-tags for destination pubkeys if provided
⋮----
// Add any additional tags
⋮----
// With the new simplified system, we don't need to manually add messages to context
// The conversation history (NDKEvents) is the source of truth
// Just save the conversation state BEFORE publishing
⋮----
// Sign and publish only after local state is successfully updated
⋮----
async publishError(message: string): Promise<NDKEvent>
⋮----
async publishTenexLog(logData: TenexLogData): Promise<NDKEvent>
⋮----
// Set timestamp
⋮----
// Create structured content
⋮----
// Add base tags
⋮----
// Add conversation reference
⋮----
// Add TENEX-specific tags
⋮----
async publishTypingIndicator(state: "start" | "stop", message?: string): Promise<NDKEvent | void>
⋮----
// Use the typing indicator manager for start calls
⋮----
// For stop calls, use the manager's stop method which handles timing
⋮----
/**
     * Internal method used by TypingIndicatorManager to publish raw typing events.
     * This bypasses the timing logic and publishes immediately.
     */
async publishTypingIndicatorRaw(state: "start" | "stop", message?: string): Promise<NDKEvent>
⋮----
// Use provided message or default
⋮----
// Add base tags (project, phase)
⋮----
// Add conversation references
⋮----
createStreamPublisher(): StreamPublisher
⋮----
// Public helper methods (made public for handleAgentCompletion)
public createBaseReply(): NDKEvent
⋮----
// When the triggering event has E tag, replace e tag with E tag value
⋮----
private addBaseTags(event: NDKEvent): void
⋮----
// Always add project tag
⋮----
// Always add current phase tag from the single source of truth
⋮----
// Always add execution time tag using the fresh conversation object
⋮----
// Add voice mode tag if the triggering event has it
⋮----
private cleanPTags(event: NDKEvent): void
⋮----
// Remove all p-tags added by NDK's reply() method to ensure clean routing
⋮----
public addLLMMetadata(event: NDKEvent, metadata?: LLMMetadata): void
⋮----
// event.tag(["llm-system-prompt", metadata.systemPrompt]);
⋮----
export class StreamPublisher
⋮----
private pendingContent = ""; // Content waiting to be published
private accumulatedContent = ""; // Total content accumulated so far
⋮----
private static readonly FLUSH_DELAY_MS = 100; // Delay before actually publishing
private static readonly SENTENCE_ENDINGS = /[.!?](?:\s|$)/; // Regex to detect sentence endings
⋮----
constructor(private readonly publisher: NostrPublisher)
⋮----
addContent(content: string): void
⋮----
// Add content to buffers
⋮----
// Check if we should flush based on sentence endings
⋮----
// If no flush is scheduled, schedule one automatically
⋮----
// If we have a sentence ending and there's already a scheduled flush,
// cancel it and flush immediately
⋮----
private shouldFlushAtSentenceEnd(): boolean
⋮----
// Check if the pending content ends with a sentence ending
⋮----
// Only flush at sentence endings if enough time has passed since last flush
// This prevents too frequent flushing for rapid short sentences
⋮----
async flush(): Promise<void>
⋮----
// Skip if no content to flush or already finalized
⋮----
// If there's already a scheduled flush, we need to handle it
⋮----
// If a flush is already scheduled, publish it immediately and schedule the new content.
// This prioritizes latency for the first batch while still batching subsequent content.
⋮----
// Schedule this content to be published after a delay
// This balances between network efficiency (batching) and user experience (low latency)
⋮----
async finalize(metadata: FinalizeMetadata): Promise<NDKEvent | undefined>
⋮----
// Cancel any pending flush timeout
⋮----
// Move any scheduled content back to pending
⋮----
// Use accumulated content for the final reply, not just pending content
⋮----
// StreamPublisher only handles text streaming, not terminal tool publishing
// Terminal tools publish their own events directly
⋮----
isFinalized(): boolean
⋮----
getSequenceNumber(): number
⋮----
/**
     * Get the total content accumulated by this publisher instance
     * since its creation or last finalization.
     */
getAccumulatedContent(): string
⋮----
// Private helper methods
private cancelScheduledFlush(): void
⋮----
private async publishScheduledContent(): Promise<void>
⋮----
// Capture the state into local variables immediately
⋮----
// Clear scheduled state even if we return early
⋮----
// Clear the shared state *before* the async operation
⋮----
// Create streaming response event (ephemeral kind 21111)
⋮----
streamingEvent.kind = EVENT_KINDS.STREAMING_RESPONSE; // Ephemeral streaming response kind
streamingEvent.content = this.accumulatedContent; // Send complete status, not just the delta
⋮----
// Tag the conversation
⋮----
// Add agent identifier
⋮----
// Add streaming metadata
⋮----
// Add voice mode tag if the triggering event has it
⋮----
// Update last flush time after successful publish
⋮----
// On failure, prepend content to the start of the pending buffer to be retried
⋮----
this.sequence--; // Roll back sequence number on failure
</file>

<file path="src/prompts/fragments/01-specialist-identity.ts">
import { fragmentRegistry } from "../core/FragmentRegistry";
import type { PromptFragment } from "../core/types";
import type { AgentInstance } from "@/agents/types";
⋮----
/**
 * Identity fragment for specialist agents ONLY.
 * No conditionals, no isOrchestrator checks.
 */
interface SpecialistIdentityArgs {
    agent: AgentInstance;
    projectTitle: string;
    projectOwnerPubkey: string;
}
⋮----
// Identity
⋮----
// Instructions
⋮----
// Project context
⋮----
// Specialist guidelines (what used to be in expertise-boundaries and domain-expert-guidelines)
⋮----
// Register the fragment
</file>

<file path="src/prompts/fragments/30-project-md.ts">
import { fragmentRegistry } from "@/prompts/core/FragmentRegistry";
import type { PromptFragment } from "@/prompts/core/types";
import fs from "node:fs";
import path from "node:path";
⋮----
interface ProjectMdArgs {
    projectPath?: string;
}
⋮----
// Ignore errors
⋮----
// Register the fragment
</file>

<file path="src/test-utils/index.ts">
/**
 * Test utilities for TENEX backend
 * 
 * This module provides comprehensive testing utilities including:
 * - Mock LLM service for deterministic E2E testing
 * - Mock factories for common objects
 * - Test environment helpers
 * - Assertion utilities
 */
⋮----
import { mock, expect } from "bun:test";
⋮----
import { tmpdir } from "node:os";
⋮----
/**
 * Create a temporary directory for testing
 */
export async function createTempDir(prefix = "tenex-test-"): Promise<string>
⋮----
/**
 * Clean up a temporary directory
 */
export async function cleanupTempDir(dirPath: string): Promise<void>
⋮----
// Ignore errors during cleanup
⋮----
/**
 * Reset all mocks and singletons
 */
export function resetAllMocks(): void
⋮----
// Reset singletons
⋮----
// eslint-disable-next-line @typescript-eslint/no-require-imports
⋮----
// Module might not be loaded
⋮----
/**
 * Wait for a condition to be true
 */
export async function waitFor(
    condition: () => boolean | Promise<boolean>,
    timeout = 5000,
    interval = 100
): Promise<void>
⋮----
/**
 * Mock file system operations
 */
export function mockFileSystem(files: Map<string, string>): Map<string, string>
⋮----
/**
 * Capture console output during tests
 */
export class ConsoleCapture
⋮----
start(): void
⋮----
stop(): void
⋮----
getLogs(): string[]
⋮----
getErrors(): string[]
⋮----
clear(): void
⋮----
/**
 * Custom assertions
 */
⋮----
/**
     * Assert that an async function throws an error
     */
async toThrowAsync(
        fn: () => Promise<any>,
        expectedError?: string | RegExp | Error
): Promise<void>
⋮----
/**
     * Assert that an array contains an object matching partial properties
     */
toContainObjectMatching<T>(
        array: T[],
        partial: Partial<T>
): void
</file>

<file path="README.md">
# TENEX

> **Orchestrate the orchestrators** - A revolutionary context-first development environment where AI agents collaborate autonomously to build software.

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Built on Nostr](https://img.shields.io/badge/Built%20on-Nostr-purple)](https://nostr.com)

## What is TENEX?

TENEX represents a paradigm shift in software development. If LLMs have fundamentally changed how we write code, shouldn't our development environments evolve too? TENEX answers this by replacing the traditional text editor with a **context-first environment** where *context*, not code, becomes the primary building block.

At its core, TENEX is a sophisticated **multi-agent orchestration system** built on the Nostr protocol. It enables autonomous AI agents to collaborate on complex software development tasks through intelligent routing, phase-based workflows, and continuous learning.

### Key Innovation: Invisible Orchestration

Unlike traditional AI assistants where you interact with a single entity, TENEX employs an **invisible orchestrator** pattern. The orchestrator silently routes your requests to specialized agents best suited for each task, creating a seamless experience where the right expertise appears exactly when needed.

## ✨ Key Features

### 🤖 **Multi-Agent Architecture**
- **Specialized Agents**: Built-in agents for orchestration, planning, execution, and project management
- **Dynamic Routing**: Intelligent task delegation based on agent capabilities and context
- **Parallel Execution**: Multiple agents can work simultaneously on different aspects of your project
- **Custom Agents**: Extensible system allowing you to define domain-specific experts

### 🔄 **Phase-Based Workflow**
Every interaction follows a structured lifecycle ensuring quality and completeness:
1. **Chat** → Initial conversation and understanding
2. **Brainstorm** → Creative exploration and ideation
3. **Plan** → Structured approach definition
4. **Execute** → Implementation and tool usage
5. **Verification** → Quality assurance and testing
6. **Chores** → Documentation and maintenance
7. **Reflection** → Learning capture and improvement

### 🧠 **Continuous Learning System**
- Agents capture and apply lessons from every interaction
- Cross-conversation knowledge sharing
- Self-improving behavior based on accumulated experience
- Persistent knowledge base stored on Nostr

### 🔧 **Powerful Tool System**
- **Built-in Tools**: File operations, code analysis, shell execution, Git integration
- **MCP Integration**: Model Context Protocol support for dynamic tool loading
- **Type-Safe**: Comprehensive validation and error handling
- **Composable**: Tools can be combined for complex operations

### 🌐 **Nostr-Native Architecture**
- **Decentralized by Design**: No central server, peer-to-peer agent communication
- **Cryptographic Identity**: Each project maintains its own nsec for secure context
- **Event Sourcing**: Complete audit trail of all agent actions
- **Resilient**: Continues operating even with network disruptions

### 🎯 **LLM Provider Agnostic**
- Support for OpenAI, Anthropic, Google, OpenRouter, and more
- Intelligent model selection based on task requirements
- Automatic failover and rate limiting
- Cost optimization through smart routing

## 🚀 Getting Started

### Prerequisites

- **Node.js** 18+ or **Bun** runtime
- **Git** for version control integration
- An API key for at least one LLM provider (OpenAI, Anthropic, etc.)

### Installation

```bash
# Clone the repository
git clone https://github.com/tenex-chat/tenex
cd tenex

# Install dependencies
bun install

# Configure your LLM provider
bun run setup:llm

# Start TENEX
bun run tenex
```

### Quick Start

1. **Create a new project** using the [TENEX Web Client](https://github.com/tenex-chat/web-client) or iOS client

2. **Example interaction**:
```
You: Create a REST API for a todo application with authentication

TENEX: [Orchestrator routes to Planner]
[Planner creates structured approach]
[Executor implements the API]
[Verification runs tests]
[Documentation is updated]
[Lessons are captured for future use]
```

## 📚 Documentation

### Architecture Guides
- [Workflow Management](./documentation/workflow-management-architecture.md) - High-level system overview
- [Agent Execution](./documentation/agent-execution-architecture.md) - How agents operate
- [Phase Management](./documentation/phase-management-architecture.md) - Workflow control system
- [Tool System](./documentation/tool-system-architecture.md) - Capability implementation
- [Learning System](./documentation/learning-system-internals.md) - Continuous improvement mechanics

### Developer Documentation
For detailed technical documentation, see the [documentation](./documentation/) directory.

## 🏗️ Project Structure

```
src/
├── agents/         # Agent system and execution
├── commands/       # CLI commands
├── conversations/  # Conversation management
├── daemon/         # Background processes
├── events/         # Nostr event definitions
├── llm/           # LLM provider integration
├── nostr/         # Nostr protocol layer
├── prompts/       # Prompt composition system
├── tools/         # Tool implementations
└── utils/         # Utility functions
```

## 🤝 Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

### Development Setup

```bash
# Run tests
bun test

# Run tests with coverage
bun test --coverage

# Type checking
bun run typecheck

# Linting
bun run lint

# Build for production
bun run build

# Watch mode for development
bun test --watch
```

## 🔮 What Makes TENEX Different?

### **Context Over Code**
Traditional IDEs optimize for code editing. TENEX optimizes for context management, recognizing that in the LLM era, maintaining and utilizing context effectively is more valuable than syntax highlighting.

### **Invisible Complexity**
The orchestrator operates behind the scenes, presenting a simple conversational interface while managing sophisticated multi-agent choreography underneath.

### **Quality by Design**
Mandatory verification and reflection phases ensure every task meets quality standards and contributes to the system's collective knowledge.

### **Truly Decentralized**
Built on Nostr from the ground up, not as an afterthought. This enables censorship-resistant, peer-to-peer agent networks with no single point of failure.

## 🎯 Use Cases

- **Rapid Prototyping**: Go from idea to working prototype through natural conversation
- **Code Migration**: Modernize legacy codebases with intelligent refactoring
- **Documentation**: Automatic generation and maintenance of technical documentation
- **Testing**: Comprehensive test generation and verification
- **Learning**: Agents that get better at your specific codebase over time

## 📈 Roadmap

- [ ] Web-based interface improvements
- [ ] Multi-model ensemble execution
- [ ] Real-time collaborative editing
- [ ] Advanced debugging and profiling tools

## 📄 License

MIT - see [LICENSE](LICENSE) file for details

## 📞 Contact & Support

- **GitHub Issues**: [Report bugs or request features](https://github.com/tenex-chat/tenex/issues)
- **Nostr**: Follow the project at `npub1tenex...` 
- **Documentation**: [Full documentation](https://docs.tenex.chat)

---

**Ready to experience the future of software development?** Create your first project using the [TENEX Web Client](https://github.com/tenex-chat/web-client) and let your AI agents handle the rest.

> "The best code is the code you don't have to write. The second best is code written by agents who learn from every line they produce." - TENEX Philosophy
</file>

<file path="src/agents/execution/completionHandler.ts">
import { getProjectContext } from "@/services/ProjectContext";
import type { Complete } from "@/tools/types";
import type { NostrPublisher } from "@/nostr/NostrPublisher";
import type { AgentInstance } from "@/agents/types";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { ConversationManager } from "@/conversations/ConversationManager";
⋮----
/**
 * Shared completion logic used by both the complete() tool and ClaudeBackend
 * Ensures consistent behavior when agents complete their tasks
 */
⋮----
export interface CompletionOptions {
    response: string;
    summary?: string;
    agent: AgentInstance;
    conversationId: string;
    publisher: NostrPublisher;
    triggeringEvent?: NDKEvent;
    conversationManager: ConversationManager;  // Required for orchestrator turn tracking
}
⋮----
conversationManager: ConversationManager;  // Required for orchestrator turn tracking
⋮----
/**
 * Handle agent task completion by preparing the event but not publishing it
 * The caller decides when to publish (immediately for ClaudeBackend, after metadata for ReasonActLoop)
 */
export async function handleAgentCompletion(options: CompletionOptions): Promise<
⋮----
// Check if this is completing a sub-task (NDKTask kind 1934)
⋮----
// This is a sub-task completion - respond to the task delegator
⋮----
// Build completion reply to the task
⋮----
reply.tag(["e", triggeringEvent.id, "", "reply"]);  // Reply to the task
reply.tag(["p", delegatorPubkey]);  // Notify the delegator
⋮----
// Return task completion
⋮----
// Regular conversation completion - respond to PM/orchestrator
⋮----
// No turn tracking needed - PM infers from conversation history
⋮----
// Build the event but don't publish
⋮----
// Add summary tag if provided
⋮----
// Return both completion and unpublished event
</file>

<file path="src/agents/execution/StreamStateManager.ts">
import type { ToolExecutionResult, Complete } from "@/tools/types";
import type { CompletionResponse } from "@/llm/types";
import type { StreamPublisher } from "@/nostr/NostrPublisher";
import type { NostrEvent } from "@nostr-dev-kit/ndk";
⋮----
/**
 * Represents the mutable state during stream processing
 */
export interface StreamingState {
    allToolResults: ToolExecutionResult[];
    termination: Complete | undefined;
    finalResponse: CompletionResponse | undefined;
    fullContent: string;
    streamPublisher: StreamPublisher | undefined;
    startedTools: Set<string>;
    loggedThinkingBlocks: Set<string>;
    deferredEvent?: NostrEvent; // The serialized event to publish after metadata arrives
}
⋮----
deferredEvent?: NostrEvent; // The serialized event to publish after metadata arrives
⋮----
/**
 * Manages the mutable state during LLM stream processing.
 * Provides controlled access and modifications to the streaming state.
 */
export class StreamStateManager
⋮----
constructor()
⋮----
/**
     * Create a fresh initial state
     */
private createInitialState(): StreamingState
⋮----
/**
     * Reset the state to initial values
     */
reset(): void
⋮----
/**
     * Append content to the accumulated full content
     */
appendContent(content: string): void
⋮----
/**
     * Get the current full content
     */
getFullContent(): string
⋮----
/**
     * Add a tool execution result
     */
addToolResult(result: ToolExecutionResult): void
⋮----
/**
     * Get all tool results
     */
getToolResults(): ToolExecutionResult[]
⋮----
/**
     * Get all tool results (alias for getToolResults)
     */
getAllToolResults(): ToolExecutionResult[]
⋮----
/**
     * Get the last tool result
     */
getLastToolResult(): ToolExecutionResult | null
⋮----
/**
     * Set the termination (complete)
     */
setTermination(termination: Complete): void
⋮----
/**
     * Get the termination
     */
getTermination(): Complete | undefined
⋮----
/**
     * Check if the stream has terminated
     */
hasTerminated(): boolean
⋮----
/**
     * Set the final response from the LLM
     */
setFinalResponse(response: CompletionResponse): void
⋮----
/**
     * Get the final response
     */
getFinalResponse(): CompletionResponse | undefined
⋮----
/**
     * Set the stream publisher
     */
setStreamPublisher(publisher: StreamPublisher): void
⋮----
/**
     * Get the stream publisher
     */
getStreamPublisher(): StreamPublisher | undefined
⋮----
/**
     * Mark a tool as started
     */
markToolStarted(toolCallId: string): void
⋮----
/**
     * Check if a tool has been started
     */
hasToolStarted(toolNamePattern: string): boolean
⋮----
/**
     * Mark a thinking block as logged (using its content hash)
     */
markThinkingBlockLogged(blockContent: string): void
⋮----
/**
     * Check if a thinking block has already been logged
     */
hasThinkingBlockBeenLogged(blockContent: string): boolean
⋮----
/**
     * Get the raw state (use sparingly, prefer specific methods)
     */
getRawState(): Readonly<StreamingState>
⋮----
/**
     * Set the deferred event (serialized NDKEvent to publish later)
     */
setDeferredEvent(serializedEvent: NostrEvent): void
⋮----
// Debug logging
⋮----
/**
     * Get the deferred event
     */
getDeferredEvent(): NostrEvent | undefined
⋮----
// Debug logging
⋮----
/**
     * Get a summary of the current state for logging
     */
getStateSummary(): Record<string, unknown>
⋮----
// Generic state management methods for extensibility
⋮----
/**
     * Set a custom state value
     */
setState(key: string, value: unknown): void
⋮----
/**
     * Get a custom state value
     */
getState(key: string): unknown
⋮----
/**
     * Check if a custom state exists
     */
hasState(key: string): boolean
⋮----
/**
     * Delete a custom state value
     */
deleteState(key: string): void
⋮----
/**
     * Get all custom state as an object
     */
getAllState(): Record<string, unknown>
⋮----
/**
     * Clear all custom state
     */
clear(): void
</file>

<file path="src/agents/constants.ts">
import type { AgentInstance } from "./types";
import { analyze } from "../tools/implementations/analyze";
import { lessonLearnTool } from "../tools/implementations/learn";
import { readPathTool } from "../tools/implementations/readPath";
import { completeTool } from "../tools/implementations/complete";
import { delegateTool } from "../tools/implementations/delegate";
import { PROJECT_MANAGER_AGENT_DEFINITION } from "./built-in/project-manager";
⋮----
// Agent slug constants
⋮----
/**
 * Get all available tools for an agent based on their role
 * All agents now have access to delegate for peer-to-peer collaboration
 */
export function getDefaultToolsForAgent(agent: AgentInstance): string[]
⋮----
// Base tools for all agents
⋮----
completeTool.name,  // All agents can complete tasks
delegateTool.name    // All agents can delegate to others
⋮----
// Special handling for project manager
⋮----
// Use the tools defined in the PROJECT_MANAGER_AGENT_DEFINITION
// This ensures consistency between the definition and runtime
⋮----
// Use PM's specific tool list which includes switch_phase
⋮----
// Ensure complete and delegate are included if not already
</file>

<file path="src/conversations/services/ConversationCoordinator.ts">
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { Phase } from "../phases";
import { PHASES } from "../phases";
import type { 
    Conversation, 
    ConversationMetadata, 
    PhaseTransition,
    AgentState
} from "../types";
import type { AgentInstance } from "@/agents/types";
import { Message } from "multi-llm-ts";
import { ConversationStore } from "./ConversationStore";
import type { IConversationPersistenceService } from "./ConversationPersistenceService";
import { PhaseManager, type PhaseTransitionContext } from "./PhaseManager";
import { ConversationEventProcessor } from "./ConversationEventProcessor";
import type { IAgentResolver } from "./AgentResolver";
import { AgentConversationContext } from "../AgentConversationContext";
import { MessageBuilder } from "../MessageBuilder";
import type { ExecutionQueueManager } from "../executionQueue";
import type { TracingContext } from "@/tracing";
import { createTracingContext, createPhaseExecutionContext } from "@/tracing";
import { createExecutionLogger } from "@/logging/ExecutionLogger";
import { buildPhaseInstructions, formatPhaseTransitionMessage } from "@/prompts/utils/phaseInstructionsBuilder";
import { logger } from "@/utils/logger";
import { ensureExecutionTimeInitialized } from "../executionTime";
⋮----
/**
 * Coordinates between all conversation services.
 * Single Responsibility: Orchestrate calls to specialized services.
 */
export class ConversationCoordinator
⋮----
// Context management
⋮----
constructor(
        store: ConversationStore,
        persistence: IConversationPersistenceService,
        phaseManager: PhaseManager,
        eventProcessor: ConversationEventProcessor,
        _agentResolver: IAgentResolver,
        executionQueueManager?: ExecutionQueueManager
)
⋮----
// Setup queue listeners if available
⋮----
/**
     * Initialize the coordinator
     */
async initialize(): Promise<void>
⋮----
/**
     * Create a new conversation from an event
     */
async createConversation(event: NDKEvent): Promise<Conversation>
⋮----
// Create tracing context
⋮----
// Store and persist
⋮----
/**
     * Get a conversation by ID
     */
getConversation(id: string): Conversation | undefined
⋮----
/**
     * Get a conversation by event ID
     */
getConversationByEvent(eventId: string): Conversation | undefined
⋮----
/**
     * Get all conversations
     */
getAllConversations(): Conversation[]
⋮----
/**
     * Add an event to a conversation
     */
async addEvent(conversationId: string, event: NDKEvent): Promise<void>
⋮----
/**
     * Update conversation metadata
     */
async updateMetadata(
        conversationId: string,
        metadata: Partial<ConversationMetadata>
): Promise<void>
⋮----
/**
     * Update conversation phase
     */
async updatePhase(
        id: string,
        phase: Phase,
        message: string,
        agentPubkey: string,
        agentName: string,
        reason?: string,
        summary?: string
): Promise<boolean>
⋮----
// Update conversation
⋮----
// Clear readFiles when transitioning from REFLECTION back to CHAT
⋮----
// Log phase transition
⋮----
// Handle queue status
⋮----
/**
     * Build messages for an agent
     */
async buildAgentMessages(
        conversationId: string,
        targetAgent: AgentInstance,
        triggeringEvent?: NDKEvent,
        handoff?: PhaseTransition
): Promise<
⋮----
// Get or create the agent context
⋮----
// Get or initialize the agent's state
⋮----
// Check if we need to show phase instructions
⋮----
// Build complete history
⋮----
// Handle phase transitions
⋮----
// Handle delegation responses if pending
⋮----
// Add handoff if present
⋮----
// Add the triggering event
⋮----
// Update state
⋮----
/**
     * Build orchestrator routing context
     */
async buildOrchestratorRoutingContext(
        conversationId: string,
        triggeringEvent?: NDKEvent
): Promise<OrchestratorRoutingContext>
⋮----
// Get original and most recent user request
⋮----
// Extract completion from triggering event if present
⋮----
// PM now infers routing context from conversation history
⋮----
/**
     * Update an agent's state
     */
async updateAgentState(
        conversationId: string,
        agentSlug: string,
        updates: Partial<AgentState>
): Promise<void>
⋮----
/**
     * Start a new orchestrator turn
     * @param agents Array of agent pubkeys for consistent identification
     */
⋮----
/**
     * Check if the current turn is complete
     * With NDKTask-based delegation, this always returns true since
     * agents won't be reactivated until all their delegated tasks complete
     */
isCurrentTurnComplete(_conversationId: string): boolean
⋮----
return true; // PM-centric routing with NDKTask handles this via pendingDelegation
⋮----
/**
     * Get the current turn for a conversation
     * With PM-centric routing, there are no explicit turns to track
     */
getCurrentTurn(_conversationId: string): null
⋮----
return null; // No turn tracking in PM-centric routing
⋮----
/**
     * Archive a conversation
     */
async archiveConversation(conversationId: string): Promise<void>
⋮----
/**
     * Search conversations
     */
async searchConversations(query: string): Promise<Conversation[]>
⋮----
/**
     * Clean up and save all conversations
     */
async cleanup(): Promise<void>
⋮----
/**
     * Complete a conversation
     */
async completeConversation(conversationId: string): Promise<void>
⋮----
/**
     * Get the tracing context for a conversation
     */
getTracingContext(conversationId: string): TracingContext | undefined
⋮----
/**
     * Get phase history for a conversation
     */
getPhaseHistory(conversationId: string): NDKEvent[]
⋮----
/**
     * Get execution queue manager (if available)
     */
getExecutionQueueManager(): ExecutionQueueManager | undefined
⋮----
/**
     * Set execution queue manager
     */
setExecutionQueueManager(manager: ExecutionQueueManager): void
⋮----
/**
     * Clean up conversation metadata
     */
cleanupConversationMetadata(conversationId: string): void
⋮----
// Private helper methods
⋮----
private async loadConversations(): Promise<void>
⋮----
// Ensure agentStates is a Map
⋮----
private getOrCreateTracingContext(conversationId: string): TracingContext
⋮----
private getOrCreateAgentContext(conversationId: string, agentSlug: string): AgentConversationContext
⋮----
private setupQueueListeners(): void
⋮----
// Log timeout warning using execution logger
</file>

<file path="src/conversations/types.ts">
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type { Phase } from "./phases";
⋮----
// Simplified agent state to track what an agent has seen
export interface AgentState {
    lastProcessedMessageIndex: number; // Index into Conversation.history
    claudeSessionId?: string; // Claude Code session ID (if per-agent per-conversation)
    lastSeenPhase?: Phase; // Track the last phase this agent operated in
    
    // Delegation tracking - when agent is waiting for task completions from other agents
    pendingDelegation?: {
        taskIds: string[];           // NDKTask IDs we're waiting for
        tasks: Map<string, {         // Task details keyed by task ID (runtime only)
            recipientPubkey: string;
            status: string;
            response?: string;
        }>;
        originalRequest: string;     // What we asked them
        timestamp: number;           // When delegation started
    };
}
⋮----
lastProcessedMessageIndex: number; // Index into Conversation.history
claudeSessionId?: string; // Claude Code session ID (if per-agent per-conversation)
lastSeenPhase?: Phase; // Track the last phase this agent operated in
⋮----
// Delegation tracking - when agent is waiting for task completions from other agents
⋮----
taskIds: string[];           // NDKTask IDs we're waiting for
tasks: Map<string, {         // Task details keyed by task ID (runtime only)
⋮----
originalRequest: string;     // What we asked them
timestamp: number;           // When delegation started
⋮----
export interface Conversation {
    id: string;
    title: string;
    phase: Phase;
    history: NDKEvent[]; // The SINGLE source of truth for all events/messages
    agentStates: Map<string, AgentState>; // Track what each agent has seen in 'history'
    phaseStartedAt?: number;
    metadata: ConversationMetadata;
    phaseTransitions: PhaseTransition[]; // First-class phase transition history

    // Execution time tracking
    executionTime: {
        totalSeconds: number;
        currentSessionStart?: number;
        isActive: boolean;
        lastUpdated: number;
    };
}
⋮----
history: NDKEvent[]; // The SINGLE source of truth for all events/messages
agentStates: Map<string, AgentState>; // Track what each agent has seen in 'history'
⋮----
phaseTransitions: PhaseTransition[]; // First-class phase transition history
⋮----
// Execution time tracking
⋮----
export interface ConversationMetadata {
    branch?: string; // Git branch for execution phase
    summary?: string; // Current understanding/summary
    requirements?: string; // Captured requirements
    plan?: string; // Approved plan
    readFiles?: string[]; // Files read during this conversation (for write_context_file security)
    projectPath?: string; // Project path for debug commands
    last_user_message?: string; // Last message from the user
    referencedArticle?: {
        title: string;
        content: string;
        dTag: string;
    }; // NDKArticle referenced by kind:11 event (30023)
    queueStatus?: {
        isQueued: boolean;
        position: number;
        estimatedWait: number;
        message: string;
    }; // Execution queue status when waiting for EXECUTE phase
}
⋮----
branch?: string; // Git branch for execution phase
summary?: string; // Current understanding/summary
requirements?: string; // Captured requirements
plan?: string; // Approved plan
readFiles?: string[]; // Files read during this conversation (for write_context_file security)
projectPath?: string; // Project path for debug commands
last_user_message?: string; // Last message from the user
⋮----
}; // NDKArticle referenced by kind:11 event (30023)
⋮----
}; // Execution queue status when waiting for EXECUTE phase
⋮----
export interface PhaseTransition {
    from: Phase;
    to: Phase;
    message: string; // Comprehensive context from the transition
    timestamp: number;
    agentPubkey: string; // Track which agent initiated
    agentName: string; // Human-readable agent name
    reason?: string; // Brief description (optional)

    // Enhanced handoff fields
    summary?: string; // State summary for receiving agent
}
⋮----
message: string; // Comprehensive context from the transition
⋮----
agentPubkey: string; // Track which agent initiated
agentName: string; // Human-readable agent name
reason?: string; // Brief description (optional)
⋮----
// Enhanced handoff fields
summary?: string; // State summary for receiving agent
</file>

<file path="src/daemon/ProjectManager.ts">
import { exec } from "node:child_process";
⋮----
import { promisify } from "node:util";
import { LLMConfigEditor } from "@/llm/LLMConfigEditor";
import { configService, setProjectContext } from "@/services";
import type { TenexConfig } from "@/services/config/types";
import { initializeToolLogger } from "@/tools/toolLogger";
import { ensureTenexInGitignore, initializeGitRepository } from "@/utils/git";
import { logger } from "@/utils/logger";
import { toKebabCase } from "@/utils/string";
import { fetchAgentDefinition } from "@/utils/agentFetcher";
import { installMCPServerFromEvent } from "@/services/mcp/mcpInstaller";
// createAgent functionality has been moved to AgentRegistry
import type NDK from "@nostr-dev-kit/ndk";
import type { NDKProject } from "@nostr-dev-kit/ndk";
import { NDKMCPTool } from "@/events/NDKMCPTool";
import chalk from "chalk";
⋮----
export interface ProjectData {
    identifier: string;
    pubkey: string;
    naddr: string;
    title: string;
    description?: string;
    repoUrl?: string;
    hashtags: string[];
    agentEventIds: string[];
    mcpEventIds: string[];
    createdAt?: number;
    updatedAt?: number;
}
⋮----
export interface IProjectManager {
    initializeProject(projectPath: string, naddr: string, ndk: NDK): Promise<ProjectData>;
    loadProject(projectPath: string): Promise<ProjectData>;
    ensureProjectExists(identifier: string, naddr: string, ndk: NDK): Promise<string>;
    loadAndInitializeProjectContext(projectPath: string, ndk: NDK): Promise<void>;
}
⋮----
initializeProject(projectPath: string, naddr: string, ndk: NDK): Promise<ProjectData>;
loadProject(projectPath: string): Promise<ProjectData>;
ensureProjectExists(identifier: string, naddr: string, ndk: NDK): Promise<string>;
loadAndInitializeProjectContext(projectPath: string, ndk: NDK): Promise<void>;
⋮----
export class ProjectManager implements IProjectManager
⋮----
constructor(projectsPath?: string)
async initializeProject(projectPath: string, naddr: string, ndk: NDK): Promise<ProjectData>
⋮----
// Fetch project from Nostr
⋮----
// Clone repository if provided, otherwise create directory and init git
⋮----
// Create project directory and initialize git
⋮----
// Ensure .tenex is in .gitignore
⋮----
// Create project structure (without nsec in config)
⋮----
// Initialize agent registry
⋮----
// Load the registry first to get global agents loaded
⋮----
// Fetch and save agent and MCP definitions
⋮----
// Reload to pick up any new agents that were added
⋮----
// Now set the project context once with all agents loaded
⋮----
// Republish kind:0 events for all agents
⋮----
// Check if LLM configuration is needed
⋮----
async loadProject(projectPath: string): Promise<ProjectData>
⋮----
// For now, return a simplified version without decoding naddr
// The identifier and pubkey will be filled when the project is fetched from Nostr
⋮----
identifier: config.projectNaddr, // Use naddr as identifier temporarily
pubkey: "", // Will be filled when fetched from Nostr
⋮----
title: "Untitled Project", // This should come from NDKProject
⋮----
hashtags: [], // This should come from NDKProject
⋮----
createdAt: undefined, // This should come from NDKProject
updatedAt: undefined, // This should come from NDKProject
⋮----
async ensureProjectExists(identifier: string, naddr: string, ndk: NDK): Promise<string>
⋮----
// Check if project already exists
⋮----
// Initialize the project
⋮----
async loadAndInitializeProjectContext(projectPath: string, ndk: NDK): Promise<void>
⋮----
// Load project configuration
⋮----
// Fetch project from Nostr
⋮----
// Load agents using AgentRegistry
⋮----
// Get all agents from registry
⋮----
// Set slug on each agent
⋮----
// Initialize ProjectContext
⋮----
// Initialize ConversationManager with ExecutionQueueManager for CLI commands
⋮----
// Create and attach ExecutionQueueManager
⋮----
// Republish kind:0 events for all agents on project load
⋮----
// Initialize tool logger for tracing tool executions
⋮----
// Only log if it's not a missing project configuration error
// The MCP server command will handle this specific error with a friendlier message
⋮----
private async fetchProject(naddr: string, ndk: NDK): Promise<NDKProject>
⋮----
private projectToProjectData(project: NDKProject): ProjectData
⋮----
private async cloneRepository(repoUrl: string, projectPath: string): Promise<void>
⋮----
private async createProjectStructure(
        projectPath: string,
        projectData: ProjectData
): Promise<void>
⋮----
// Create project config (without nsec - it's now in agents.json)
⋮----
private async fetchAndSaveCapabilities(
        projectPath: string,
        project: ProjectData,
        ndk: NDK,
        ndkProject: NDKProject | undefined,
        agentRegistry: any
): Promise<void>
⋮----
// Process agent tags
⋮----
// Generate a slug for the agent (kebab-case of the name)
⋮----
// Use AgentRegistry.ensureAgent to handle all file operations
⋮----
// Process MCP tags
⋮----
private async projectExists(projectPath: string): Promise<boolean>
⋮----
// Also verify that config.json exists and has projectNaddr
⋮----
private async checkAndRunLLMConfigWizard(projectPath: string): Promise<void>
⋮----
// Check if there are any LLM configurations
⋮----
// Don't throw - LLM configuration is not critical for project initialization
</file>

<file path="src/event-handler/reply.ts">
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import chalk from "chalk";
import type { AgentExecutor } from "../agents/execution/AgentExecutor";
import { ExecutionConfig } from "../agents/execution/constants";
import type { ExecutionContext } from "../agents/execution/types";
import type { ConversationManager, Conversation, AgentState } from "../conversations";
import { NostrPublisher } from "../nostr";
import { isEventFromUser } from "../nostr/utils";
import { getProjectContext } from "../services";
import type { AgentInstance } from "../agents/types";
import { formatAnyError } from "../utils/error-formatter";
import { logger } from "../utils/logger";
⋮----
interface EventHandlerContext {
    conversationManager: ConversationManager;
    agentExecutor: AgentExecutor;
}
⋮----
interface TaskCompletionResult {
    shouldReactivate: boolean;
    targetAgent?: AgentInstance;
    syntheticEvent?: NDKEvent;
}
⋮----
/**
 * Main entry point for handling chat messages
 */
export const handleChatMessage = async (
    event: NDKEvent,
    context: EventHandlerContext
): Promise<void> =>
⋮----
// Extract p-tags to identify mentioned agents
⋮----
// Check if this message is directed to the system (project or agents)
⋮----
// This is a reply within an existing conversation
⋮----
/**
 * Find the conversation for a reply event, handling task mappings
 */
async function findConversationForReply(
    event: NDKEvent,
    conversationManager: ConversationManager
): Promise<
⋮----
// If no conversation found and this is a reply to an NDKTask (K tag = 1934)
⋮----
// First check if we have a task mapping for this task
⋮----
// Fallback: The task itself might be the conversation root
⋮----
/**
 * Handle orphaned replies by creating a new conversation
 */
async function handleOrphanedReply(
    event: NDKEvent,
    conversationManager: ConversationManager,
    mentionedPubkeys: string[]
): Promise<Conversation | undefined>
⋮----
// Create a synthetic root event based on the reply
⋮----
id: convRoot || event.id, // Use conversation root if available, otherwise use the reply's ID
⋮----
tags: event.tags.filter(tag => tag[0] !== "E" && tag[0] !== "e"), // Remove reply tags
⋮----
// Add the actual reply event to the conversation history
⋮----
/**
 * Determine which agent should handle the event
 */
function determineTargetAgent(
    event: NDKEvent,
    mentionedPubkeys: string[],
    projectManager: AgentInstance
): AgentInstance
⋮----
let targetAgent = projectManager; // Default to PM for coordination
⋮----
// Check for p-tagged agents regardless of sender
⋮----
// Find the first p-tagged system agent
⋮----
/**
 * Process a task completion event and update delegation state
 */
async function processTaskCompletion(
    event: NDKEvent,
    conversation: Conversation,
    conversationManager: ConversationManager
): Promise<TaskCompletionResult>
⋮----
// Check all agents for pending delegations that include this task
⋮----
// Update the task status
⋮----
// Check if all tasks are complete
⋮----
// Synthesize responses and reactivate agent
⋮----
// Log progress
⋮----
/**
 * Synthesize task responses and prepare for agent reactivation
 */
async function synthesizeAndReactivate(
    agentState: AgentState,
    agentSlug: string,
    conversation: Conversation,
    conversationManager: ConversationManager,
    event: NDKEvent,
    projectCtx: ReturnType<typeof getProjectContext>
): Promise<TaskCompletionResult>
⋮----
// Synthesize all responses
⋮----
// Clear the pending delegation
⋮----
// Prepare for reactivation
⋮----
// Create a synthetic event with the synthesized responses
⋮----
// Add to conversation
⋮----
/**
 * Check for recent phase transitions that might be handoffs
 */
function getRecentHandoff(conversation: Conversation)
⋮----
// If this transition was very recent (within last 30 seconds) and has handoff info
⋮----
/**
 * Execute the agent with proper error handling
 */
async function executeAgent(
    executionContext: ExecutionContext,
    agentExecutor: AgentExecutor,
    conversation: Conversation,
    conversationManager: ConversationManager,
    projectManager: AgentInstance,
    event: NDKEvent
): Promise<void>
⋮----
// Check if it's an insufficient credits error
⋮----
// Create NostrPublisher to publish error
⋮----
/**
 * Main reply handling logic - orchestrates all the helper functions
 */
async function handleReplyLogic(
    event: NDKEvent,
    { conversationManager, agentExecutor }: EventHandlerContext,
    mentionedPubkeys: string[]
): Promise<void>
⋮----
// Find the conversation this reply belongs to
⋮----
// Handle orphaned replies if no conversation found
⋮----
// Add event to conversation history
⋮----
// Get project context and PM
⋮----
// Determine which agent should handle this event
⋮----
// Skip if the target agent is the same as the sender (prevent self-reply loops)
⋮----
// Check if this is a task completion event
⋮----
// Still waiting for more completions
⋮----
// Check for recent phase transition handoffs
⋮----
// Extract claude-session from the event or use mapped session
⋮----
// Build execution context
⋮----
agentExecutor, // Pass the executor so continue() can use it
⋮----
// Add handoff if available
⋮----
// Execute with proper error handling
</file>

<file path="src/llm/callLogger.ts">
import { join } from "node:path";
import type { CompletionRequest, CompletionResponse, ResolvedLLMConfig } from "./types";
⋮----
export interface LLMCallLogEntry {
    timestamp: string;
    timestampMs: number;
    requestId: string;
    duration?: number;
    durationMs?: number;

    // Configuration context
    configKey: string;
    config: {
        provider: string;
        model: string;
        baseUrl?: string;
        enableCaching?: boolean;
        temperature?: number;
        maxTokens?: number;
    };

    // Request context
    agentName?: string;
    context?: {
        configName?: string;
        agentName?: string;
    };

    // Complete request data
    request: {
        messages: Array<{
            role: string;
            content: string;
            contentLength: number;
        }>;
        options?: Record<string, unknown>;
        messageCount: number;
        totalRequestLength: number;
    };

    // Complete response data (if successful)
    response?: {
        content?: string;
        contentLength?: number;
        toolCalls?: Array<{
            name: string;
            params: unknown;
            paramsLength: number;
        }>;
        toolCallCount: number;
        usage?: {
            promptTokens?: number;
            completionTokens?: number;
            totalTokens?: number;
            cost?: number;
        };
    };

    // Error data (if failed)
    error?: {
        message: string;
        stack?: string;
        type: string;
    };

    // Status
    status: "success" | "error";

}
⋮----
// Configuration context
⋮----
// Request context
⋮----
// Complete request data
⋮----
// Complete response data (if successful)
⋮----
// Error data (if failed)
⋮----
// Status
⋮----
export class LLMCallLogger
⋮----
constructor(projectPath: string)
⋮----
private async ensureLogDirectory(): Promise<void>
⋮----
// Ignore if directory already exists
⋮----
private getLogFileName(agentName?: string): string
⋮----
const date = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
⋮----
// Sanitize agent name for filename
⋮----
private getLogFilePath(agentName?: string): string
⋮----
private generateRequestId(configKey: string): string
⋮----
async logLLMCall(
        configKey: string,
        config: ResolvedLLMConfig,
        request: CompletionRequest,
        result: { response?: CompletionResponse; error?: Error },
        performance: { startTime: number; endTime: number }
): Promise<void>
⋮----
// Calculate total request length
⋮----
// Build log entry
⋮----
duration: Math.round((durationMs / 1000) * 100) / 100, // seconds with 2 decimals
⋮----
// Trim system prompt if it's the first message and longer than 1000 chars
⋮----
// Parse JSON content for orchestrator to make logs more readable
⋮----
content = parsed; // Store as object, not string
⋮----
// Not JSON or parsing failed, keep as-is
⋮----
// Add response data if successful
⋮----
// Try to parse response content as JSON if possible
⋮----
responseContent = parsed; // Store as object, not string
⋮----
// Not JSON or parsing failed, keep as-is
⋮----
cost: undefined, // Cost calculation would need to be implemented based on model pricing
⋮----
// Add error data if failed
⋮----
// Write to JSONL file
⋮----
// Don't let logging errors break the main flow
⋮----
// Singleton instance
⋮----
export function initializeLLMLogger(projectPath: string): LLMCallLogger
⋮----
export function getLLMLogger(): LLMCallLogger | null
</file>

<file path="src/test-utils/mock-llm/MockLLMService.ts">
import type { 
    LLMService, 
    Message,
    CompletionRequest,
    CompletionResponse,
    StreamEvent
} from "@/llm/types";
import type { MockLLMConfig, MockLLMResponse } from "./types";
import { conversationalLogger } from "../conversational-logger";
⋮----
export class MockLLMService implements LLMService
⋮----
// Context tracking for enhanced triggers
⋮----
constructor(config: MockLLMConfig =
⋮----
// Load responses from scenarios
⋮----
// Sort by priority
⋮----
async complete(request: CompletionRequest): Promise<CompletionResponse>
⋮----
// Simulate delay if specified
⋮----
// Convert to CompletionResponse format that matches multi-llm-ts v4
// LlmResponse expects toolCalls with LlmToolCallInfo[] structure (name, params, result)
⋮----
// Convert our mock format to LlmToolCallInfo format
⋮----
// Format with function as string
⋮----
async *stream(request: CompletionRequest): AsyncIterable<StreamEvent>
⋮----
// Simulate streaming content
⋮----
// Send tool calls
⋮----
// Send completion event
⋮----
private findMatchingResponse(messages: Message[], model: string): MockLLMResponse['response']
⋮----
// Extract agent name and phase from system prompt
⋮----
// Get conversation context
⋮----
// Update agent iteration count
⋮----
// Find matching response
⋮----
// Check all trigger conditions
⋮----
continue; // No user message, but trigger expects one
⋮----
// All conditions matched
⋮----
// Log the response using conversational logger
⋮----
// Return default response
⋮----
private extractAgentName(systemPrompt: string): string
⋮----
// Try multiple patterns to extract agent name
⋮----
// Handle special cases
if (!name || name === 'the') continue; // Skip if we accidentally matched "the"
⋮----
// Check for specific agent keywords
⋮----
private extractPhase(systemPrompt: string): string
⋮----
// Try multiple patterns to extract phase
⋮----
private recordRequest(
        messages: Message[], 
        model: string, 
        response: MockLLMResponse['response']
): void
⋮----
// Helper methods for testing
⋮----
addResponse(response: MockLLMResponse): void
⋮----
getRequestHistory(): Array<
⋮----
clearHistory(): void
⋮----
// Method to update context (called by test harness)
updateContext(updates: {
        conversationId?: string;
        lastContinueCaller?: string;
        iteration?: number;
        lastAgentExecuted?: string;
}): void
⋮----
private getOrCreateContext(conversationId: string):
⋮----
private extractConversationId(messages: Message[]): string
⋮----
// Try to extract conversation ID from messages
// For now, use a default ID
</file>

<file path="src/test-utils/mock-factories.ts">
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
import type { AgentInstance } from "@/agents/types";
import type { ExecutionContext } from "@/agents/execution/types";
import type { Conversation } from "@/conversations/types";
import type { Phase } from "@/conversations/phases";
import { PHASES } from "@/conversations/phases";
import type { ToolCall } from "@/llm/types";
import { EVENT_KINDS } from "@/llm/types";
⋮----
/**
 * Factory functions for creating mock objects in tests
 */
⋮----
/**
 * MockNostrEvent class that implements the serialize method required by FileSystemAdapter
 */
export class MockNostrEvent implements Partial<NDKEvent>
⋮----
constructor(overrides?: Partial<NDKEvent>)
⋮----
serialize(includeSignature?: boolean, includeId?: boolean): string
⋮----
tagValue(tagName: string): string | undefined
⋮----
static deserialize(ndk: NDK, serialized: string): MockNostrEvent
⋮----
export function createMockNDKEvent(overrides?: Partial<NDKEvent>): NDKEvent
⋮----
export function createMockAgent(overrides?: Partial<AgentInstance>): AgentInstance
⋮----
export function createMockConversation(overrides?: Partial<Conversation>): Conversation
⋮----
export function createMockExecutionContext(overrides?: Partial<ExecutionContext>): ExecutionContext
⋮----
// Create mock publisher and conversation manager
⋮----
export function createMockToolCall(overrides?: Partial<ToolCall>): ToolCall
⋮----
/**
 * Create a builder for complex mock objects
 */
export class MockBuilder<T>
⋮----
with<K extends keyof T>(key: K, value: T[K]): this
⋮----
build(defaults: T): T
⋮----
// Usage example:
// const agent = new MockBuilder<AgentInstance>()
//     .with('name', 'TestAgent')
//     .with('allowedTools', ['test-tool'])
//     .build(createMockAgent());
</file>

<file path="src/tools/implementations/complete.ts">
import type { Termination } from "../types";
import { success, createToolDefinition } from "../types";
import { z } from "zod";
import { handleAgentCompletion } from "@/agents/execution/completionHandler";
⋮----
/**
 * Complete tool - signals task completion and returns control to the delegating agent
 * 
 * IMPORTANT: This tool returns control to whoever delegated to you (PM or another agent).
 * Use this when:
 * - You've completed your assigned task
 * - You need to report back with results
 * - You've gathered enough information to move forward (e.g., requirements are clear)
 * 
 * DO NOT use this for conversational responses - just respond normally for those.
 * YOUR JOB IS NOT DONE UNTIL YOU EXPLICITLY USE THIS TOOL
 */
⋮----
// Use the shared completion handler to get both completion and event
⋮----
// Serialize the event for passing through tool layer
⋮----
// Debug logging
⋮----
// Return success with completion and serialized event
</file>

<file path="src/tools/implementations/learn.ts">
import { NDKAgentLesson } from "@/events/NDKAgentLesson";
import { getNDK } from "@/nostr";
import { getProjectContext } from "@/services/ProjectContext";
import { formatAnyError } from "@/utils/error-formatter";
import { logger } from "@/utils/logger";
import { z } from "zod";
import type { Tool } from "../types";
import { createZodSchema, success, failure } from "../types";
⋮----
interface LessonLearnInput {
    title: string;
    lesson: string;
    detailed?: string;
    category?: string;
    hashtags?: string[];
}
⋮----
interface LessonLearnOutput {
    message: string;
    eventId: string;
    title: string;
    hasDetailed: boolean;
}
⋮----
// Create the lesson event
⋮----
// Add optional fields if provided
⋮----
// Add reference to the agent event if available
⋮----
// Add project tag for scoping
⋮----
// Sign and publish the event
</file>

<file path="src/tenex.ts">
import { logError } from "@/utils/logger";
import { handleCliError } from "@/utils/cli-error";
// CLI entry point for TENEX
import { Command } from "commander";
import { agentCommand } from "./commands/agent/index";
import { daemonCommand } from "./commands/daemon";
import { runDebugSystemPrompt } from "./commands/debug/index";
import { inventoryCommand } from "./commands/inventory/index";
import { mcpCommand } from "./commands/mcp/index";
import { projectCommand } from "./commands/project/index";
import { queueCommand } from "./commands/queue/index";
import { setupCommand } from "./commands/setup/index";
import { initNDK } from "./nostr/ndkClient";
import { PHASES } from "./conversations/phases";
⋮----
// Add main commands
⋮----
// Add debug command
⋮----
// Initialize NDK before parsing commands
export async function main(): Promise<void>
⋮----
// Only run if called directly (not imported)
</file>

<file path="src/agents/built-in/project-manager.ts">
import { writeContextFileTool } from "@/tools/implementations/writeContextFile";
import type { StoredAgentData } from "../types";
import { readPathTool } from "@/tools/implementations/readPath";
⋮----
/**
 * Default project manager agent definition
 * This agent represents the project manager focused on deep project knowledge
 * and understanding the project's architecture, dependencies, and context.
 */
⋮----
"switch_phase", // EXCLUSIVE to PM for workflow orchestration
</file>

<file path="src/agents/execution/ToolStreamHandler.ts">
import type { NostrPublisher } from "@/nostr/NostrPublisher";
import { StreamPublisher } from "@/nostr/NostrPublisher";
import type { TracingLogger } from "@/tracing";
import type { ExecutionContext } from "./types";
import type { ExecutionLogger } from "@/logging/ExecutionLogger";
import type { ToolExecutionResult } from "@/tools/executor";
import { StreamStateManager } from "./StreamStateManager";
import { ExecutionConfig } from "./constants";
import { formatAnyError, formatToolError } from "@/utils/error-formatter";
import { deserializeToolResult, isSerializedToolResult } from "@/llm/ToolResult";
import { isComplete } from "./control-flow-types";
import type { ToolName } from "@/tools/registry";
⋮----
/**
 * Handles tool-related events in the LLM stream.
 * Responsible for processing tool_start and tool_complete events,
 * managing tool descriptions, publishing typing indicators, and error handling.
 */
export class ToolStreamHandler
⋮----
constructor(
⋮----
/**
     * Handle a tool_start event
     */
async handleToolStartEvent(
        streamPublisher: StreamPublisher | undefined,
        publisher: NostrPublisher | undefined,
        toolName: string,
        toolArgs: Record<string, unknown>,
        tracingLogger: TracingLogger,
        context?: ExecutionContext
): Promise<void>
⋮----
// Create a unique ID for this tool call
⋮----
// Log tool execution start
⋮----
// Finalize the stream if there's any buffered content
// This ensures any content generated before tool use is published as a complete reply
⋮----
// Check the content accumulated within the streamPublisher itself
⋮----
// Create a new stream publisher for subsequent content
⋮----
// Just flush if no content
⋮----
// Publish typing indicator with tool information
⋮----
/**
     * Handle a tool_complete event
     * @returns true if this was a terminal tool (continue, complete)
     */
async handleToolCompleteEvent(
        event: { tool: string; result: unknown },
        streamPublisher: StreamPublisher | undefined,
        publisher: NostrPublisher | undefined,
        tracingLogger: TracingLogger,
        context: ExecutionContext
): Promise<boolean>
⋮----
// Parse the tool result first to get metadata
⋮----
// Check if this tool never sent a tool_start event
// Pass the tool result so we can use metadata if available
⋮----
// Add result to state
⋮----
// Log tool execution complete
⋮----
// Publish error if tool failed
⋮----
// Process the tool result (update state with continue/termination)
⋮----
// Flush stream and stop typing indicator
⋮----
// Check if this is a terminal tool
⋮----
/**
     * Check if tool never sent a start event and handle it
     */
private async handleMissingToolStart(
        toolName: string,
        toolResult: ToolExecutionResult,
        publisher: NostrPublisher | undefined,
        tracingLogger: TracingLogger,
        _context: ExecutionContext
): Promise<void>
⋮----
// First try to use metadata from the tool result
⋮----
// Try to generate a message from executed args
⋮----
// Fall back to generic message
⋮----
// Brief delay to ensure the typing indicator is visible
⋮----
/**
     * Parse tool result from event
     */
private parseToolResult(event:
⋮----
// Tool results must include the typed result
⋮----
/**
     * Log tool completion with ExecutionLogger
     */
private logToolComplete(
        toolResult: ToolExecutionResult,
        toolName: string,
        context: ExecutionContext
): void
⋮----
// We don't have the exact start time, so use a reasonable estimate
⋮----
/**
     * Publish tool error if execution failed
     */
private async publishToolError(
        toolResult: ToolExecutionResult,
        toolName: string,
        publisher: NostrPublisher | undefined,
        tracingLogger: TracingLogger
): Promise<void>
⋮----
/**
     * Process tool result and update state
     */
private processToolResult(
        toolResult: ToolExecutionResult,
        tracingLogger: TracingLogger,
        _context: ExecutionContext
): void
⋮----
// Check if it's a termination
⋮----
// Store the serialized event if present (for deferred publishing)
⋮----
/**
     * Check if tool result is terminal (complete)
     */
private isTerminalResult(result: ToolExecutionResult): boolean
⋮----
/**
     * Get human-readable description for a tool
     */
private getToolDescription(toolName: string, args: Record<string, unknown>): string
⋮----
/**
     * Tool description generators
     */
private getToolDescriptions(): Partial<Record<ToolName | 'default', (args: Record<string, unknown>) => string>>
⋮----
// Core tool operations
⋮----
// Control flow
⋮----
// MCP tools
⋮----
// For MCP tools, try to create a descriptive message
</file>

<file path="src/commands/run/SubscriptionManager.ts">
import {
    addProcessedEvent,
    clearProcessedEvents,
    flushProcessedEvents,
    hasProcessedEvent,
    loadProcessedEvents,
} from "@/commands/run/processedEventTracking";
import type { EventHandler } from "@/event-handler";
import { NDKAgentLesson } from "@/events/NDKAgentLesson";
import { EVENT_KINDS } from "@/llm/types";
import { getNDK } from "@/nostr/ndkClient";
import { getProjectContext } from "@/services";
import { logger } from "@/utils/logger";
import {
    type NDKEvent,
    type NDKFilter,
    type NDKSubscription,
    filterAndRelaySetFromBech32,
} from "@nostr-dev-kit/ndk";
import chalk from "chalk";
⋮----
export class SubscriptionManager
⋮----
constructor(eventHandler: EventHandler, projectPath: string)
⋮----
async start(): Promise<void>
⋮----
// Load previously processed event IDs from disk
⋮----
// 1. Subscribe to project updates (NDKProject events)
⋮----
// 2. Subscribe to agent lessons
⋮----
// 3. Subscribe to all project-related events
⋮----
// 4. Subscribe to spec replies (kind 1111 with #K:30023)
⋮----
private async subscribeToProjectUpdates(): Promise<void>
⋮----
// Get all agent pubkeys
⋮----
// Create filters array
⋮----
// Add filter for agent pubkeys if any exist
⋮----
private async subscribeToAgentLessons(): Promise<void>
⋮----
// Get all agent pubkeys
⋮----
// Create filter for agent lessons
⋮----
// Log initial load completion
⋮----
// Log lesson distribution
⋮----
private async subscribeToProjectEvents(): Promise<void>
⋮----
// Filter for all events that tag this project
⋮----
private async subscribeToSpecReplies(): Promise<void>
⋮----
// Subscribe to spec replies (kind 1111 with #K:30023)
⋮----
// Use the A tag value as conversationId for routing
⋮----
// Route as a normal conversation event
⋮----
private async handleIncomingEvent(event: NDKEvent, source: string): Promise<void>
⋮----
// Check for duplicate events
⋮----
// Mark as processed
⋮----
// Log receipt
⋮----
async stop(): Promise<void>
⋮----
// Flush any pending saves to disk before stopping
</file>

<file path="src/conversations/persistence/FileSystemAdapter.ts">
import { ensureDirectory, fileExists, readJsonFile, writeJsonFile } from "@/lib/fs";
import { getNDK } from "@/nostr/ndkClient";
import { logger } from "@/utils/logger";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import type { AgentState, Conversation } from "../types";
import type { Phase } from "../phases";
import {
    type AgentStateSchema,
    MetadataFileSchema,
    SerializedConversationSchema,
} from "./schemas";
import type { z } from "zod";
import type {
    ConversationMetadata,
    ConversationPersistenceAdapter,
    ConversationSearchCriteria,
} from "./types";
⋮----
export class FileSystemAdapter implements ConversationPersistenceAdapter
⋮----
constructor(projectPath: string)
⋮----
async initialize(): Promise<void>
⋮----
// Initialize metadata file if it doesn't exist
⋮----
async save(conversation: Conversation): Promise<void>
⋮----
// Convert agentStates Map to a plain object for serialization
⋮----
// Serialize NDKEvents to a storable format
⋮----
// Update metadata
⋮----
async load(conversationId: string): Promise<Conversation | null>
⋮----
// Check archive
⋮----
// Validate the loaded data with Zod
⋮----
// Reconstruct conversation with validated data
⋮----
// Reconstruct agentStates Map
⋮----
// Deserialize events first
⋮----
// Deduplicate events based on event.id
⋮----
// Log if deduplication occurred
⋮----
phase: data.phase as Phase, // Phase validation happens in schema parsing
⋮----
from: transition.from as Phase, // Phase validation happens in schema parsing
⋮----
async delete(conversationId: string): Promise<void>
⋮----
// Remove from metadata
⋮----
async list(): Promise<ConversationMetadata[]>
⋮----
async search(criteria: ConversationSearchCriteria): Promise<ConversationMetadata[]>
⋮----
async archive(conversationId: string): Promise<void>
⋮----
// Update metadata with lock
⋮----
async restore(conversationId: string): Promise<void>
⋮----
// Update metadata with lock
⋮----
private getConversationPath(conversationId: string): string
⋮----
private getArchivePath(conversationId: string): string
⋮----
private async loadMetadata(): Promise<
⋮----
// Validate with Zod
⋮----
private async saveMetadata(metadata:
⋮----
private async updateMetadata(conversation: Conversation): Promise<void>
⋮----
// Serialize metadata updates to prevent race conditions
⋮----
private async removeFromMetadata(conversationId: string): Promise<void>
⋮----
// Serialize metadata updates to prevent race conditions
</file>

<file path="src/prompts/utils/__tests__/systemPromptBuilder.test.ts">
import { describe, expect, it } from "bun:test";
import { buildSystemPrompt, buildSystemPromptMessages } from "../systemPromptBuilder";
import type { AgentInstance } from "@/agents/types";
import { PHASES } from "@/conversations/phases";
// Import all required fragments
⋮----
// Completion guidance is now injected dynamically with phase transitions
// so it should NOT be in the base system prompt
⋮----
// Orchestrator should not have the yield-back fragment section
⋮----
// Completion guidance is now injected dynamically with phase transitions
// so it should NOT be in the base system prompt
⋮----
// Should have multiple messages
⋮----
// Check for cacheable messages
⋮----
// Check for PROJECT.md and inventory messages
⋮----
// But should still have inventory
⋮----
// Legacy prompt should be the concatenation of all messages
</file>

<file path="src/services/mcp/MCPService.ts">
import { type ChildProcess } from "node:child_process";
⋮----
import { configService } from "@/services/ConfigService";
import type { MCPServerConfig, TenexMCP } from "@/services/config/types";
import type { Tool } from "@/tools/types";
import { logger } from "@/utils/logger";
import { formatAnyError } from "@/utils/error-formatter";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { z } from "zod";
import { adaptMCPTool } from "./MCPToolAdapter";
⋮----
interface MCPClient {
    client: Client;
    process?: ChildProcess;
    serverName: string;
    config: MCPServerConfig;
}
⋮----
// Define Zod schemas for MCP responses
⋮----
type MCPTool = z.infer<typeof MCPToolSchema>;
⋮----
type MCPContent = z.infer<typeof MCPContentSchema>;
⋮----
interface StdioTransportWithProcess extends StdioClientTransport {
    process?: ChildProcess;
    subprocess?: ChildProcess;
}
⋮----
export class MCPService
⋮----
private constructor()
⋮----
static getInstance(): MCPService
⋮----
async initialize(projectPath?: string): Promise<void>
⋮----
// Don't throw - allow the system to continue without MCP
⋮----
private async startServers(mcpConfig: TenexMCP): Promise<void>
⋮----
// Continue with other servers
⋮----
private async startServer(name: string, config: MCPServerConfig): Promise<void>
⋮----
// SECURITY CHECK: Enforce allowedPaths
⋮----
// Only include defined environment variables
⋮----
// Override with config env
⋮----
// Perform health check
⋮----
// Ignore close errors
⋮----
// Store the client with the transport's subprocess
⋮----
// Refresh tool cache when a new server is started
⋮----
private async refreshToolCache(): Promise<void>
⋮----
// Synchronous method to get cached tools
getCachedTools(): Tool[]
⋮----
private async fetchAvailableTools(): Promise<Tool[]>
⋮----
private convertMCPToolToTenexTool(serverName: string, mcpTool: MCPTool): Tool
⋮----
// Use the adapter to create a type-safe tool with Zod schemas
// Cast to any to handle type mismatch between z.record(z.unknown()) and expected properties type
⋮----
async executeTool(
        serverName: string,
        toolName: string,
        args: Record<string, unknown>
): Promise<unknown>
⋮----
// Extract text content from the response
⋮----
async shutdown(): Promise<void>
⋮----
private async shutdownServer(name: string, mcpClient: MCPClient): Promise<void>
⋮----
// Close the client connection
⋮----
// Kill the process if it exists
⋮----
// Give it some time to shut down gracefully
⋮----
// Force kill if graceful shutdown fails
⋮----
// Process already terminated, ignore error
⋮----
// Check if a server is running
isServerRunning(name: string): boolean
⋮----
// Get list of running servers
getRunningServers(): string[]
⋮----
/**
     * Reload MCP service configuration and restart servers
     * This is called when MCP tools are added/removed dynamically
     */
async reload(projectPath?: string): Promise<void>
⋮----
// Shutdown existing servers
⋮----
// Re-initialize with the new configuration
</file>

<file path="src/tools/implementations/agents-discover.ts">
import type { Tool, ExecutionContext, Result, ToolError, Validated, ParameterSchema } from "@/tools/types";
import { createZodSchema, success, failure } from "@/tools/types";
import { NDKAgentDiscovery } from "@/services/NDKAgentDiscovery";
import { getNDK } from "@/nostr";
import { logger } from "@/utils/logger";
import { z } from "zod";
⋮----
// Define the input schema
⋮----
// Define the output type - returns markdown formatted string
interface AgentsDiscoverOutput {
    markdown: string;
    agentsFound: number;
}
⋮----
/**
 * Tool: agents_discover
 * Discover AgentDefinition events from the Nostr network
 */
/**
 * Format discovered agents as markdown
 */
function formatAgentsAsMarkdown(agents: Array<{
  id: string;
  name: string;
  role: string;
  description?: string;
  useCriteria?: string;
  authorPubkey: string;
  createdAt?: number;
}>): string
⋮----
// Discover agents with specified filters
⋮----
// Format results with bech32 encoded IDs
⋮----
// Get bech32 encoded ID from the NDKAgentDefinition event
⋮----
// Apply limit if specified
⋮----
// Format as markdown
</file>

<file path="src/tools/implementations/mcp-discover.ts">
import type { Tool, ExecutionContext, Result, ToolError, Validated, ParameterSchema } from "@/tools/types";
import { createZodSchema, success, failure } from "@/tools/types";
import { getNDK } from "@/nostr";
import { NDKMCPTool } from "@/events/NDKMCPTool";
import { logger } from "@/utils/logger";
import { z } from "zod";
import type { NDKFilter } from "@nostr-dev-kit/ndk";
⋮----
// Define the input schema
⋮----
// Define the output type - returns markdown formatted string
interface McpDiscoverOutput {
    markdown: string;
    toolsFound: number;
}
⋮----
/**
 * Tool: mcp_discover
 * Discover MCP tool definitions from the Nostr network
 */
/**
 * Format discovered tools as markdown
 */
function formatToolsAsMarkdown(tools: Array<{
  id: string;
  name: string;
  description?: string;
  command?: string;
  image?: string;
  slug: string;
  authorPubkey: string;
  createdAt?: number;
}>): string
⋮----
// Build filter for kind:4200 (NDKMCPTool)
⋮----
// Fetch events from network
⋮----
// Convert to NDKMCPTool instances and extract metadata
⋮----
// Get bech32 encoded ID
⋮----
// Apply local filtering if specified
⋮----
// Sort by creation time (newest first)
⋮----
// Limit results
⋮----
// Format as markdown
</file>

<file path="src/commands/debug/chat.ts">
/* eslint-disable no-console */
⋮----
import { AgentRegistry } from "@/agents/AgentRegistry";
import { AgentExecutor } from "@/agents/execution/AgentExecutor";
import type { ExecutionContext } from "@/agents/execution/types";
import type { AgentInstance } from "@/agents/types";
import { ConversationManager } from "@/conversations/ConversationManager";
import { PHASES } from "@/conversations/phases";
import type { Conversation } from "@/conversations/types";
import { createAgentAwareLLMService, loadLLMRouter } from "@/llm";
import { DEFAULT_AGENT_LLM_CONFIG } from "@/llm/constants";
import { initNDK } from "@/nostr/ndkClient";
import { PromptBuilder } from "@/prompts";
import { getProjectContext } from "@/services";
import { formatAnyError } from "@/utils/error-formatter";
import { logDebug, logError, logInfo } from "@/utils/logger";
import { ensureProjectInitialized } from "@/utils/projectInitialization";
import { NDKEvent } from "@nostr-dev-kit/ndk";
import chalk from "chalk";
import { v4 as uuidv4 } from "uuid";
import { debugLog, debugError, debugInfo, debugSection } from "./utils";
⋮----
interface DebugChatOptions {
    systemPrompt?: boolean;
    message?: string;
    llm?: string | boolean;
}
⋮----
export async function runDebugChat(
    initialAgentName: string | undefined,
    options: DebugChatOptions
): Promise<void>
⋮----
// Parse LLM options - --llm should specify a preset name from llms.json
⋮----
// Initialize project context if needed
⋮----
// Create the LLM router
⋮----
// Get project context and create signer
⋮----
// Load agent from registry or create default
⋮----
// Use the existing agent but potentially override llmConfig if --llm specified
⋮----
// Create default debug agent
⋮----
// Create conversation state for AgentExecutor
⋮----
// Initialize NDK for AgentExecutor
⋮----
// Create agent-aware LLM service that routes based on agent's llmConfig
⋮----
// Initialize AgentExecutor
⋮----
// Track messages separately for interactive mode
⋮----
// Show system prompt if requested
⋮----
// Handle single message mode
⋮----
// Create a mock NDKEvent for the debug session
⋮----
mockEvent.kind = 9000; // Tenex conversation event kind
⋮----
// Create execution context
⋮----
// Execute using AgentExecutor without parent tracing context
⋮----
// Interactive REPL mode
⋮----
// Handle special commands
⋮----
// Skip empty inputs
⋮----
// Show thinking indicator
⋮----
// Add user message to tracking
⋮----
// Create a mock NDKEvent for the user message
⋮----
mockEvent.kind = 9000; // Tenex conversation event kind
⋮----
// Create execution context
⋮----
// Execute using AgentExecutor without parent tracing context
⋮----
// Clear thinking indicator
⋮----
// Add assistant response to tracking
⋮----
// Display response
⋮----
// Clear thinking indicator
⋮----
debugLog(""); // Empty line for readability
</file>

<file path="src/commands/debug/index.ts">
import { AgentRegistry } from "@/agents/AgentRegistry";
import { ALL_PHASES, type Phase } from "@/conversations/phases";
import { buildSystemPromptMessages } from "@/prompts/utils/systemPromptBuilder";
import { getProjectContext } from "@/services";
import { mcpService } from "@/services/mcp/MCPService";
import type { Tool } from "@/tools/types";
import { handleCliError } from "@/utils/cli-error";
import { logError, logInfo } from "@/utils/logger";
import { ensureProjectInitialized } from "@/utils/projectInitialization";
import chalk from "chalk";
import { formatMarkdown, colorizeJSON } from "@/utils/formatting";
import type { NDKAgentLesson } from "@/events/NDKAgentLesson";
import { logWarning } from "@/utils/logger";
⋮----
// Format content with enhancements
function formatContentWithEnhancements(content: string, isSystemPrompt = false): string
⋮----
// Handle <tool_use> blocks
⋮----
interface DebugSystemPromptOptions {
    agent: string;
    phase: string;
}
⋮----
export async function runDebugSystemPrompt(options: DebugSystemPromptOptions): Promise<void>
⋮----
// Initialize project context if needed
⋮----
// Load agent from registry
⋮----
// Get all available agents for handoffs
⋮----
// Validate phase
⋮----
// Initialize MCP service to get tools
⋮----
// Continue without MCP tools - don't fail the whole debug command
⋮----
// Build system prompt using the shared function - exactly as production does
// Only pass the current agent's lessons
⋮----
conversation: undefined, // No conversation in debug mode
⋮----
// Display each system message separately with metadata
⋮----
// Display message metadata
⋮----
// Format and display message content
</file>

<file path="src/prompts/utils/systemPromptBuilder.ts">
import type { AgentInstance } from "@/agents/types";
import type { Phase } from "@/conversations/phases";
import type { Conversation } from "@/conversations/types";
import type { NDKAgentLesson } from "@/events/NDKAgentLesson";
import { PromptBuilder } from "@/prompts/core/PromptBuilder";
import type { Tool } from "@/tools/types";
⋮----
import { isVoiceMode } from "@/prompts/fragments/20-voice-mode";
import type { NDKEvent, NDKProject } from "@nostr-dev-kit/ndk";
import { Message } from "multi-llm-ts";
⋮----
export interface BuildSystemPromptOptions {
    // Required data
    agent: AgentInstance;
    phase: Phase;
    project: NDKProject;

    // Optional runtime data
    availableAgents?: AgentInstance[];
    conversation?: Conversation;
    agentLessons?: Map<string, NDKAgentLesson[]>;
    mcpTools?: Tool[];
    triggeringEvent?: NDKEvent;
}
⋮----
// Required data
⋮----
// Optional runtime data
⋮----
export interface BuildStandalonePromptOptions {
    // Required data
    agent: AgentInstance;
    phase: Phase;

    // Optional runtime data
    availableAgents?: AgentInstance[];
    conversation?: Conversation;
    agentLessons?: Map<string, NDKAgentLesson[]>;
    mcpTools?: Tool[];
    triggeringEvent?: NDKEvent;
}
⋮----
// Required data
⋮----
// Optional runtime data
⋮----
export interface SystemMessage {
    message: Message;
    metadata?: {
        cacheable?: boolean;
        cacheKey?: string;
        description?: string;
    };
}
⋮----
/**
 * Builds the system prompt messages for an agent, returning an array of messages
 * with optional caching metadata.
 * This is the single source of truth for system prompt generation.
 */
export function buildSystemPromptMessages(options: BuildSystemPromptOptions): SystemMessage[]
⋮----
// Build the main system prompt
⋮----
// Add PROJECT.md as separate cacheable message for project-manager
⋮----
// Add project inventory as separate cacheable message for all agents
⋮----
/**
 * Builds the main system prompt content (without PROJECT.md and inventory)
 */
function buildMainSystemPrompt(options: BuildSystemPromptOptions): string
⋮----
// Build system prompt with all agent and phase context
⋮----
// Choose identity fragment based on agent type - NO conditionals in fragments
⋮----
// Add available agents - different fragment for orchestrator vs specialist
⋮----
// Add voice mode instructions if this is a voice mode event
// But skip for orchestrator since it doesn't speak to users
⋮----
// Add referenced article context if present
⋮----
// Keep phase-definitions as it's foundational knowledge
// Remove phase-context and phase-constraints as they'll be injected dynamically
⋮----
// Add tools for specialists only
⋮----
// .add("tool-use", {});
⋮----
// Add appropriate fragments based on agent type
⋮----
// Orchestrator only needs routing instructions, no reasoning tags
⋮----
// Specialists use reasoning tags
// systemPromptBuilder.add("specialist-reasoning", {});
⋮----
/**
 * Builds PROJECT.md content as a separate message
 */
function buildProjectMdContent(options: BuildSystemPromptOptions): string | null
⋮----
/**
 * Builds project inventory content as a separate message
 */
function buildProjectInventoryContent(options: BuildSystemPromptOptions): string | null
⋮----
/**
 * Builds system prompt messages for standalone agents (without project context).
 * Includes most fragments except project-specific ones.
 */
export function buildStandaloneSystemPromptMessages(options: BuildStandalonePromptOptions): SystemMessage[]
⋮----
// Build the main system prompt
⋮----
/**
 * Builds the main system prompt for standalone agents
 */
function buildStandaloneMainPrompt(options: BuildStandalonePromptOptions): string
⋮----
// For standalone agents, use a simplified identity without project references
⋮----
projectOwnerPubkey: agent.pubkey, // Use agent's own pubkey as owner
⋮----
// Add available agents if any (for potential handoffs in standalone mode)
⋮----
// Add voice mode instructions if applicable
⋮----
// Add referenced article context if present
⋮----
// Keep phase definitions as foundational knowledge
⋮----
// Add tools
⋮----
// Specialists use reasoning tags
// systemPromptBuilder.add("specialist-reasoning", {});
⋮----
// Add completion guidance for non-orchestrator agents
⋮----
/**
 * Legacy function that returns a single concatenated system prompt string.
 * @deprecated Use buildSystemPromptMessages instead for better caching support
 */
export function buildSystemPrompt(options: BuildSystemPromptOptions): string
</file>

<file path="src/commands/mcp/server.ts">
import { Command } from "commander";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { logger } from "@/utils/logger";
import { initNDK, getNDK } from "@/nostr/ndkClient";
import { ProjectManager } from "@/daemon/ProjectManager";
import { getProjectContext } from "@/services/ProjectContext";
import { NDKAgentLesson } from "@/events/NDKAgentLesson";
import { NDKMCPTool } from "@/events/NDKMCPTool";
import { NDKPrivateKeySigner } from "@nostr-dev-kit/ndk";
⋮----
/**
 * Format discovered MCP tools as markdown
 */
function formatMCPToolsAsMarkdown(tools: Array<{
  id: string;
  name: string;
  description?: string;
  command?: string;
  image?: string;
  slug: string;
  authorPubkey: string;
  createdAt?: number;
}>): string
⋮----
// Add installation instructions at the end
⋮----
import type { NDKSigner } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
import type { AgentInstance } from "@/agents/types";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
⋮----
// Schema definitions for MCP handlers
⋮----
/**
 * Service for managing lessons
 */
class LessonService
⋮----
constructor(
⋮----
async createLesson(
        data: { 
            title: string; 
            lesson: string;
            detailed?: string;
            category?: string;
            hashtags?: string[];
        },
        agentEventId: string,
        signer: NDKSigner
)
⋮----
// Add optional fields if provided
⋮----
// Add reference to the agent event if available
⋮----
// Agent reference would go here but NDKAgentLesson doesn't have agent property
⋮----
// Add project tag for scoping if available
⋮----
async getLessons(filter:
⋮----
kinds: [4129 as any],  // NDKAgentLesson.kind
⋮----
// Initialize NDK
⋮----
// Try to load project context if available, but don't fail if not
⋮----
// Re-throw if it's a different error
⋮----
// NDK is already available from above, no need to redeclare
⋮----
// Wait a moment for relays to connect
⋮----
// Log relay status
⋮----
// Create MCP server
⋮----
// Add tools handler
⋮----
// Handle tool calls
⋮----
// Ensure XOR logic - either agentSlug OR nsec, not both
⋮----
// Determine how to get the signer based on what's provided
⋮----
// Project context mode - use agent slug
⋮----
// Standalone mode - use nsec
⋮----
// Provide context-aware error message
⋮----
// Create LessonService instance
⋮----
// Use LessonService to create the lesson
⋮----
// Ensure XOR logic - either agentSlug OR pubkey, not both
⋮----
// Determine how to get the pubkey
⋮----
// Project context mode - use agent slug
⋮----
// Standalone mode - use provided pubkey
⋮----
// Provide context-aware error message
⋮----
// Create LessonService instance
⋮----
// Use LessonService to fetch lessons
⋮----
// Fetch MCP tool events (kind 4200)
⋮----
// Convert to NDKMCPTool instances and extract metadata
⋮----
// Apply local filtering if specified
⋮----
// Sort by creation time (newest first)
⋮----
// Format as markdown
⋮----
// Import NDK types needed for this handler
⋮----
// Calculate 1 minute ago timestamp for online status check
⋮----
// Fetch both kinds of events in parallel
⋮----
// Fetch 31933 events (NDKProject)
⋮----
// Fetch 24010 events (project status - online agents)
// Only get status events from the last minute to determine if online
⋮----
// Build a map of online agents by project (keyed by project tagId)
⋮----
// Process status events to find online agents
⋮----
// Get the project reference from the "a" tag (this identifies which project the status is for)
⋮----
// Get agent tags from the 24010 event
⋮----
// agent tag format: ["agent", "<pubkey>", "<slug>"]
⋮----
// Convert pubkey to npub format
⋮----
// Store agents for this specific project using its tagId as the key
⋮----
// Once we have the list of projects, fetch spec documents that tag them
⋮----
// Create array of project tag IDs for fetching articles
⋮----
// Fetch NDKArticles (kind 30023) that tag these projects
⋮----
// Process articles
⋮----
// Get project references from the article's tags (for internal filtering only)
⋮----
// Get summary or first 300 bytes of content
⋮----
_projectRefs: projectRefs, // Keep for internal filtering but prefix with underscore
⋮----
// Process project events (31933)
⋮----
// Get the project's tagId for matching with status events and articles
⋮----
// Check if this project has online agents using its tagId
⋮----
// Get the encoded project ID with nostr: prefix
⋮----
// Find spec articles for this project
⋮----
.map(({ _projectRefs, ...article }) => article); // Remove internal _projectRefs field
⋮----
// Sort projects by creation time (newest first)
⋮----
// Start the server
⋮----
// Keep the process alive
</file>

<file path="src/tools/registry.ts">
/**
 * Tool Registry
 * 
 * Central registry for all available tools in the TENEX system.
 * Tools are registered by name and can be retrieved individually
 * or in bulk for agent assignment.
 */
⋮----
import { analyze } from "./implementations/analyze";
import { generateInventoryTool } from "./implementations/generateInventory";
import { lessonLearnTool } from "./implementations/learn";
import { lessonGetTool } from "./implementations/lessonGet";
import { readPathTool } from "./implementations/readPath";
import { writeContextFileTool } from "./implementations/writeContextFile";
import { completeTool } from "./implementations/complete";
import { shellTool } from "./implementations/shell";
import { agentsDiscover } from "./implementations/agents-discover";
import { agentsHire } from "./implementations/agents-hire";
import { mcpDiscover } from "./implementations/mcp-discover";
import { delegateTool } from "./implementations/delegate";
import { nostrProjectsTool } from "./implementations/nostr-projects";
import { claudeCode } from "./implementations/claude_code";
import { switchPhaseTool } from "./implementations/switch_phase";
import type { Tool } from "./types";
⋮----
/**
 * Union type of all available tool names in the system.
 * This ensures type safety when referencing tools throughout the codebase.
 */
export type ToolName = 
  | "read_path"
  | "write_context_file"
  | "complete"
  | "analyze"
  | "generate_inventory"
  | "lesson_learn"
  | "lesson_get"
  | "shell"
  | "agents_discover"
  | "agents_hire"
  | "discover_capabilities"
  | "delegate"
  | "nostr_projects"
  | "claude_code"
  | "switch_phase";
⋮----
/**
 * Registry of all available tools mapped by their canonical names.
 * Tool names serve as unique identifiers for tool lookup and execution.
 */
⋮----
/**
 * Retrieve a single tool by name.
 * 
 * @param name - The canonical name of the tool to retrieve
 * @returns The tool instance if found, undefined otherwise
 */
export function getTool(name: ToolName): Tool<any, any> | undefined
⋮----
/**
 * Retrieve multiple tools by their names.
 * Non-existent tools are silently filtered out.
 * 
 * @param names - Array of tool names to retrieve
 * @returns Array of found tools (may be shorter than input if some tools don't exist)
 */
export function getTools(names: ToolName[]): Tool<any, any>[]
⋮----
/**
 * Get all registered tools in the system.
 * Useful for discovery and capability enumeration.
 * 
 * @returns Array of all registered tools
 */
export function getAllTools(): Tool<any, any>[]
</file>

<file path="package.json">
{
    "name": "tenex-tools",
    "version": "0.4.4",
    "description": "TENEX Command Line Interface",
    "main": "./dist/index.js",
    "types": "./dist/index.d.ts",
    "exports": {
        ".": {
            "import": "./dist/index.js",
            "types": "./dist/index.d.ts"
        }
    },
    "bin": {
        "tenex": "./dist/tenex-wrapper.cjs"
    },
    "files": [
        "dist/**/*.js",
        "dist/**/*.cjs",
        "!dist/**/*.map",
        "!dist/**/__tests__",
        "!dist/**/*.test.js",
        "!dist/**/*.spec.js",
        "!dist/test-utils",
        "src/**/*.ts",
        "!src/**/__tests__",
        "!src/**/*.test.ts",
        "!src/**/*.spec.ts",
        "!src/test-utils",
        "tsconfig.json"
    ],
    "scripts": {
        "start": "bun run ./src/tenex.ts",
        "build": "bun scripts/build-bundled.js",
        "prepublishOnly": "bun run build",
        "postinstall": "patch-package",
        "test": "bun test",
        "test:watch": "bun test --watch",
        "test:coverage": "bun test --coverage",
        "test:unit": "bun test src/**/__tests__/*.test.ts",
        "test:integration": "bun test src/**/__tests__/*.integration.test.ts",
        "test:e2e": "bun test tests/e2e/*.test.ts",
        "typecheck": "tsc --noEmit",
        "lint": "eslint src --ext .ts,.tsx",
        "lint:fix": "eslint src --ext .ts,.tsx --fix",
        "clean": "rm -rf dist node_modules bun.lockb coverage"
    },
    "engines": {
        "node": ">=18.0.0"
    },
    "publishConfig": {
        "access": "public",
        "registry": "https://registry.npmjs.org/"
    },
    "dependencies": {
        "@inquirer/search": "^3.0.15",
        "@modelcontextprotocol/sdk": "^1.13.2",
        "@nostr-dev-kit/ndk": "^2.14.33",
        "chalk": "^5.4.1",
        "cli-table3": "^0.6.5",
        "commander": "^13.1.0",
        "date-fns": "^4.1.0",
        "inquirer": "^12.9.1",
        "multi-llm-ts": "^4.0.3",
        "nostr-tools": "^2.15.0",
        "repomix": "^1.1.0",
        "uuid": "^11.1.0",
        "zod": "^3.25.67"
    },
    "devDependencies": {
        "@eslint/js": "^9.30.1",
        "@types/inquirer": "^9.0.9",
        "esbuild": "^0.25.5",
        "esbuild-plugin-alias": "^0.2.1",
        "eslint": "^9.30.1",
        "jest-mock-extended": "^4.0.0",
        "patch-package": "^8.0.0",
        "typescript": "^5.8.3",
        "typescript-eslint": "^8.35.1"
    },
    "type": "module",
    "keywords": [],
    "author": "",
    "license": "ISC"
}
</file>

<file path="src/agents/execution/ReasonActLoop.ts">
import { formatAnyError } from "@/utils/error-formatter";
import type { LLMService, Tool } from "@/llm/types";
import type { StreamEvent } from "@/llm/types";
import type { NostrPublisher } from "@/nostr/NostrPublisher";
import { StreamPublisher } from "@/nostr/NostrPublisher";
import { buildLLMMetadata } from "@/prompts/utils/llmMetadata";
import type { TracingContext, TracingLogger } from "@/tracing";
import { createTracingLogger, createTracingContext } from "@/tracing";
import { Message } from "multi-llm-ts";
import type { ExecutionContext } from "./types";
import { createExecutionLogger, type ExecutionLogger } from "@/logging/ExecutionLogger";
import { StreamStateManager } from "./StreamStateManager";
import { ToolStreamHandler } from "./ToolStreamHandler";
import { TerminationHandler } from "./TerminationHandler";
import type { ToolExecutionResult } from "@/tools/executor";
⋮----
// Maximum iterations to prevent infinite loops
⋮----
// Track recent tool calls to detect repetition
interface ToolCallRecord {
    tool: string;
    args: string; // JSON stringified for comparison
    timestamp: number;
}
⋮----
args: string; // JSON stringified for comparison
⋮----
/**
 * ReasonActLoop implementation that properly implements the Reason-Act-Observe pattern.
 * Iteratively calls the LLM, executes tools, and feeds results back for further reasoning.
 */
export class ReasonActLoop
⋮----
constructor(
⋮----
/**
     * ExecutionBackend interface implementation
     */
async execute(
        messages: Array<Message>,
        tools: Tool[],
        context: ExecutionContext,
        publisher: NostrPublisher
): Promise<void>
⋮----
// Execute the streaming loop
⋮----
// Drain the generator
⋮----
async *executeStreamingInternal(
        context: ExecutionContext,
        messages: Message[],
        tracingContext: TracingContext,
        publisher?: NostrPublisher,
        tools?: Tool[]
): AsyncGenerator<StreamEvent, void, unknown>
⋮----
// Initialize handlers
⋮----
// Track conversation messages for the iterative loop
⋮----
// Main Reason-Act-Observe loop
⋮----
// Create and process stream for this iteration
⋮----
// Process stream events for this iteration
⋮----
// Yield events from this iteration
⋮----
// Check if we should continue iterating
⋮----
// Add tool results to conversation for next iteration
⋮----
// Agent generated content but no tool calls or terminal tool
// This means the agent has provided a textual response - we should complete
⋮----
isComplete = true; // Complete after generating a response
⋮----
// No tool calls, no terminal tool, AND no content was generated
// This indicates the agent truly has nothing further to do
⋮----
// Finalize stream for this iteration
⋮----
// Check if agent completed properly (just log, don't retry)
⋮----
/**
     * Process a single iteration of the stream and collect results
     */
private async processIterationStream(
        stream: AsyncIterable<StreamEvent>,
        stateManager: StreamStateManager,
        toolHandler: ToolStreamHandler,
        initialStreamPublisher: StreamPublisher | undefined,
        publisher: NostrPublisher | undefined,
        tracingLogger: TracingLogger,
        context: ExecutionContext,
        messages: Message[]
): Promise<
⋮----
// Initialize streaming buffer for this agent
⋮----
// Check for repetitive tool calls
⋮----
// Update streamPublisher reference if a new one was created
⋮----
// Collect tool result for next iteration
⋮----
// Continue processing to capture metadata
⋮----
// Clear the streaming line for this agent
⋮----
// Clear the streaming line for this agent
⋮----
/**
     * Add tool results back to the conversation for the next iteration
     */
private addToolResultsToConversation(
        messages: Message[],
        toolResults: ToolExecutionResult[],
        assistantMessage: string,
        tracingLogger: TracingLogger
): void
⋮----
// Add the assistant's message (with reasoning and tool calls)
⋮----
// Add tool results as user messages for the next iteration
⋮----
/**
     * Format a tool result for inclusion in the conversation
     */
private formatToolResultMessage(result: ToolExecutionResult): string
⋮----
// Format the output as a string
⋮----
/**
     * Handle the done event with metadata processing
     */
private handleDoneEvent(
        event: { response?: any },
        stateManager: StreamStateManager,
        publisher: NostrPublisher | undefined,
        tracingLogger: TracingLogger,
        context: ExecutionContext,
        messages: Message[]
): void
⋮----
// Check for deferred event from complete() tool
⋮----
/**
     * Process deferred event from complete() tool
     */
private async processDeferredEvent(
        serializedEvent: any,
        response: any,
        publisher: NostrPublisher,
        tracingLogger: TracingLogger,
        context: ExecutionContext,
        messages: Message[]
): Promise<void>
⋮----
// Reconstruct the NDKEvent from serialized form
⋮----
// Build and add LLM metadata
⋮----
// Sign and publish with full metadata
⋮----
private handleContentEvent(
        event: { content: string },
        stateManager: StreamStateManager,
        streamPublisher?: StreamPublisher,
        context?: ExecutionContext
): void
⋮----
// Extract and log reasoning if present
⋮----
// Orchestrator should remain silent
⋮----
private handleErrorEvent(
        event: { error: string },
        stateManager: StreamStateManager,
        streamPublisher: StreamPublisher | undefined,
        tracingLogger: TracingLogger,
        context?: ExecutionContext
): void
⋮----
// Orchestrator should remain silent
⋮----
private async finalizeStream(
        streamPublisher: StreamPublisher | undefined,
        stateManager: StreamStateManager,
        context: ExecutionContext,
        messages: Message[]
): Promise<void>
⋮----
// Build metadata for finalization
⋮----
// Only finalize if there's content or metadata
⋮----
private createLLMStream(
        context: ExecutionContext,
        messages: Message[],
        tools?: Tool[],
        publisher?: NostrPublisher
): ReturnType<LLMService["stream"]>
⋮----
private createStreamPublisher(publisher: NostrPublisher | undefined): StreamPublisher | undefined
⋮----
private createFinalEvent(stateManager: StreamStateManager): StreamEvent
⋮----
// Add additional properties for AgentExecutor
⋮----
private async *handleError(
        error: unknown,
        publisher: NostrPublisher | undefined,
        stateManager: StreamStateManager,
        tracingLogger: TracingLogger,
        context: ExecutionContext
): AsyncGenerator<StreamEvent>
⋮----
private logExecutionStart(
        tracingLogger: TracingLogger,
        context: ExecutionContext,
        tools?: Tool[]
): void
⋮----
private extractAndLogReasoning(content: string, context?: ExecutionContext, stateManager?: StreamStateManager): void
⋮----
// Extract thinking content
⋮----
// Process each thinking block
⋮----
// Check if this block has already been logged
⋮----
return; // Skip already logged blocks
⋮----
// Mark this block as logged
⋮----
// Previously parsed reasoning data here but no longer needed
⋮----
private updateStreamingLog(agentKey: string, content: string): void
⋮----
// Only log the new chunk, not the entire buffer
⋮----
// Simple approach: just log each chunk as it arrives
// This avoids the complexity of trying to update in place
⋮----
// Still track the full buffer for debugging if needed
⋮----
private clearStreamingLog(agentKey: string): void
⋮----
// Just clean up and add a newline
⋮----
// Add a newline to separate from next output
⋮----
/**
     * Check if a tool call is being repeated excessively
     * Adds a warning message to the conversation if repetition is detected
     */
private checkToolRepetition(
        tool: string, 
        args: any,
        messages: Message[]
): string | null
⋮----
// Add current call to history
⋮----
// Keep history size limited
⋮----
// Count similar recent calls (same tool and args within last 10 calls)
⋮----
// Add a system message to help the agent understand it's stuck
⋮----
// Don't clear history - keep tracking to detect persistent loops
// this.recentToolCalls = [];
</file>

<file path="src/agents/AgentRegistry.ts">
import { formatAnyError } from "@/utils/error-formatter";
⋮----
import { AgentPublisher } from "@/agents/AgentPublisher";
import type { AgentInstance, AgentConfig, AgentConfigOptionalNsec, StoredAgentData } from "@/agents/types";
import { ensureDirectory, fileExists, readFile, writeJsonFile } from "@/lib/fs";
import { DEFAULT_AGENT_LLM_CONFIG } from "@/llm/constants";
import { getNDK } from "@/nostr";
import { configService } from "@/services";
import { getProjectContext, isProjectContextInitialized } from "@/services";
import type { TenexAgents } from "@/services/config/types";
import { logger } from "@/utils/logger";
import { NDKPrivateKeySigner } from "@nostr-dev-kit/ndk";
import type { NDKProject } from "@nostr-dev-kit/ndk";
import { getBuiltInAgents } from "./builtInAgents";
import { getDefaultToolsForAgent } from "./constants";
⋮----
/**
 * AgentRegistry manages agent configuration and instances for a project.
 * Handles loading, saving, and publishing agents to the Nostr network.
 */
export class AgentRegistry
⋮----
/**
     * Creates a new AgentRegistry instance.
     * @param basePath - Base directory path for the project
     * @param isGlobal - Whether this is the global agent registry
     */
constructor(
        private basePath: string,
        isGlobal = false
)
⋮----
// If basePath already includes .tenex, use it as is
⋮----
async loadFromProject(ndkProject?: NDKProject): Promise<void>
⋮----
// Ensure .tenex directory exists
⋮----
// Load agents using ConfigService
⋮----
// Load global agents first if we're in a project context
⋮----
// Load project/local agents
⋮----
// Load global agents first (if in project context)
⋮----
// Track global agent event IDs and slugs
⋮----
// Load project/local agents (skip if they match a global agent's event ID or slug)
⋮----
// Check if this project agent matches a global agent (same event ID or same slug)
⋮----
// Load built-in agents
⋮----
async ensureAgent(
        name: string,
        config: AgentConfigOptionalNsec,
        ndkProject?: NDKProject,
        fromGlobal = false
): Promise<AgentInstance>
⋮----
// Check if agent already exists in memory
⋮----
// Check if we're in a project context and this agent exists globally
⋮----
// Check by slug first (exact match)
⋮----
// Load the global agent if not already loaded
⋮----
// Load the global agent - use internal method to avoid recursion
⋮----
// Check by eventId if provided
⋮----
// Load the global agent if not already loaded
⋮----
// Load the global agent - use internal method to avoid recursion
⋮----
// Check if we have it in local registry
⋮----
// Generate new nsec for agent
⋮----
// Create new registry entry
⋮----
// Only add eventId if it exists
⋮----
// Check if this is a built-in agent
⋮----
// Save agent definition to file
⋮----
// Only include tools if explicitly provided
⋮----
// For built-in agents, we don't save instructions to the JSON file
// This ensures built-in agents always use the up-to-date instructions
// from the code rather than potentially outdated instructions in the file
⋮----
// Publish kind:0 and request events for new agent
⋮----
// Load agent definition from file
⋮----
// For built-in agents, merge missing fields from TypeScript definition before validation
⋮----
// Fill in missing required fields from built-in definition
⋮----
// Check if this is a built-in agent
⋮----
// Fallback: create definition from config if file doesn't exist
⋮----
// Create NDKPrivateKeySigner
⋮----
// Use the helper to build the agent instance
⋮----
// Store in both maps
⋮----
getAgent(name: string): AgentInstance | undefined
⋮----
getAgentByPubkey(pubkey: string): AgentInstance | undefined
⋮----
getAllAgents(): AgentInstance[]
⋮----
getAllAgentsMap(): Map<string, AgentInstance>
⋮----
getAgentByName(name: string): AgentInstance | undefined
⋮----
private async saveRegistry(): Promise<void>
⋮----
/**
     * Remove an agent by its event ID
     * This removes the agent from memory and deletes its definition file
     */
async removeAgentByEventId(eventId: string): Promise<boolean>
⋮----
// Find the agent with this event ID
⋮----
// Don't allow removing built-in agents
⋮----
// Remove from memory
⋮----
// Remove from registry
⋮----
// Delete the agent definition file
⋮----
// Remove from registry and save
⋮----
/**
     * Remove an agent by its slug
     * This removes the agent from memory and deletes its definition file
     */
async removeAgentBySlug(slug: string): Promise<boolean>
⋮----
// Don't allow removing built-in agents
⋮----
// Remove from memory
⋮----
// Remove from registry
⋮----
// Delete the agent definition file
⋮----
// Remove from registry and save
⋮----
/**
     * Update an agent's LLM configuration persistently
     */
async updateAgentLLMConfig(agentPubkey: string, newLLMConfig: string): Promise<boolean>
⋮----
// Find the agent by pubkey
⋮----
// Update the agent in memory
⋮----
// Find the registry entry by slug
⋮----
// Update the agent definition file
⋮----
// Read existing definition
⋮----
// Create definition from current agent state
⋮----
// Update the llmConfig
⋮----
// Save the updated definition
⋮----
private async publishAgentEvents(
        signer: NDKPrivateKeySigner,
        config: Omit<AgentConfig, "nsec">,
        ndkAgentEventId?: string,
        ndkProject?: NDKProject
): Promise<void>
⋮----
// Use passed NDKProject if available, otherwise fall back to ProjectContext
⋮----
// Check if project context is initialized
⋮----
// Get project context for project event and name
⋮----
// Create agent publisher
⋮----
// Publish agent profile (kind:0) and request event
⋮----
// Don't throw - agent creation should succeed even if publishing fails
⋮----
async loadAgentBySlug(slug: string, fromGlobal = false): Promise<AgentInstance | null>
⋮----
private async loadAgentBySlugInternal(slug: string, fromGlobal = false): Promise<AgentInstance | null>
⋮----
// Determine the correct agents directory
⋮----
// Load agent definition from file
⋮----
// For built-in agents, merge missing fields from TypeScript definition before validation
⋮----
// Fill in missing required fields from built-in definition
⋮----
// Create AgentConfig from definition
⋮----
tools: agentDefinition.tools, // Preserve explicit tools configuration
mcp: agentDefinition.mcp, // Preserve MCP configuration
⋮----
// If loading from global registry, create agent directly without recursive ensureAgent call
⋮----
/**
     * Helper method to build an AgentInstance from configuration and registry data
     * Centralizes the logic for creating agent instances to avoid duplication
     */
private async buildAgentInstance(
        slug: string,
        agentDefinition: StoredAgentData,
        registryEntry: TenexAgents[string],
        signer: NDKPrivateKeySigner,
        isGlobal: boolean
): Promise<AgentInstance>
⋮----
// Determine agent name - use project name for project-manager agent
⋮----
// If project context not available, use default name
⋮----
// Determine if this is a built-in agent
⋮----
// Create Agent instance with all properties set
⋮----
tools: [], // Will be set next
mcp: agentDefinition.mcp ?? true, // Default to true for all agents
⋮----
// Set tools - use explicit tools if configured, otherwise use defaults
⋮----
// Convert tool names to Tool instances
⋮----
// Cast to ToolName[] - tool names from storage are validated at runtime
⋮----
/**
     * Create an agent instance directly without going through ensureAgent
     * Used to avoid infinite recursion when loading global agents
     */
private async createAgentInstance(
        slug: string,
        config: AgentConfig,
        registryEntry: TenexAgents[string]
): Promise<AgentInstance>
⋮----
// Create NDKPrivateKeySigner
⋮----
// Create agent definition from config
⋮----
// Use the helper to build the agent instance
⋮----
true // createAgentInstance is only called for global agents
⋮----
// Store in both maps
⋮----
/**
     * Validate an agent definition has all required fields
     */
private validateAgentDefinition(definition: unknown): asserts definition is StoredAgentData
⋮----
// Optional fields with type validation
// Note: instructions is optional for built-in agents
⋮----
/**
     * Ensure built-in agents are loaded
     */
private async ensureBuiltInAgents(
        ndkProject?: NDKProject
): Promise<void>
⋮----
// Use ensureAgent just like any other agent
⋮----
mcp: true, // Default: true for all agents
⋮----
// Mark as built-in
⋮----
/**
     * Republish kind:0 events for all agents
     * This is called when the project boots to ensure agents are discoverable
     */
async republishAllAgentProfiles(ndkProject: NDKProject): Promise<void>
⋮----
// Use passed NDKProject if available, otherwise fall back to ProjectContext
⋮----
// Check if project context is initialized
⋮----
// Get project context for project event and name
⋮----
// Republish kind:0 for each agent
⋮----
// Continue with other agents even if one fails
</file>

<file path="src/agents/execution/AgentExecutor.ts">
import { formatAnyError } from "@/utils/error-formatter";
import type { ConversationManager } from "@/conversations/ConversationManager";
import type { LLMService } from "@/llm/types";
import { NostrPublisher } from "@/nostr";
import { buildSystemPromptMessages, buildStandaloneSystemPromptMessages } from "@/prompts/utils/systemPromptBuilder";
import { getProjectContext, isProjectContextInitialized } from "@/services";
import { mcpService } from "@/services/mcp/MCPService";
import {
    type TracingContext,
    createAgentExecutionContext,
    createTracingContext,
} from "@/tracing";
import { logger } from "@/utils/logger";
import type { NDKEvent, NDKProject } from "@nostr-dev-kit/ndk";
import type { NDKPrivateKeySigner } from "@nostr-dev-kit/ndk";
import type { AgentInstance } from "@/agents/types";
import { Message } from "multi-llm-ts";
import { ReasonActLoop } from "./ReasonActLoop";
import type { ExecutionContext } from "./types";
⋮----
import { startExecutionTime, stopExecutionTime } from "@/conversations/executionTime";
import { createExecutionLogger } from "@/logging/ExecutionLogger";
import type { NDKAgentLesson } from "@/events/NDKAgentLesson";
⋮----
/**
 * Minimal context for standalone agent execution
 */
export interface StandaloneAgentContext {
    agents: Map<string, AgentInstance>;
    pubkey: string;
    signer: NDKPrivateKeySigner;
    project?: NDKProject;
    getLessonsForAgent?: (pubkey: string) => NDKAgentLesson[];
}
⋮----
export class AgentExecutor
⋮----
constructor(
⋮----
/**
     * Get the execution backend - all agents now use ReasonActLoop
     */
private getBackend(): ReasonActLoop
⋮----
/**
     * Execute an agent's assignment for a conversation with streaming
     */
async execute(context: ExecutionContext, parentTracingContext?: TracingContext): Promise<void>
⋮----
// Create agent execution tracing context
⋮----
// Build messages first to get the Claude session ID
⋮----
// Get the Claude session ID from the conversation state
⋮----
// Build full context with additional properties
⋮----
agentExecutor: this, // Pass this AgentExecutor instance for continue() tool
claudeSessionId, // Pass the determined session ID
⋮----
// Get fresh conversation data for execution time tracking
⋮----
// Start execution time tracking
⋮----
// Log execution flow start
⋮----
// Publish typing indicator start
⋮----
// Log execution flow complete
⋮----
// Stop typing indicator after successful execution
⋮----
// Clean up the publisher resources
⋮----
// Conversation updates are now handled by NostrPublisher
⋮----
// Log execution flow failure
⋮----
// Stop execution time tracking even on error
⋮----
// Conversation saving is now handled by NostrPublisher
⋮----
// Ensure typing indicator is stopped even on error
⋮----
// Clean up the publisher resources
⋮----
/**
     * Build the messages array for the agent execution
     */
private async buildMessages(
        context: ExecutionContext,
        _triggeringEvent: NDKEvent
): Promise<Message[]>
⋮----
// Get fresh conversation data
⋮----
// Get MCP tools for the prompt
⋮----
// Check if we're in standalone mode or project mode
⋮----
// Standalone mode - use minimal context
⋮----
// Get lessons if available
⋮----
// Build standalone system prompt
⋮----
// Add all system messages
⋮----
// Project mode - use full project context
⋮----
// Create tag map for efficient lookup
⋮----
// Get all available agents for handoffs
⋮----
// Build system prompt using the shared function
// Only pass the current agent's lessons
⋮----
// Build system prompt messages for all agents (including orchestrator)
⋮----
// Add all system messages
⋮----
// Fallback: No context available - use absolute minimal prompt
⋮----
// Check for #debug flag in triggering event content
⋮----
// All agents now get conversation transcript
⋮----
// Add the agent's messages
⋮----
/**
     * Execute with streaming support
     */
private async executeWithStreaming(
        context: ExecutionContext,
        messages: Message[],
        _tracingContext: TracingContext
): Promise<void>
⋮----
// Get tools for response processing - use agent's configured tools
⋮----
// Add MCP tools if available and agent has MCP access
⋮----
// Add claude_code tool for agents that explicitly have it in their tools list
// This is now handled through agent configuration directly
⋮----
// Get the backend - all agents use ReasonActLoop now
⋮----
// Execute using the backend - all backends now use the same interface
</file>

<file path="src/conversations/ConversationManager.ts">
import type { Phase } from "@/conversations/phases";
import type { AgentState, PhaseTransition, Conversation, ConversationMetadata } from "@/conversations/types";
import { ensureDirectory } from "@/lib/fs";
import type { TracingContext } from "@/tracing";
import { TENEX_DIR, CONVERSATIONS_DIR } from "@/constants";
import type { NDKEvent } from "@nostr-dev-kit/ndk";
import { logger } from "@/utils/logger";
import { FileSystemAdapter } from "./persistence";
import type { ConversationPersistenceAdapter } from "./persistence/types";
import type { AgentInstance } from "@/agents/types";
import { Message } from "multi-llm-ts";
import { ExecutionQueueManager } from "./executionQueue";
import {
    ConversationStore,
    ConversationPersistenceService,
    PhaseManager,
    ConversationEventProcessor,
    ProjectAgentResolver,
    ConversationCoordinator,
} from "./services";
⋮----
/**
 * ConversationManager - Now a facade that delegates to specialized services.
 * Maintained for backward compatibility.
 */
export class ConversationManager
⋮----
constructor(
        private projectPath: string, 
        persistence?: ConversationPersistenceAdapter,
        executionQueueManager?: ExecutionQueueManager
)
⋮----
// Create services
⋮----
// Create coordinator
⋮----
getProjectPath(): string
⋮----
getExecutionQueueManager(): ExecutionQueueManager | undefined
⋮----
setExecutionQueueManager(manager: ExecutionQueueManager): void
⋮----
async initialize(): Promise<void>
⋮----
// Load task mappings from persistence
⋮----
async createConversation(event: NDKEvent): Promise<Conversation>
⋮----
getConversation(id: string): Conversation | undefined
⋮----
async loadConversation(id: string): Promise<Conversation | undefined>
⋮----
// First check if already in memory
⋮----
// Try to load from disk
⋮----
// Ensure execution time is initialized
⋮----
// Ensure agentStates is a Map
⋮----
// Add to store
⋮----
async updatePhase(
        id: string,
        phase: Phase,
        message: string,
        agentPubkey: string,
        agentName: string,
        reason?: string,
        summary?: string
): Promise<boolean>
⋮----
async addEvent(conversationId: string, event: NDKEvent): Promise<void>
⋮----
async updateMetadata(
        conversationId: string,
        metadata: Partial<ConversationMetadata>
): Promise<void>
⋮----
getPhaseHistory(conversationId: string): NDKEvent[]
⋮----
getAllConversations(): Conversation[]
⋮----
getConversationByEvent(eventId: string): Conversation | undefined
⋮----
async buildAgentMessages(
        conversationId: string,
        targetAgent: AgentInstance,
        triggeringEvent?: NDKEvent,
        handoff?: PhaseTransition
): Promise<
⋮----
async buildOrchestratorRoutingContext(
        conversationId: string,
        triggeringEvent?: NDKEvent
): Promise<OrchestratorRoutingContext>
⋮----
async updateAgentState(
        conversationId: string, 
        agentSlug: string, 
        updates: Partial<AgentState>
): Promise<void>
⋮----
async saveConversation(conversationId: string): Promise<void>
⋮----
// The coordinator auto-saves, but keep this for compatibility
⋮----
// Trigger a save through metadata update
⋮----
async archiveConversation(conversationId: string): Promise<void>
⋮----
async searchConversations(query: string): Promise<Conversation[]>
⋮----
async cleanup(): Promise<void>
⋮----
getTracingContext(conversationId: string): TracingContext | undefined
⋮----
cleanupConversationMetadata(conversationId: string): void
⋮----
async completeConversation(conversationId: string): Promise<void>
⋮----
async startOrchestratorTurn(
        conversationId: string,
        phase: Phase,
        agents: string[],
        reason?: string
): Promise<string>
⋮----
async addCompletionToTurn(
        _conversationId: string,
        _agentPubkey: string,
        _message: string
): Promise<void>
⋮----
// No-op: Turn tracking removed in PM-centric routing
⋮----
isCurrentTurnComplete(_conversationId: string): boolean
⋮----
// Always true: NDKTask-based delegation handles completion tracking
⋮----
getCurrentTurn(_conversationId: string): null
⋮----
// No turn tracking in PM-centric routing
⋮----
/**
     * Register a task ID with its associated conversation and Claude session
     */
async registerTaskMapping(taskId: string, conversationId: string, claudeSessionId?: string): Promise<void>
⋮----
// Save mappings to disk
⋮----
/**
     * Get conversation and session info for a task ID
     */
getTaskMapping(taskId: string):
⋮----
/**
     * Remove a task mapping
     */
async removeTaskMapping(taskId: string): Promise<void>
⋮----
// Save updated mappings to disk
⋮----
/**
     * Load task mappings from disk
     */
private async loadTaskMappings(): Promise<void>
⋮----
// File doesn't exist yet or is corrupted - start with empty mappings
⋮----
/**
     * Save task mappings to disk
     */
private async saveTaskMappings(): Promise<void>
</file>

</files>
